
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Command
 * 
 */
export type Command = $Result.DefaultSelection<Prisma.$CommandPayload>
/**
 * Model CommandProject
 * 
 */
export type CommandProject = $Result.DefaultSelection<Prisma.$CommandProjectPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Planning
 * 
 */
export type Planning = $Result.DefaultSelection<Prisma.$PlanningPayload>
/**
 * Model Sprint
 * 
 */
export type Sprint = $Result.DefaultSelection<Prisma.$SprintPayload>
/**
 * Model Operation
 * 
 */
export type Operation = $Result.DefaultSelection<Prisma.$OperationPayload>
/**
 * Model WorkFlowNode
 * 
 */
export type WorkFlowNode = $Result.DefaultSelection<Prisma.$WorkFlowNodePayload>
/**
 * Model WorkFlowEdge
 * 
 */
export type WorkFlowEdge = $Result.DefaultSelection<Prisma.$WorkFlowEdgePayload>
/**
 * Model WorkFlow
 * 
 */
export type WorkFlow = $Result.DefaultSelection<Prisma.$WorkFlowPayload>
/**
 * Model OperationHistory
 * 
 */
export type OperationHistory = $Result.DefaultSelection<Prisma.$OperationHistoryPayload>
/**
 * Model Expertise
 * 
 */
export type Expertise = $Result.DefaultSelection<Prisma.$ExpertisePayload>
/**
 * Model History
 * 
 */
export type History = $Result.DefaultSelection<Prisma.$HistoryPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model OperationRecord
 * 
 */
export type OperationRecord = $Result.DefaultSelection<Prisma.$OperationRecordPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  SYS_ADMIN: 'SYS_ADMIN',
  CLIENT: 'CLIENT',
  OPERATOR: 'OPERATOR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  ACTIVE: 'ACTIVE',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const ActionType: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]


export const EntityType: {
  EXPERTISE: 'EXPERTISE',
  COMMAND: 'COMMAND',
  PROJECT: 'PROJECT',
  POSTS: 'POSTS',
  DEVICE: 'DEVICE'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

export type EntityType = $Enums.EntityType

export const EntityType: typeof $Enums.EntityType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.command`: Exposes CRUD operations for the **Command** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commands
    * const commands = await prisma.command.findMany()
    * ```
    */
  get command(): Prisma.CommandDelegate<ExtArgs>;

  /**
   * `prisma.commandProject`: Exposes CRUD operations for the **CommandProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommandProjects
    * const commandProjects = await prisma.commandProject.findMany()
    * ```
    */
  get commandProject(): Prisma.CommandProjectDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.planning`: Exposes CRUD operations for the **Planning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plannings
    * const plannings = await prisma.planning.findMany()
    * ```
    */
  get planning(): Prisma.PlanningDelegate<ExtArgs>;

  /**
   * `prisma.sprint`: Exposes CRUD operations for the **Sprint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sprints
    * const sprints = await prisma.sprint.findMany()
    * ```
    */
  get sprint(): Prisma.SprintDelegate<ExtArgs>;

  /**
   * `prisma.operation`: Exposes CRUD operations for the **Operation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operations
    * const operations = await prisma.operation.findMany()
    * ```
    */
  get operation(): Prisma.OperationDelegate<ExtArgs>;

  /**
   * `prisma.workFlowNode`: Exposes CRUD operations for the **WorkFlowNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkFlowNodes
    * const workFlowNodes = await prisma.workFlowNode.findMany()
    * ```
    */
  get workFlowNode(): Prisma.WorkFlowNodeDelegate<ExtArgs>;

  /**
   * `prisma.workFlowEdge`: Exposes CRUD operations for the **WorkFlowEdge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkFlowEdges
    * const workFlowEdges = await prisma.workFlowEdge.findMany()
    * ```
    */
  get workFlowEdge(): Prisma.WorkFlowEdgeDelegate<ExtArgs>;

  /**
   * `prisma.workFlow`: Exposes CRUD operations for the **WorkFlow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkFlows
    * const workFlows = await prisma.workFlow.findMany()
    * ```
    */
  get workFlow(): Prisma.WorkFlowDelegate<ExtArgs>;

  /**
   * `prisma.operationHistory`: Exposes CRUD operations for the **OperationHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationHistories
    * const operationHistories = await prisma.operationHistory.findMany()
    * ```
    */
  get operationHistory(): Prisma.OperationHistoryDelegate<ExtArgs>;

  /**
   * `prisma.expertise`: Exposes CRUD operations for the **Expertise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expertise
    * const expertise = await prisma.expertise.findMany()
    * ```
    */
  get expertise(): Prisma.ExpertiseDelegate<ExtArgs>;

  /**
   * `prisma.history`: Exposes CRUD operations for the **History** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Histories
    * const histories = await prisma.history.findMany()
    * ```
    */
  get history(): Prisma.HistoryDelegate<ExtArgs>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs>;

  /**
   * `prisma.operationRecord`: Exposes CRUD operations for the **OperationRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationRecords
    * const operationRecords = await prisma.operationRecord.findMany()
    * ```
    */
  get operationRecord(): Prisma.OperationRecordDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.1
   * Query Engine version: 5675a3182f972f1a8f31d16eee6abf4fd54910e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    Command: 'Command',
    CommandProject: 'CommandProject',
    Post: 'Post',
    Planning: 'Planning',
    Sprint: 'Sprint',
    Operation: 'Operation',
    WorkFlowNode: 'WorkFlowNode',
    WorkFlowEdge: 'WorkFlowEdge',
    WorkFlow: 'WorkFlow',
    OperationHistory: 'OperationHistory',
    Expertise: 'Expertise',
    History: 'History',
    Device: 'Device',
    OperationRecord: 'OperationRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'project' | 'command' | 'commandProject' | 'post' | 'planning' | 'sprint' | 'operation' | 'workFlowNode' | 'workFlowEdge' | 'workFlow' | 'operationHistory' | 'expertise' | 'history' | 'device' | 'operationRecord'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>,
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Command: {
        payload: Prisma.$CommandPayload<ExtArgs>
        fields: Prisma.CommandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          findFirst: {
            args: Prisma.CommandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          findMany: {
            args: Prisma.CommandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>[]
          }
          create: {
            args: Prisma.CommandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          createMany: {
            args: Prisma.CommandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommandCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>[]
          }
          delete: {
            args: Prisma.CommandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          update: {
            args: Prisma.CommandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          deleteMany: {
            args: Prisma.CommandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          aggregate: {
            args: Prisma.CommandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommand>
          }
          groupBy: {
            args: Prisma.CommandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommandGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandCountArgs<ExtArgs>,
            result: $Utils.Optional<CommandCountAggregateOutputType> | number
          }
        }
      }
      CommandProject: {
        payload: Prisma.$CommandProjectPayload<ExtArgs>
        fields: Prisma.CommandProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandProjectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandProjectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload>
          }
          findFirst: {
            args: Prisma.CommandProjectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandProjectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload>
          }
          findMany: {
            args: Prisma.CommandProjectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload>[]
          }
          create: {
            args: Prisma.CommandProjectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload>
          }
          createMany: {
            args: Prisma.CommandProjectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommandProjectCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload>[]
          }
          delete: {
            args: Prisma.CommandProjectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload>
          }
          update: {
            args: Prisma.CommandProjectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload>
          }
          deleteMany: {
            args: Prisma.CommandProjectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommandProjectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommandProjectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommandProjectPayload>
          }
          aggregate: {
            args: Prisma.CommandProjectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommandProject>
          }
          groupBy: {
            args: Prisma.CommandProjectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommandProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandProjectCountArgs<ExtArgs>,
            result: $Utils.Optional<CommandProjectCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>,
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Planning: {
        payload: Prisma.$PlanningPayload<ExtArgs>
        fields: Prisma.PlanningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanningFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanningFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          findFirst: {
            args: Prisma.PlanningFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanningFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          findMany: {
            args: Prisma.PlanningFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>[]
          }
          create: {
            args: Prisma.PlanningCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          createMany: {
            args: Prisma.PlanningCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanningCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>[]
          }
          delete: {
            args: Prisma.PlanningDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          update: {
            args: Prisma.PlanningUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          deleteMany: {
            args: Prisma.PlanningDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlanningUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlanningUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          aggregate: {
            args: Prisma.PlanningAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlanning>
          }
          groupBy: {
            args: Prisma.PlanningGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlanningGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanningCountArgs<ExtArgs>,
            result: $Utils.Optional<PlanningCountAggregateOutputType> | number
          }
        }
      }
      Sprint: {
        payload: Prisma.$SprintPayload<ExtArgs>
        fields: Prisma.SprintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SprintFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SprintFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findFirst: {
            args: Prisma.SprintFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SprintFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findMany: {
            args: Prisma.SprintFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          create: {
            args: Prisma.SprintCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          createMany: {
            args: Prisma.SprintCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SprintCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          delete: {
            args: Prisma.SprintDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          update: {
            args: Prisma.SprintUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          deleteMany: {
            args: Prisma.SprintDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SprintUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SprintUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          aggregate: {
            args: Prisma.SprintAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSprint>
          }
          groupBy: {
            args: Prisma.SprintGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SprintGroupByOutputType>[]
          }
          count: {
            args: Prisma.SprintCountArgs<ExtArgs>,
            result: $Utils.Optional<SprintCountAggregateOutputType> | number
          }
        }
      }
      Operation: {
        payload: Prisma.$OperationPayload<ExtArgs>
        fields: Prisma.OperationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          findFirst: {
            args: Prisma.OperationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          findMany: {
            args: Prisma.OperationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>[]
          }
          create: {
            args: Prisma.OperationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          createMany: {
            args: Prisma.OperationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>[]
          }
          delete: {
            args: Prisma.OperationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          update: {
            args: Prisma.OperationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          deleteMany: {
            args: Prisma.OperationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OperationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OperationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          aggregate: {
            args: Prisma.OperationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOperation>
          }
          groupBy: {
            args: Prisma.OperationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OperationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationCountArgs<ExtArgs>,
            result: $Utils.Optional<OperationCountAggregateOutputType> | number
          }
        }
      }
      WorkFlowNode: {
        payload: Prisma.$WorkFlowNodePayload<ExtArgs>
        fields: Prisma.WorkFlowNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkFlowNodeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkFlowNodeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload>
          }
          findFirst: {
            args: Prisma.WorkFlowNodeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkFlowNodeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload>
          }
          findMany: {
            args: Prisma.WorkFlowNodeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload>[]
          }
          create: {
            args: Prisma.WorkFlowNodeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload>
          }
          createMany: {
            args: Prisma.WorkFlowNodeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkFlowNodeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload>[]
          }
          delete: {
            args: Prisma.WorkFlowNodeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload>
          }
          update: {
            args: Prisma.WorkFlowNodeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload>
          }
          deleteMany: {
            args: Prisma.WorkFlowNodeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkFlowNodeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkFlowNodeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowNodePayload>
          }
          aggregate: {
            args: Prisma.WorkFlowNodeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkFlowNode>
          }
          groupBy: {
            args: Prisma.WorkFlowNodeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkFlowNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkFlowNodeCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkFlowNodeCountAggregateOutputType> | number
          }
        }
      }
      WorkFlowEdge: {
        payload: Prisma.$WorkFlowEdgePayload<ExtArgs>
        fields: Prisma.WorkFlowEdgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkFlowEdgeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkFlowEdgeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload>
          }
          findFirst: {
            args: Prisma.WorkFlowEdgeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkFlowEdgeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload>
          }
          findMany: {
            args: Prisma.WorkFlowEdgeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload>[]
          }
          create: {
            args: Prisma.WorkFlowEdgeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload>
          }
          createMany: {
            args: Prisma.WorkFlowEdgeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkFlowEdgeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload>[]
          }
          delete: {
            args: Prisma.WorkFlowEdgeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload>
          }
          update: {
            args: Prisma.WorkFlowEdgeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload>
          }
          deleteMany: {
            args: Prisma.WorkFlowEdgeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkFlowEdgeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkFlowEdgeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowEdgePayload>
          }
          aggregate: {
            args: Prisma.WorkFlowEdgeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkFlowEdge>
          }
          groupBy: {
            args: Prisma.WorkFlowEdgeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkFlowEdgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkFlowEdgeCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkFlowEdgeCountAggregateOutputType> | number
          }
        }
      }
      WorkFlow: {
        payload: Prisma.$WorkFlowPayload<ExtArgs>
        fields: Prisma.WorkFlowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkFlowFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkFlowFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload>
          }
          findFirst: {
            args: Prisma.WorkFlowFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkFlowFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload>
          }
          findMany: {
            args: Prisma.WorkFlowFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload>[]
          }
          create: {
            args: Prisma.WorkFlowCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload>
          }
          createMany: {
            args: Prisma.WorkFlowCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkFlowCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload>[]
          }
          delete: {
            args: Prisma.WorkFlowDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload>
          }
          update: {
            args: Prisma.WorkFlowUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload>
          }
          deleteMany: {
            args: Prisma.WorkFlowDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkFlowUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkFlowUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkFlowPayload>
          }
          aggregate: {
            args: Prisma.WorkFlowAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkFlow>
          }
          groupBy: {
            args: Prisma.WorkFlowGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkFlowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkFlowCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkFlowCountAggregateOutputType> | number
          }
        }
      }
      OperationHistory: {
        payload: Prisma.$OperationHistoryPayload<ExtArgs>
        fields: Prisma.OperationHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload>
          }
          findFirst: {
            args: Prisma.OperationHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload>
          }
          findMany: {
            args: Prisma.OperationHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload>[]
          }
          create: {
            args: Prisma.OperationHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload>
          }
          createMany: {
            args: Prisma.OperationHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationHistoryCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload>[]
          }
          delete: {
            args: Prisma.OperationHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload>
          }
          update: {
            args: Prisma.OperationHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload>
          }
          deleteMany: {
            args: Prisma.OperationHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OperationHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OperationHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationHistoryPayload>
          }
          aggregate: {
            args: Prisma.OperationHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOperationHistory>
          }
          groupBy: {
            args: Prisma.OperationHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OperationHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<OperationHistoryCountAggregateOutputType> | number
          }
        }
      }
      Expertise: {
        payload: Prisma.$ExpertisePayload<ExtArgs>
        fields: Prisma.ExpertiseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpertiseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpertiseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload>
          }
          findFirst: {
            args: Prisma.ExpertiseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpertiseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload>
          }
          findMany: {
            args: Prisma.ExpertiseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload>[]
          }
          create: {
            args: Prisma.ExpertiseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload>
          }
          createMany: {
            args: Prisma.ExpertiseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpertiseCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload>[]
          }
          delete: {
            args: Prisma.ExpertiseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload>
          }
          update: {
            args: Prisma.ExpertiseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload>
          }
          deleteMany: {
            args: Prisma.ExpertiseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExpertiseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExpertiseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpertisePayload>
          }
          aggregate: {
            args: Prisma.ExpertiseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExpertise>
          }
          groupBy: {
            args: Prisma.ExpertiseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExpertiseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpertiseCountArgs<ExtArgs>,
            result: $Utils.Optional<ExpertiseCountAggregateOutputType> | number
          }
        }
      }
      History: {
        payload: Prisma.$HistoryPayload<ExtArgs>
        fields: Prisma.HistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          findFirst: {
            args: Prisma.HistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          findMany: {
            args: Prisma.HistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>[]
          }
          create: {
            args: Prisma.HistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          createMany: {
            args: Prisma.HistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistoryCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>[]
          }
          delete: {
            args: Prisma.HistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          update: {
            args: Prisma.HistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          deleteMany: {
            args: Prisma.HistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          aggregate: {
            args: Prisma.HistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistory>
          }
          groupBy: {
            args: Prisma.HistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<HistoryCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>,
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      OperationRecord: {
        payload: Prisma.$OperationRecordPayload<ExtArgs>
        fields: Prisma.OperationRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload>
          }
          findFirst: {
            args: Prisma.OperationRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload>
          }
          findMany: {
            args: Prisma.OperationRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload>[]
          }
          create: {
            args: Prisma.OperationRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload>
          }
          createMany: {
            args: Prisma.OperationRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationRecordCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload>[]
          }
          delete: {
            args: Prisma.OperationRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload>
          }
          update: {
            args: Prisma.OperationRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload>
          }
          deleteMany: {
            args: Prisma.OperationRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OperationRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OperationRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OperationRecordPayload>
          }
          aggregate: {
            args: Prisma.OperationRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOperationRecord>
          }
          groupBy: {
            args: Prisma.OperationRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OperationRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<OperationRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    commands: number
    expertises: number
    histories: number
    plannings: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commands?: boolean | UserCountOutputTypeCountCommandsArgs
    expertises?: boolean | UserCountOutputTypeCountExpertisesArgs
    histories?: boolean | UserCountOutputTypeCountHistoriesArgs
    plannings?: boolean | UserCountOutputTypeCountPlanningsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpertisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpertiseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    commandProjects: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandProjects?: boolean | ProjectCountOutputTypeCountCommandProjectsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCommandProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandProjectWhereInput
  }


  /**
   * Count Type CommandCountOutputType
   */

  export type CommandCountOutputType = {
    commandProjects: number
  }

  export type CommandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandProjects?: boolean | CommandCountOutputTypeCountCommandProjectsArgs
  }

  // Custom InputTypes
  /**
   * CommandCountOutputType without action
   */
  export type CommandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandCountOutputType
     */
    select?: CommandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommandCountOutputType without action
   */
  export type CommandCountOutputTypeCountCommandProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandProjectWhereInput
  }


  /**
   * Count Type CommandProjectCountOutputType
   */

  export type CommandProjectCountOutputType = {
    planings: number
  }

  export type CommandProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planings?: boolean | CommandProjectCountOutputTypeCountPlaningsArgs
  }

  // Custom InputTypes
  /**
   * CommandProjectCountOutputType without action
   */
  export type CommandProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProjectCountOutputType
     */
    select?: CommandProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommandProjectCountOutputType without action
   */
  export type CommandProjectCountOutputTypeCountPlaningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    plannings: number
    expertises: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plannings?: boolean | PostCountOutputTypeCountPlanningsArgs
    expertises?: boolean | PostCountOutputTypeCountExpertisesArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountExpertisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpertiseWhereInput
  }


  /**
   * Count Type PlanningCountOutputType
   */

  export type PlanningCountOutputType = {
    operationHistory: number
  }

  export type PlanningCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationHistory?: boolean | PlanningCountOutputTypeCountOperationHistoryArgs
  }

  // Custom InputTypes
  /**
   * PlanningCountOutputType without action
   */
  export type PlanningCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningCountOutputType
     */
    select?: PlanningCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanningCountOutputType without action
   */
  export type PlanningCountOutputTypeCountOperationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationHistoryWhereInput
  }


  /**
   * Count Type OperationCountOutputType
   */

  export type OperationCountOutputType = {
    plannings: number
    posts: number
    WorkflowNode: number
  }

  export type OperationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plannings?: boolean | OperationCountOutputTypeCountPlanningsArgs
    posts?: boolean | OperationCountOutputTypeCountPostsArgs
    WorkflowNode?: boolean | OperationCountOutputTypeCountWorkflowNodeArgs
  }

  // Custom InputTypes
  /**
   * OperationCountOutputType without action
   */
  export type OperationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationCountOutputType
     */
    select?: OperationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperationCountOutputType without action
   */
  export type OperationCountOutputTypeCountPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
  }

  /**
   * OperationCountOutputType without action
   */
  export type OperationCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * OperationCountOutputType without action
   */
  export type OperationCountOutputTypeCountWorkflowNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkFlowNodeWhereInput
  }


  /**
   * Count Type WorkFlowNodeCountOutputType
   */

  export type WorkFlowNodeCountOutputType = {
    targetEdges: number
    sourceEdges: number
  }

  export type WorkFlowNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetEdges?: boolean | WorkFlowNodeCountOutputTypeCountTargetEdgesArgs
    sourceEdges?: boolean | WorkFlowNodeCountOutputTypeCountSourceEdgesArgs
  }

  // Custom InputTypes
  /**
   * WorkFlowNodeCountOutputType without action
   */
  export type WorkFlowNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNodeCountOutputType
     */
    select?: WorkFlowNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkFlowNodeCountOutputType without action
   */
  export type WorkFlowNodeCountOutputTypeCountTargetEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkFlowEdgeWhereInput
  }

  /**
   * WorkFlowNodeCountOutputType without action
   */
  export type WorkFlowNodeCountOutputTypeCountSourceEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkFlowEdgeWhereInput
  }


  /**
   * Count Type WorkFlowCountOutputType
   */

  export type WorkFlowCountOutputType = {
    WorkFlowEdge: number
    WorkflowNode: number
  }

  export type WorkFlowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WorkFlowEdge?: boolean | WorkFlowCountOutputTypeCountWorkFlowEdgeArgs
    WorkflowNode?: boolean | WorkFlowCountOutputTypeCountWorkflowNodeArgs
  }

  // Custom InputTypes
  /**
   * WorkFlowCountOutputType without action
   */
  export type WorkFlowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowCountOutputType
     */
    select?: WorkFlowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkFlowCountOutputType without action
   */
  export type WorkFlowCountOutputTypeCountWorkFlowEdgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkFlowEdgeWhereInput
  }

  /**
   * WorkFlowCountOutputType without action
   */
  export type WorkFlowCountOutputTypeCountWorkflowNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkFlowNodeWhereInput
  }


  /**
   * Count Type ExpertiseCountOutputType
   */

  export type ExpertiseCountOutputType = {
    operations: number
    posts: number
  }

  export type ExpertiseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operations?: boolean | ExpertiseCountOutputTypeCountOperationsArgs
    posts?: boolean | ExpertiseCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * ExpertiseCountOutputType without action
   */
  export type ExpertiseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertiseCountOutputType
     */
    select?: ExpertiseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpertiseCountOutputType without action
   */
  export type ExpertiseCountOutputTypeCountOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationWhereInput
  }

  /**
   * ExpertiseCountOutputType without action
   */
  export type ExpertiseCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    password: string | null
    image: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    password: string | null
    image: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    password: number
    image: number
    phone: number
    attributes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    password?: true
    image?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    password?: true
    image?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    password?: true
    image?: true
    phone?: true
    attributes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    role: $Enums.Role
    password: string
    image: string | null
    phone: string | null
    attributes: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    password?: boolean
    image?: boolean
    phone?: boolean
    attributes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commands?: boolean | User$commandsArgs<ExtArgs>
    expertises?: boolean | User$expertisesArgs<ExtArgs>
    histories?: boolean | User$historiesArgs<ExtArgs>
    plannings?: boolean | User$planningsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    password?: boolean
    image?: boolean
    phone?: boolean
    attributes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    password?: boolean
    image?: boolean
    phone?: boolean
    attributes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commands?: boolean | User$commandsArgs<ExtArgs>
    expertises?: boolean | User$expertisesArgs<ExtArgs>
    histories?: boolean | User$historiesArgs<ExtArgs>
    plannings?: boolean | User$planningsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      commands: Prisma.$CommandPayload<ExtArgs>[]
      expertises: Prisma.$ExpertisePayload<ExtArgs>[]
      histories: Prisma.$HistoryPayload<ExtArgs>[]
      plannings: Prisma.$PlanningPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: $Enums.Role
      password: string
      image: string | null
      phone: string | null
      attributes: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends UserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    commands<T extends User$commandsArgs<ExtArgs> = {}>(args?: Subset<T, User$commandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'findMany'> | Null>;

    expertises<T extends User$expertisesArgs<ExtArgs> = {}>(args?: Subset<T, User$expertisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'findMany'> | Null>;

    histories<T extends User$historiesArgs<ExtArgs> = {}>(args?: Subset<T, User$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    plannings<T extends User$planningsArgs<ExtArgs> = {}>(args?: Subset<T, User$planningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly attributes: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.commands
   */
  export type User$commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    cursor?: CommandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * User.expertises
   */
  export type User$expertisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    where?: ExpertiseWhereInput
    orderBy?: ExpertiseOrderByWithRelationInput | ExpertiseOrderByWithRelationInput[]
    cursor?: ExpertiseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpertiseScalarFieldEnum | ExpertiseScalarFieldEnum[]
  }

  /**
   * User.histories
   */
  export type User$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    where?: HistoryWhereInput
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    cursor?: HistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * User.plannings
   */
  export type User$planningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    cursor?: PlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: boolean | null
    workFlowId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: boolean | null
    workFlowId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    workFlowId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    workFlowId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    workFlowId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    workFlowId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: boolean
    workFlowId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    workFlowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandProjects?: boolean | Project$commandProjectsArgs<ExtArgs>
    workFlow?: boolean | Project$workFlowArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    workFlowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workFlow?: boolean | Project$workFlowArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    workFlowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandProjects?: boolean | Project$commandProjectsArgs<ExtArgs>
    workFlow?: boolean | Project$workFlowArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workFlow?: boolean | Project$workFlowArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      commandProjects: Prisma.$CommandProjectPayload<ExtArgs>[]
      workFlow: Prisma.$WorkFlowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: boolean
      workFlowId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ProjectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    commandProjects<T extends Project$commandProjectsArgs<ExtArgs> = {}>(args?: Subset<T, Project$commandProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    workFlow<T extends Project$workFlowArgs<ExtArgs> = {}>(args?: Subset<T, Project$workFlowArgs<ExtArgs>>): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'Boolean'>
    readonly workFlowId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.commandProjects
   */
  export type Project$commandProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    where?: CommandProjectWhereInput
    orderBy?: CommandProjectOrderByWithRelationInput | CommandProjectOrderByWithRelationInput[]
    cursor?: CommandProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandProjectScalarFieldEnum | CommandProjectScalarFieldEnum[]
  }

  /**
   * Project.workFlow
   */
  export type Project$workFlowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    where?: WorkFlowWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Command
   */

  export type AggregateCommand = {
    _count: CommandCountAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  export type CommandMinAggregateOutputType = {
    id: string | null
    reference: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandCountAggregateOutputType = {
    id: number
    reference: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommandMinAggregateInputType = {
    id?: true
    reference?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandMaxAggregateInputType = {
    id?: true
    reference?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandCountAggregateInputType = {
    id?: true
    reference?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Command to aggregate.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commands
    **/
    _count?: true | CommandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandMaxAggregateInputType
  }

  export type GetCommandAggregateType<T extends CommandAggregateArgs> = {
        [P in keyof T & keyof AggregateCommand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommand[P]>
      : GetScalarType<T[P], AggregateCommand[P]>
  }




  export type CommandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithAggregationInput | CommandOrderByWithAggregationInput[]
    by: CommandScalarFieldEnum[] | CommandScalarFieldEnum
    having?: CommandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandCountAggregateInputType | true
    _min?: CommandMinAggregateInputType
    _max?: CommandMaxAggregateInputType
  }

  export type CommandGroupByOutputType = {
    id: string
    reference: string
    clientId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommandCountAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  type GetCommandGroupByPayload<T extends CommandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandGroupByOutputType[P]>
            : GetScalarType<T[P], CommandGroupByOutputType[P]>
        }
      >
    >


  export type CommandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandProjects?: boolean | Command$commandProjectsArgs<ExtArgs>
    client?: boolean | Command$clientArgs<ExtArgs>
    _count?: boolean | CommandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["command"]>

  export type CommandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Command$clientArgs<ExtArgs>
  }, ExtArgs["result"]["command"]>

  export type CommandSelectScalar = {
    id?: boolean
    reference?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandProjects?: boolean | Command$commandProjectsArgs<ExtArgs>
    client?: boolean | Command$clientArgs<ExtArgs>
    _count?: boolean | CommandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Command$clientArgs<ExtArgs>
  }

  export type $CommandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Command"
    objects: {
      commandProjects: Prisma.$CommandProjectPayload<ExtArgs>[]
      client: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reference: string
      clientId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["command"]>
    composites: {}
  }

  type CommandGetPayload<S extends boolean | null | undefined | CommandDefaultArgs> = $Result.GetResult<Prisma.$CommandPayload, S>

  type CommandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommandCountAggregateInputType | true
    }

  export interface CommandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Command'], meta: { name: 'Command' } }
    /**
     * Find zero or one Command that matches the filter.
     * @param {CommandFindUniqueArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommandFindUniqueArgs<ExtArgs>>
    ): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Command that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommandFindUniqueOrThrowArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Command that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandFindFirstArgs<ExtArgs>>
    ): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Command that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstOrThrowArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commands
     * const commands = await prisma.command.findMany()
     * 
     * // Get first 10 Commands
     * const commands = await prisma.command.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandWithIdOnly = await prisma.command.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Command.
     * @param {CommandCreateArgs} args - Arguments to create a Command.
     * @example
     * // Create one Command
     * const Command = await prisma.command.create({
     *   data: {
     *     // ... data to create a Command
     *   }
     * })
     * 
    **/
    create<T extends CommandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommandCreateArgs<ExtArgs>>
    ): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Commands.
     * @param {CommandCreateManyArgs} args - Arguments to create many Commands.
     * @example
     * // Create many Commands
     * const command = await prisma.command.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CommandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commands and returns the data saved in the database.
     * @param {CommandCreateManyAndReturnArgs} args - Arguments to create many Commands.
     * @example
     * // Create many Commands
     * const command = await prisma.command.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commands and only return the `id`
     * const commandWithIdOnly = await prisma.command.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CommandCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Command.
     * @param {CommandDeleteArgs} args - Arguments to delete one Command.
     * @example
     * // Delete one Command
     * const Command = await prisma.command.delete({
     *   where: {
     *     // ... filter to delete one Command
     *   }
     * })
     * 
    **/
    delete<T extends CommandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommandDeleteArgs<ExtArgs>>
    ): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Command.
     * @param {CommandUpdateArgs} args - Arguments to update one Command.
     * @example
     * // Update one Command
     * const command = await prisma.command.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommandUpdateArgs<ExtArgs>>
    ): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Commands.
     * @param {CommandDeleteManyArgs} args - Arguments to filter Commands to delete.
     * @example
     * // Delete a few Commands
     * const { count } = await prisma.command.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commands
     * const command = await prisma.command.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Command.
     * @param {CommandUpsertArgs} args - Arguments to update or create a Command.
     * @example
     * // Update or create a Command
     * const command = await prisma.command.upsert({
     *   create: {
     *     // ... data to create a Command
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Command we want to update
     *   }
     * })
    **/
    upsert<T extends CommandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommandUpsertArgs<ExtArgs>>
    ): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandCountArgs} args - Arguments to filter Commands to count.
     * @example
     * // Count the number of Commands
     * const count = await prisma.command.count({
     *   where: {
     *     // ... the filter for the Commands we want to count
     *   }
     * })
    **/
    count<T extends CommandCountArgs>(
      args?: Subset<T, CommandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandAggregateArgs>(args: Subset<T, CommandAggregateArgs>): Prisma.PrismaPromise<GetCommandAggregateType<T>>

    /**
     * Group by Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandGroupByArgs['orderBy'] }
        : { orderBy?: CommandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Command model
   */
  readonly fields: CommandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Command.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    commandProjects<T extends Command$commandProjectsArgs<ExtArgs> = {}>(args?: Subset<T, Command$commandProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    client<T extends Command$clientArgs<ExtArgs> = {}>(args?: Subset<T, Command$clientArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Command model
   */ 
  interface CommandFieldRefs {
    readonly id: FieldRef<"Command", 'String'>
    readonly reference: FieldRef<"Command", 'String'>
    readonly clientId: FieldRef<"Command", 'String'>
    readonly createdAt: FieldRef<"Command", 'DateTime'>
    readonly updatedAt: FieldRef<"Command", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Command findUnique
   */
  export type CommandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command findUniqueOrThrow
   */
  export type CommandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command findFirst
   */
  export type CommandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     */
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command findFirstOrThrow
   */
  export type CommandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     */
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command findMany
   */
  export type CommandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Commands to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command create
   */
  export type CommandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The data needed to create a Command.
     */
    data: XOR<CommandCreateInput, CommandUncheckedCreateInput>
  }

  /**
   * Command createMany
   */
  export type CommandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commands.
     */
    data: CommandCreateManyInput | CommandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Command createManyAndReturn
   */
  export type CommandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Commands.
     */
    data: CommandCreateManyInput | CommandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Command update
   */
  export type CommandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The data needed to update a Command.
     */
    data: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
    /**
     * Choose, which Command to update.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command updateMany
   */
  export type CommandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commands.
     */
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyInput>
    /**
     * Filter which Commands to update
     */
    where?: CommandWhereInput
  }

  /**
   * Command upsert
   */
  export type CommandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The filter to search for the Command to update in case it exists.
     */
    where: CommandWhereUniqueInput
    /**
     * In case the Command found by the `where` argument doesn't exist, create a new Command with this data.
     */
    create: XOR<CommandCreateInput, CommandUncheckedCreateInput>
    /**
     * In case the Command was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
  }

  /**
   * Command delete
   */
  export type CommandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter which Command to delete.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command deleteMany
   */
  export type CommandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commands to delete
     */
    where?: CommandWhereInput
  }

  /**
   * Command.commandProjects
   */
  export type Command$commandProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    where?: CommandProjectWhereInput
    orderBy?: CommandProjectOrderByWithRelationInput | CommandProjectOrderByWithRelationInput[]
    cursor?: CommandProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandProjectScalarFieldEnum | CommandProjectScalarFieldEnum[]
  }

  /**
   * Command.client
   */
  export type Command$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Command without action
   */
  export type CommandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
  }


  /**
   * Model CommandProject
   */

  export type AggregateCommandProject = {
    _count: CommandProjectCountAggregateOutputType | null
    _avg: CommandProjectAvgAggregateOutputType | null
    _sum: CommandProjectSumAggregateOutputType | null
    _min: CommandProjectMinAggregateOutputType | null
    _max: CommandProjectMaxAggregateOutputType | null
  }

  export type CommandProjectAvgAggregateOutputType = {
    target: number | null
    done: number | null
  }

  export type CommandProjectSumAggregateOutputType = {
    target: number | null
    done: number | null
  }

  export type CommandProjectMinAggregateOutputType = {
    id: string | null
    commandId: string | null
    projectId: string | null
    target: number | null
    done: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandProjectMaxAggregateOutputType = {
    id: string | null
    commandId: string | null
    projectId: string | null
    target: number | null
    done: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandProjectCountAggregateOutputType = {
    id: number
    commandId: number
    projectId: number
    target: number
    done: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommandProjectAvgAggregateInputType = {
    target?: true
    done?: true
  }

  export type CommandProjectSumAggregateInputType = {
    target?: true
    done?: true
  }

  export type CommandProjectMinAggregateInputType = {
    id?: true
    commandId?: true
    projectId?: true
    target?: true
    done?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandProjectMaxAggregateInputType = {
    id?: true
    commandId?: true
    projectId?: true
    target?: true
    done?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandProjectCountAggregateInputType = {
    id?: true
    commandId?: true
    projectId?: true
    target?: true
    done?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommandProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommandProject to aggregate.
     */
    where?: CommandProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandProjects to fetch.
     */
    orderBy?: CommandProjectOrderByWithRelationInput | CommandProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommandProjects
    **/
    _count?: true | CommandProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandProjectMaxAggregateInputType
  }

  export type GetCommandProjectAggregateType<T extends CommandProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCommandProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommandProject[P]>
      : GetScalarType<T[P], AggregateCommandProject[P]>
  }




  export type CommandProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandProjectWhereInput
    orderBy?: CommandProjectOrderByWithAggregationInput | CommandProjectOrderByWithAggregationInput[]
    by: CommandProjectScalarFieldEnum[] | CommandProjectScalarFieldEnum
    having?: CommandProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandProjectCountAggregateInputType | true
    _avg?: CommandProjectAvgAggregateInputType
    _sum?: CommandProjectSumAggregateInputType
    _min?: CommandProjectMinAggregateInputType
    _max?: CommandProjectMaxAggregateInputType
  }

  export type CommandProjectGroupByOutputType = {
    id: string
    commandId: string
    projectId: string
    target: number
    done: number
    startDate: Date | null
    endDate: Date
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: CommandProjectCountAggregateOutputType | null
    _avg: CommandProjectAvgAggregateOutputType | null
    _sum: CommandProjectSumAggregateOutputType | null
    _min: CommandProjectMinAggregateOutputType | null
    _max: CommandProjectMaxAggregateOutputType | null
  }

  type GetCommandProjectGroupByPayload<T extends CommandProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandProjectGroupByOutputType[P]>
            : GetScalarType<T[P], CommandProjectGroupByOutputType[P]>
        }
      >
    >


  export type CommandProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commandId?: boolean
    projectId?: boolean
    target?: boolean
    done?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    command?: boolean | CommandDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    planings?: boolean | CommandProject$planingsArgs<ExtArgs>
    sprint?: boolean | CommandProject$sprintArgs<ExtArgs>
    _count?: boolean | CommandProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandProject"]>

  export type CommandProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commandId?: boolean
    projectId?: boolean
    target?: boolean
    done?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    command?: boolean | CommandDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandProject"]>

  export type CommandProjectSelectScalar = {
    id?: boolean
    commandId?: boolean
    projectId?: boolean
    target?: boolean
    done?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommandProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    command?: boolean | CommandDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    planings?: boolean | CommandProject$planingsArgs<ExtArgs>
    sprint?: boolean | CommandProject$sprintArgs<ExtArgs>
    _count?: boolean | CommandProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommandProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    command?: boolean | CommandDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CommandProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommandProject"
    objects: {
      command: Prisma.$CommandPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      planings: Prisma.$PlanningPayload<ExtArgs>[]
      sprint: Prisma.$SprintPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commandId: string
      projectId: string
      target: number
      done: number
      startDate: Date | null
      endDate: Date
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commandProject"]>
    composites: {}
  }

  type CommandProjectGetPayload<S extends boolean | null | undefined | CommandProjectDefaultArgs> = $Result.GetResult<Prisma.$CommandProjectPayload, S>

  type CommandProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommandProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommandProjectCountAggregateInputType | true
    }

  export interface CommandProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommandProject'], meta: { name: 'CommandProject' } }
    /**
     * Find zero or one CommandProject that matches the filter.
     * @param {CommandProjectFindUniqueArgs} args - Arguments to find a CommandProject
     * @example
     * // Get one CommandProject
     * const commandProject = await prisma.commandProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommandProjectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommandProjectFindUniqueArgs<ExtArgs>>
    ): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CommandProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommandProjectFindUniqueOrThrowArgs} args - Arguments to find a CommandProject
     * @example
     * // Get one CommandProject
     * const commandProject = await prisma.commandProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommandProjectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandProjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CommandProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProjectFindFirstArgs} args - Arguments to find a CommandProject
     * @example
     * // Get one CommandProject
     * const commandProject = await prisma.commandProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommandProjectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandProjectFindFirstArgs<ExtArgs>>
    ): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CommandProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProjectFindFirstOrThrowArgs} args - Arguments to find a CommandProject
     * @example
     * // Get one CommandProject
     * const commandProject = await prisma.commandProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommandProjectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandProjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CommandProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommandProjects
     * const commandProjects = await prisma.commandProject.findMany()
     * 
     * // Get first 10 CommandProjects
     * const commandProjects = await prisma.commandProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandProjectWithIdOnly = await prisma.commandProject.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommandProjectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandProjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CommandProject.
     * @param {CommandProjectCreateArgs} args - Arguments to create a CommandProject.
     * @example
     * // Create one CommandProject
     * const CommandProject = await prisma.commandProject.create({
     *   data: {
     *     // ... data to create a CommandProject
     *   }
     * })
     * 
    **/
    create<T extends CommandProjectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommandProjectCreateArgs<ExtArgs>>
    ): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CommandProjects.
     * @param {CommandProjectCreateManyArgs} args - Arguments to create many CommandProjects.
     * @example
     * // Create many CommandProjects
     * const commandProject = await prisma.commandProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CommandProjectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandProjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommandProjects and returns the data saved in the database.
     * @param {CommandProjectCreateManyAndReturnArgs} args - Arguments to create many CommandProjects.
     * @example
     * // Create many CommandProjects
     * const commandProject = await prisma.commandProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommandProjects and only return the `id`
     * const commandProjectWithIdOnly = await prisma.commandProject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CommandProjectCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandProjectCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CommandProject.
     * @param {CommandProjectDeleteArgs} args - Arguments to delete one CommandProject.
     * @example
     * // Delete one CommandProject
     * const CommandProject = await prisma.commandProject.delete({
     *   where: {
     *     // ... filter to delete one CommandProject
     *   }
     * })
     * 
    **/
    delete<T extends CommandProjectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommandProjectDeleteArgs<ExtArgs>>
    ): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CommandProject.
     * @param {CommandProjectUpdateArgs} args - Arguments to update one CommandProject.
     * @example
     * // Update one CommandProject
     * const commandProject = await prisma.commandProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommandProjectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommandProjectUpdateArgs<ExtArgs>>
    ): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CommandProjects.
     * @param {CommandProjectDeleteManyArgs} args - Arguments to filter CommandProjects to delete.
     * @example
     * // Delete a few CommandProjects
     * const { count } = await prisma.commandProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommandProjectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommandProjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommandProjects
     * const commandProject = await prisma.commandProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommandProjectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommandProjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommandProject.
     * @param {CommandProjectUpsertArgs} args - Arguments to update or create a CommandProject.
     * @example
     * // Update or create a CommandProject
     * const commandProject = await prisma.commandProject.upsert({
     *   create: {
     *     // ... data to create a CommandProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommandProject we want to update
     *   }
     * })
    **/
    upsert<T extends CommandProjectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommandProjectUpsertArgs<ExtArgs>>
    ): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CommandProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProjectCountArgs} args - Arguments to filter CommandProjects to count.
     * @example
     * // Count the number of CommandProjects
     * const count = await prisma.commandProject.count({
     *   where: {
     *     // ... the filter for the CommandProjects we want to count
     *   }
     * })
    **/
    count<T extends CommandProjectCountArgs>(
      args?: Subset<T, CommandProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommandProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandProjectAggregateArgs>(args: Subset<T, CommandProjectAggregateArgs>): Prisma.PrismaPromise<GetCommandProjectAggregateType<T>>

    /**
     * Group by CommandProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandProjectGroupByArgs['orderBy'] }
        : { orderBy?: CommandProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommandProject model
   */
  readonly fields: CommandProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommandProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    command<T extends CommandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommandDefaultArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    planings<T extends CommandProject$planingsArgs<ExtArgs> = {}>(args?: Subset<T, CommandProject$planingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findMany'> | Null>;

    sprint<T extends CommandProject$sprintArgs<ExtArgs> = {}>(args?: Subset<T, CommandProject$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CommandProject model
   */ 
  interface CommandProjectFieldRefs {
    readonly id: FieldRef<"CommandProject", 'String'>
    readonly commandId: FieldRef<"CommandProject", 'String'>
    readonly projectId: FieldRef<"CommandProject", 'String'>
    readonly target: FieldRef<"CommandProject", 'Int'>
    readonly done: FieldRef<"CommandProject", 'Int'>
    readonly startDate: FieldRef<"CommandProject", 'DateTime'>
    readonly endDate: FieldRef<"CommandProject", 'DateTime'>
    readonly status: FieldRef<"CommandProject", 'Status'>
    readonly createdAt: FieldRef<"CommandProject", 'DateTime'>
    readonly updatedAt: FieldRef<"CommandProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommandProject findUnique
   */
  export type CommandProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * Filter, which CommandProject to fetch.
     */
    where: CommandProjectWhereUniqueInput
  }

  /**
   * CommandProject findUniqueOrThrow
   */
  export type CommandProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * Filter, which CommandProject to fetch.
     */
    where: CommandProjectWhereUniqueInput
  }

  /**
   * CommandProject findFirst
   */
  export type CommandProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * Filter, which CommandProject to fetch.
     */
    where?: CommandProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandProjects to fetch.
     */
    orderBy?: CommandProjectOrderByWithRelationInput | CommandProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandProjects.
     */
    cursor?: CommandProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandProjects.
     */
    distinct?: CommandProjectScalarFieldEnum | CommandProjectScalarFieldEnum[]
  }

  /**
   * CommandProject findFirstOrThrow
   */
  export type CommandProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * Filter, which CommandProject to fetch.
     */
    where?: CommandProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandProjects to fetch.
     */
    orderBy?: CommandProjectOrderByWithRelationInput | CommandProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandProjects.
     */
    cursor?: CommandProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandProjects.
     */
    distinct?: CommandProjectScalarFieldEnum | CommandProjectScalarFieldEnum[]
  }

  /**
   * CommandProject findMany
   */
  export type CommandProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * Filter, which CommandProjects to fetch.
     */
    where?: CommandProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandProjects to fetch.
     */
    orderBy?: CommandProjectOrderByWithRelationInput | CommandProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommandProjects.
     */
    cursor?: CommandProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandProjects.
     */
    skip?: number
    distinct?: CommandProjectScalarFieldEnum | CommandProjectScalarFieldEnum[]
  }

  /**
   * CommandProject create
   */
  export type CommandProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a CommandProject.
     */
    data: XOR<CommandProjectCreateInput, CommandProjectUncheckedCreateInput>
  }

  /**
   * CommandProject createMany
   */
  export type CommandProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommandProjects.
     */
    data: CommandProjectCreateManyInput | CommandProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommandProject createManyAndReturn
   */
  export type CommandProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommandProjects.
     */
    data: CommandProjectCreateManyInput | CommandProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommandProject update
   */
  export type CommandProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a CommandProject.
     */
    data: XOR<CommandProjectUpdateInput, CommandProjectUncheckedUpdateInput>
    /**
     * Choose, which CommandProject to update.
     */
    where: CommandProjectWhereUniqueInput
  }

  /**
   * CommandProject updateMany
   */
  export type CommandProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommandProjects.
     */
    data: XOR<CommandProjectUpdateManyMutationInput, CommandProjectUncheckedUpdateManyInput>
    /**
     * Filter which CommandProjects to update
     */
    where?: CommandProjectWhereInput
  }

  /**
   * CommandProject upsert
   */
  export type CommandProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the CommandProject to update in case it exists.
     */
    where: CommandProjectWhereUniqueInput
    /**
     * In case the CommandProject found by the `where` argument doesn't exist, create a new CommandProject with this data.
     */
    create: XOR<CommandProjectCreateInput, CommandProjectUncheckedCreateInput>
    /**
     * In case the CommandProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandProjectUpdateInput, CommandProjectUncheckedUpdateInput>
  }

  /**
   * CommandProject delete
   */
  export type CommandProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
    /**
     * Filter which CommandProject to delete.
     */
    where: CommandProjectWhereUniqueInput
  }

  /**
   * CommandProject deleteMany
   */
  export type CommandProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommandProjects to delete
     */
    where?: CommandProjectWhereInput
  }

  /**
   * CommandProject.planings
   */
  export type CommandProject$planingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    cursor?: PlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * CommandProject.sprint
   */
  export type CommandProject$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * CommandProject without action
   */
  export type CommandProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandProject
     */
    select?: CommandProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandProjectInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    operationId: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    operationId: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    operationId: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    operationId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    operationId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    operationId?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    operationId: string | null
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationId?: boolean
    device?: boolean | Post$deviceArgs<ExtArgs>
    plannings?: boolean | Post$planningsArgs<ExtArgs>
    Operation?: boolean | Post$OperationArgs<ExtArgs>
    expertises?: boolean | Post$expertisesArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationId?: boolean
    Operation?: boolean | Post$OperationArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationId?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | Post$deviceArgs<ExtArgs>
    plannings?: boolean | Post$planningsArgs<ExtArgs>
    Operation?: boolean | Post$OperationArgs<ExtArgs>
    expertises?: boolean | Post$expertisesArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Operation?: boolean | Post$OperationArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs> | null
      plannings: Prisma.$PlanningPayload<ExtArgs>[]
      Operation: Prisma.$OperationPayload<ExtArgs> | null
      expertises: Prisma.$ExpertisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      operationId: string | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PostCreateArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PostCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PostDeleteArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpsertArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    device<T extends Post$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Post$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    plannings<T extends Post$planningsArgs<ExtArgs> = {}>(args?: Subset<T, Post$planningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findMany'> | Null>;

    Operation<T extends Post$OperationArgs<ExtArgs> = {}>(args?: Subset<T, Post$OperationArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    expertises<T extends Post$expertisesArgs<ExtArgs> = {}>(args?: Subset<T, Post$expertisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly name: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly operationId: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post.device
   */
  export type Post$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * Post.plannings
   */
  export type Post$planningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    cursor?: PlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Post.Operation
   */
  export type Post$OperationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    where?: OperationWhereInput
  }

  /**
   * Post.expertises
   */
  export type Post$expertisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    where?: ExpertiseWhereInput
    orderBy?: ExpertiseOrderByWithRelationInput | ExpertiseOrderByWithRelationInput[]
    cursor?: ExpertiseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpertiseScalarFieldEnum | ExpertiseScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Planning
   */

  export type AggregatePlanning = {
    _count: PlanningCountAggregateOutputType | null
    _min: PlanningMinAggregateOutputType | null
    _max: PlanningMaxAggregateOutputType | null
  }

  export type PlanningMinAggregateOutputType = {
    id: string | null
    operatorId: string | null
    postId: string | null
    operationId: string | null
    commandProjectId: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanningMaxAggregateOutputType = {
    id: string | null
    operatorId: string | null
    postId: string | null
    operationId: string | null
    commandProjectId: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanningCountAggregateOutputType = {
    id: number
    operatorId: number
    postId: number
    operationId: number
    commandProjectId: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanningMinAggregateInputType = {
    id?: true
    operatorId?: true
    postId?: true
    operationId?: true
    commandProjectId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanningMaxAggregateInputType = {
    id?: true
    operatorId?: true
    postId?: true
    operationId?: true
    commandProjectId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanningCountAggregateInputType = {
    id?: true
    operatorId?: true
    postId?: true
    operationId?: true
    commandProjectId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planning to aggregate.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plannings
    **/
    _count?: true | PlanningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanningMaxAggregateInputType
  }

  export type GetPlanningAggregateType<T extends PlanningAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanning[P]>
      : GetScalarType<T[P], AggregatePlanning[P]>
  }




  export type PlanningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithAggregationInput | PlanningOrderByWithAggregationInput[]
    by: PlanningScalarFieldEnum[] | PlanningScalarFieldEnum
    having?: PlanningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanningCountAggregateInputType | true
    _min?: PlanningMinAggregateInputType
    _max?: PlanningMaxAggregateInputType
  }

  export type PlanningGroupByOutputType = {
    id: string
    operatorId: string
    postId: string
    operationId: string
    commandProjectId: string
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: PlanningCountAggregateOutputType | null
    _min: PlanningMinAggregateOutputType | null
    _max: PlanningMaxAggregateOutputType | null
  }

  type GetPlanningGroupByPayload<T extends PlanningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanningGroupByOutputType[P]>
            : GetScalarType<T[P], PlanningGroupByOutputType[P]>
        }
      >
    >


  export type PlanningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operatorId?: boolean
    postId?: boolean
    operationId?: boolean
    commandProjectId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    device?: boolean | Planning$deviceArgs<ExtArgs>
    operationHistory?: boolean | Planning$operationHistoryArgs<ExtArgs>
    commandProject?: boolean | CommandProjectDefaultArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PlanningCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planning"]>

  export type PlanningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operatorId?: boolean
    postId?: boolean
    operationId?: boolean
    commandProjectId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandProject?: boolean | CommandProjectDefaultArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planning"]>

  export type PlanningSelectScalar = {
    id?: boolean
    operatorId?: boolean
    postId?: boolean
    operationId?: boolean
    commandProjectId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | Planning$deviceArgs<ExtArgs>
    operationHistory?: boolean | Planning$operationHistoryArgs<ExtArgs>
    commandProject?: boolean | CommandProjectDefaultArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PlanningCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandProject?: boolean | CommandProjectDefaultArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlanningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Planning"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs> | null
      operationHistory: Prisma.$OperationHistoryPayload<ExtArgs>[]
      commandProject: Prisma.$CommandProjectPayload<ExtArgs>
      operation: Prisma.$OperationPayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
      operator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      operatorId: string
      postId: string
      operationId: string
      commandProjectId: string
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planning"]>
    composites: {}
  }

  type PlanningGetPayload<S extends boolean | null | undefined | PlanningDefaultArgs> = $Result.GetResult<Prisma.$PlanningPayload, S>

  type PlanningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanningFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanningCountAggregateInputType | true
    }

  export interface PlanningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Planning'], meta: { name: 'Planning' } }
    /**
     * Find zero or one Planning that matches the filter.
     * @param {PlanningFindUniqueArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlanningFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlanningFindUniqueArgs<ExtArgs>>
    ): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Planning that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanningFindUniqueOrThrowArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlanningFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanningFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Planning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindFirstArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlanningFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanningFindFirstArgs<ExtArgs>>
    ): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Planning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindFirstOrThrowArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlanningFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanningFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Plannings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plannings
     * const plannings = await prisma.planning.findMany()
     * 
     * // Get first 10 Plannings
     * const plannings = await prisma.planning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planningWithIdOnly = await prisma.planning.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlanningFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanningFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Planning.
     * @param {PlanningCreateArgs} args - Arguments to create a Planning.
     * @example
     * // Create one Planning
     * const Planning = await prisma.planning.create({
     *   data: {
     *     // ... data to create a Planning
     *   }
     * })
     * 
    **/
    create<T extends PlanningCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlanningCreateArgs<ExtArgs>>
    ): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Plannings.
     * @param {PlanningCreateManyArgs} args - Arguments to create many Plannings.
     * @example
     * // Create many Plannings
     * const planning = await prisma.planning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PlanningCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanningCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plannings and returns the data saved in the database.
     * @param {PlanningCreateManyAndReturnArgs} args - Arguments to create many Plannings.
     * @example
     * // Create many Plannings
     * const planning = await prisma.planning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plannings and only return the `id`
     * const planningWithIdOnly = await prisma.planning.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PlanningCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanningCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Planning.
     * @param {PlanningDeleteArgs} args - Arguments to delete one Planning.
     * @example
     * // Delete one Planning
     * const Planning = await prisma.planning.delete({
     *   where: {
     *     // ... filter to delete one Planning
     *   }
     * })
     * 
    **/
    delete<T extends PlanningDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlanningDeleteArgs<ExtArgs>>
    ): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Planning.
     * @param {PlanningUpdateArgs} args - Arguments to update one Planning.
     * @example
     * // Update one Planning
     * const planning = await prisma.planning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlanningUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlanningUpdateArgs<ExtArgs>>
    ): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Plannings.
     * @param {PlanningDeleteManyArgs} args - Arguments to filter Plannings to delete.
     * @example
     * // Delete a few Plannings
     * const { count } = await prisma.planning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlanningDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanningDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plannings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plannings
     * const planning = await prisma.planning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlanningUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlanningUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Planning.
     * @param {PlanningUpsertArgs} args - Arguments to update or create a Planning.
     * @example
     * // Update or create a Planning
     * const planning = await prisma.planning.upsert({
     *   create: {
     *     // ... data to create a Planning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planning we want to update
     *   }
     * })
    **/
    upsert<T extends PlanningUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlanningUpsertArgs<ExtArgs>>
    ): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Plannings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningCountArgs} args - Arguments to filter Plannings to count.
     * @example
     * // Count the number of Plannings
     * const count = await prisma.planning.count({
     *   where: {
     *     // ... the filter for the Plannings we want to count
     *   }
     * })
    **/
    count<T extends PlanningCountArgs>(
      args?: Subset<T, PlanningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanningAggregateArgs>(args: Subset<T, PlanningAggregateArgs>): Prisma.PrismaPromise<GetPlanningAggregateType<T>>

    /**
     * Group by Planning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanningGroupByArgs['orderBy'] }
        : { orderBy?: PlanningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Planning model
   */
  readonly fields: PlanningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Planning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    device<T extends Planning$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Planning$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    operationHistory<T extends Planning$operationHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Planning$operationHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    commandProject<T extends CommandProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommandProjectDefaultArgs<ExtArgs>>): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    operation<T extends OperationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperationDefaultArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    operator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Planning model
   */ 
  interface PlanningFieldRefs {
    readonly id: FieldRef<"Planning", 'String'>
    readonly operatorId: FieldRef<"Planning", 'String'>
    readonly postId: FieldRef<"Planning", 'String'>
    readonly operationId: FieldRef<"Planning", 'String'>
    readonly commandProjectId: FieldRef<"Planning", 'String'>
    readonly startDate: FieldRef<"Planning", 'DateTime'>
    readonly endDate: FieldRef<"Planning", 'DateTime'>
    readonly createdAt: FieldRef<"Planning", 'DateTime'>
    readonly updatedAt: FieldRef<"Planning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Planning findUnique
   */
  export type PlanningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning findUniqueOrThrow
   */
  export type PlanningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning findFirst
   */
  export type PlanningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plannings.
     */
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning findFirstOrThrow
   */
  export type PlanningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plannings.
     */
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning findMany
   */
  export type PlanningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Plannings to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning create
   */
  export type PlanningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The data needed to create a Planning.
     */
    data: XOR<PlanningCreateInput, PlanningUncheckedCreateInput>
  }

  /**
   * Planning createMany
   */
  export type PlanningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plannings.
     */
    data: PlanningCreateManyInput | PlanningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Planning createManyAndReturn
   */
  export type PlanningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Plannings.
     */
    data: PlanningCreateManyInput | PlanningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Planning update
   */
  export type PlanningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The data needed to update a Planning.
     */
    data: XOR<PlanningUpdateInput, PlanningUncheckedUpdateInput>
    /**
     * Choose, which Planning to update.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning updateMany
   */
  export type PlanningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plannings.
     */
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyInput>
    /**
     * Filter which Plannings to update
     */
    where?: PlanningWhereInput
  }

  /**
   * Planning upsert
   */
  export type PlanningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The filter to search for the Planning to update in case it exists.
     */
    where: PlanningWhereUniqueInput
    /**
     * In case the Planning found by the `where` argument doesn't exist, create a new Planning with this data.
     */
    create: XOR<PlanningCreateInput, PlanningUncheckedCreateInput>
    /**
     * In case the Planning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanningUpdateInput, PlanningUncheckedUpdateInput>
  }

  /**
   * Planning delete
   */
  export type PlanningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter which Planning to delete.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning deleteMany
   */
  export type PlanningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plannings to delete
     */
    where?: PlanningWhereInput
  }

  /**
   * Planning.device
   */
  export type Planning$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * Planning.operationHistory
   */
  export type Planning$operationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    where?: OperationHistoryWhereInput
    orderBy?: OperationHistoryOrderByWithRelationInput | OperationHistoryOrderByWithRelationInput[]
    cursor?: OperationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationHistoryScalarFieldEnum | OperationHistoryScalarFieldEnum[]
  }

  /**
   * Planning without action
   */
  export type PlanningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
  }


  /**
   * Model Sprint
   */

  export type AggregateSprint = {
    _count: SprintCountAggregateOutputType | null
    _avg: SprintAvgAggregateOutputType | null
    _sum: SprintSumAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  export type SprintAvgAggregateOutputType = {
    target: number | null
    days: number | null
  }

  export type SprintSumAggregateOutputType = {
    target: number | null
    days: number | null
  }

  export type SprintMinAggregateOutputType = {
    id: string | null
    target: number | null
    days: number | null
    status: $Enums.Status | null
    commandProjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SprintMaxAggregateOutputType = {
    id: string | null
    target: number | null
    days: number | null
    status: $Enums.Status | null
    commandProjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SprintCountAggregateOutputType = {
    id: number
    target: number
    days: number
    status: number
    commandProjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SprintAvgAggregateInputType = {
    target?: true
    days?: true
  }

  export type SprintSumAggregateInputType = {
    target?: true
    days?: true
  }

  export type SprintMinAggregateInputType = {
    id?: true
    target?: true
    days?: true
    status?: true
    commandProjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SprintMaxAggregateInputType = {
    id?: true
    target?: true
    days?: true
    status?: true
    commandProjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SprintCountAggregateInputType = {
    id?: true
    target?: true
    days?: true
    status?: true
    commandProjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SprintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprint to aggregate.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sprints
    **/
    _count?: true | SprintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SprintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SprintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SprintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SprintMaxAggregateInputType
  }

  export type GetSprintAggregateType<T extends SprintAggregateArgs> = {
        [P in keyof T & keyof AggregateSprint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSprint[P]>
      : GetScalarType<T[P], AggregateSprint[P]>
  }




  export type SprintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithAggregationInput | SprintOrderByWithAggregationInput[]
    by: SprintScalarFieldEnum[] | SprintScalarFieldEnum
    having?: SprintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SprintCountAggregateInputType | true
    _avg?: SprintAvgAggregateInputType
    _sum?: SprintSumAggregateInputType
    _min?: SprintMinAggregateInputType
    _max?: SprintMaxAggregateInputType
  }

  export type SprintGroupByOutputType = {
    id: string
    target: number
    days: number
    status: $Enums.Status
    commandProjectId: string
    createdAt: Date
    updatedAt: Date
    _count: SprintCountAggregateOutputType | null
    _avg: SprintAvgAggregateOutputType | null
    _sum: SprintSumAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  type GetSprintGroupByPayload<T extends SprintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SprintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SprintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SprintGroupByOutputType[P]>
            : GetScalarType<T[P], SprintGroupByOutputType[P]>
        }
      >
    >


  export type SprintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    target?: boolean
    days?: boolean
    status?: boolean
    commandProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandProject?: boolean | CommandProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    target?: boolean
    days?: boolean
    status?: boolean
    commandProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandProject?: boolean | CommandProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectScalar = {
    id?: boolean
    target?: boolean
    days?: boolean
    status?: boolean
    commandProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SprintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandProject?: boolean | CommandProjectDefaultArgs<ExtArgs>
  }
  export type SprintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandProject?: boolean | CommandProjectDefaultArgs<ExtArgs>
  }

  export type $SprintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sprint"
    objects: {
      commandProject: Prisma.$CommandProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      target: number
      days: number
      status: $Enums.Status
      commandProjectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sprint"]>
    composites: {}
  }

  type SprintGetPayload<S extends boolean | null | undefined | SprintDefaultArgs> = $Result.GetResult<Prisma.$SprintPayload, S>

  type SprintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SprintFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SprintCountAggregateInputType | true
    }

  export interface SprintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sprint'], meta: { name: 'Sprint' } }
    /**
     * Find zero or one Sprint that matches the filter.
     * @param {SprintFindUniqueArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SprintFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SprintFindUniqueArgs<ExtArgs>>
    ): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sprint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SprintFindUniqueOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SprintFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SprintFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sprint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SprintFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SprintFindFirstArgs<ExtArgs>>
    ): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sprint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SprintFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SprintFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sprints
     * const sprints = await prisma.sprint.findMany()
     * 
     * // Get first 10 Sprints
     * const sprints = await prisma.sprint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sprintWithIdOnly = await prisma.sprint.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SprintFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SprintFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sprint.
     * @param {SprintCreateArgs} args - Arguments to create a Sprint.
     * @example
     * // Create one Sprint
     * const Sprint = await prisma.sprint.create({
     *   data: {
     *     // ... data to create a Sprint
     *   }
     * })
     * 
    **/
    create<T extends SprintCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SprintCreateArgs<ExtArgs>>
    ): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sprints.
     * @param {SprintCreateManyArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends SprintCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SprintCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sprints and returns the data saved in the database.
     * @param {SprintCreateManyAndReturnArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends SprintCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, SprintCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Sprint.
     * @param {SprintDeleteArgs} args - Arguments to delete one Sprint.
     * @example
     * // Delete one Sprint
     * const Sprint = await prisma.sprint.delete({
     *   where: {
     *     // ... filter to delete one Sprint
     *   }
     * })
     * 
    **/
    delete<T extends SprintDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SprintDeleteArgs<ExtArgs>>
    ): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sprint.
     * @param {SprintUpdateArgs} args - Arguments to update one Sprint.
     * @example
     * // Update one Sprint
     * const sprint = await prisma.sprint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SprintUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SprintUpdateArgs<ExtArgs>>
    ): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sprints.
     * @param {SprintDeleteManyArgs} args - Arguments to filter Sprints to delete.
     * @example
     * // Delete a few Sprints
     * const { count } = await prisma.sprint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SprintDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SprintDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SprintUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SprintUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sprint.
     * @param {SprintUpsertArgs} args - Arguments to update or create a Sprint.
     * @example
     * // Update or create a Sprint
     * const sprint = await prisma.sprint.upsert({
     *   create: {
     *     // ... data to create a Sprint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sprint we want to update
     *   }
     * })
    **/
    upsert<T extends SprintUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SprintUpsertArgs<ExtArgs>>
    ): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintCountArgs} args - Arguments to filter Sprints to count.
     * @example
     * // Count the number of Sprints
     * const count = await prisma.sprint.count({
     *   where: {
     *     // ... the filter for the Sprints we want to count
     *   }
     * })
    **/
    count<T extends SprintCountArgs>(
      args?: Subset<T, SprintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SprintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SprintAggregateArgs>(args: Subset<T, SprintAggregateArgs>): Prisma.PrismaPromise<GetSprintAggregateType<T>>

    /**
     * Group by Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SprintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SprintGroupByArgs['orderBy'] }
        : { orderBy?: SprintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SprintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSprintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sprint model
   */
  readonly fields: SprintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sprint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SprintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    commandProject<T extends CommandProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommandProjectDefaultArgs<ExtArgs>>): Prisma__CommandProjectClient<$Result.GetResult<Prisma.$CommandProjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Sprint model
   */ 
  interface SprintFieldRefs {
    readonly id: FieldRef<"Sprint", 'String'>
    readonly target: FieldRef<"Sprint", 'Int'>
    readonly days: FieldRef<"Sprint", 'Int'>
    readonly status: FieldRef<"Sprint", 'Status'>
    readonly commandProjectId: FieldRef<"Sprint", 'String'>
    readonly createdAt: FieldRef<"Sprint", 'DateTime'>
    readonly updatedAt: FieldRef<"Sprint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sprint findUnique
   */
  export type SprintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findUniqueOrThrow
   */
  export type SprintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findFirst
   */
  export type SprintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findFirstOrThrow
   */
  export type SprintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findMany
   */
  export type SprintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprints to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint create
   */
  export type SprintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to create a Sprint.
     */
    data: XOR<SprintCreateInput, SprintUncheckedCreateInput>
  }

  /**
   * Sprint createMany
   */
  export type SprintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sprint createManyAndReturn
   */
  export type SprintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint update
   */
  export type SprintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to update a Sprint.
     */
    data: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
    /**
     * Choose, which Sprint to update.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint updateMany
   */
  export type SprintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
  }

  /**
   * Sprint upsert
   */
  export type SprintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The filter to search for the Sprint to update in case it exists.
     */
    where: SprintWhereUniqueInput
    /**
     * In case the Sprint found by the `where` argument doesn't exist, create a new Sprint with this data.
     */
    create: XOR<SprintCreateInput, SprintUncheckedCreateInput>
    /**
     * In case the Sprint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
  }

  /**
   * Sprint delete
   */
  export type SprintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter which Sprint to delete.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint deleteMany
   */
  export type SprintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprints to delete
     */
    where?: SprintWhereInput
  }

  /**
   * Sprint without action
   */
  export type SprintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
  }


  /**
   * Model Operation
   */

  export type AggregateOperation = {
    _count: OperationCountAggregateOutputType | null
    _avg: OperationAvgAggregateOutputType | null
    _sum: OperationSumAggregateOutputType | null
    _min: OperationMinAggregateOutputType | null
    _max: OperationMaxAggregateOutputType | null
  }

  export type OperationAvgAggregateOutputType = {
    estimatedTime: number | null
  }

  export type OperationSumAggregateOutputType = {
    estimatedTime: number | null
  }

  export type OperationMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    icon: string | null
    description: string | null
    isFinal: boolean | null
    estimatedTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expertiseId: string | null
  }

  export type OperationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    icon: string | null
    description: string | null
    isFinal: boolean | null
    estimatedTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expertiseId: string | null
  }

  export type OperationCountAggregateOutputType = {
    id: number
    name: number
    code: number
    icon: number
    description: number
    isFinal: number
    estimatedTime: number
    createdAt: number
    updatedAt: number
    expertiseId: number
    _all: number
  }


  export type OperationAvgAggregateInputType = {
    estimatedTime?: true
  }

  export type OperationSumAggregateInputType = {
    estimatedTime?: true
  }

  export type OperationMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    icon?: true
    description?: true
    isFinal?: true
    estimatedTime?: true
    createdAt?: true
    updatedAt?: true
    expertiseId?: true
  }

  export type OperationMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    icon?: true
    description?: true
    isFinal?: true
    estimatedTime?: true
    createdAt?: true
    updatedAt?: true
    expertiseId?: true
  }

  export type OperationCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    icon?: true
    description?: true
    isFinal?: true
    estimatedTime?: true
    createdAt?: true
    updatedAt?: true
    expertiseId?: true
    _all?: true
  }

  export type OperationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operation to aggregate.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operations
    **/
    _count?: true | OperationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationMaxAggregateInputType
  }

  export type GetOperationAggregateType<T extends OperationAggregateArgs> = {
        [P in keyof T & keyof AggregateOperation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperation[P]>
      : GetScalarType<T[P], AggregateOperation[P]>
  }




  export type OperationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationWhereInput
    orderBy?: OperationOrderByWithAggregationInput | OperationOrderByWithAggregationInput[]
    by: OperationScalarFieldEnum[] | OperationScalarFieldEnum
    having?: OperationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationCountAggregateInputType | true
    _avg?: OperationAvgAggregateInputType
    _sum?: OperationSumAggregateInputType
    _min?: OperationMinAggregateInputType
    _max?: OperationMaxAggregateInputType
  }

  export type OperationGroupByOutputType = {
    id: string
    name: string
    code: string
    icon: string
    description: string | null
    isFinal: boolean
    estimatedTime: number
    createdAt: Date
    updatedAt: Date
    expertiseId: string | null
    _count: OperationCountAggregateOutputType | null
    _avg: OperationAvgAggregateOutputType | null
    _sum: OperationSumAggregateOutputType | null
    _min: OperationMinAggregateOutputType | null
    _max: OperationMaxAggregateOutputType | null
  }

  type GetOperationGroupByPayload<T extends OperationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationGroupByOutputType[P]>
            : GetScalarType<T[P], OperationGroupByOutputType[P]>
        }
      >
    >


  export type OperationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    icon?: boolean
    description?: boolean
    isFinal?: boolean
    estimatedTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expertiseId?: boolean
    Expertise?: boolean | Operation$ExpertiseArgs<ExtArgs>
    plannings?: boolean | Operation$planningsArgs<ExtArgs>
    posts?: boolean | Operation$postsArgs<ExtArgs>
    WorkflowNode?: boolean | Operation$WorkflowNodeArgs<ExtArgs>
    _count?: boolean | OperationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operation"]>

  export type OperationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    icon?: boolean
    description?: boolean
    isFinal?: boolean
    estimatedTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expertiseId?: boolean
    Expertise?: boolean | Operation$ExpertiseArgs<ExtArgs>
  }, ExtArgs["result"]["operation"]>

  export type OperationSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    icon?: boolean
    description?: boolean
    isFinal?: boolean
    estimatedTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expertiseId?: boolean
  }

  export type OperationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Expertise?: boolean | Operation$ExpertiseArgs<ExtArgs>
    plannings?: boolean | Operation$planningsArgs<ExtArgs>
    posts?: boolean | Operation$postsArgs<ExtArgs>
    WorkflowNode?: boolean | Operation$WorkflowNodeArgs<ExtArgs>
    _count?: boolean | OperationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OperationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Expertise?: boolean | Operation$ExpertiseArgs<ExtArgs>
  }

  export type $OperationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operation"
    objects: {
      Expertise: Prisma.$ExpertisePayload<ExtArgs> | null
      plannings: Prisma.$PlanningPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      WorkflowNode: Prisma.$WorkFlowNodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      icon: string
      description: string | null
      isFinal: boolean
      estimatedTime: number
      createdAt: Date
      updatedAt: Date
      expertiseId: string | null
    }, ExtArgs["result"]["operation"]>
    composites: {}
  }

  type OperationGetPayload<S extends boolean | null | undefined | OperationDefaultArgs> = $Result.GetResult<Prisma.$OperationPayload, S>

  type OperationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationCountAggregateInputType | true
    }

  export interface OperationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operation'], meta: { name: 'Operation' } }
    /**
     * Find zero or one Operation that matches the filter.
     * @param {OperationFindUniqueArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OperationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OperationFindUniqueArgs<ExtArgs>>
    ): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Operation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationFindUniqueOrThrowArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OperationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Operation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindFirstArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OperationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationFindFirstArgs<ExtArgs>>
    ): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Operation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindFirstOrThrowArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OperationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Operations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operations
     * const operations = await prisma.operation.findMany()
     * 
     * // Get first 10 Operations
     * const operations = await prisma.operation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationWithIdOnly = await prisma.operation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OperationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Operation.
     * @param {OperationCreateArgs} args - Arguments to create a Operation.
     * @example
     * // Create one Operation
     * const Operation = await prisma.operation.create({
     *   data: {
     *     // ... data to create a Operation
     *   }
     * })
     * 
    **/
    create<T extends OperationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OperationCreateArgs<ExtArgs>>
    ): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Operations.
     * @param {OperationCreateManyArgs} args - Arguments to create many Operations.
     * @example
     * // Create many Operations
     * const operation = await prisma.operation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends OperationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operations and returns the data saved in the database.
     * @param {OperationCreateManyAndReturnArgs} args - Arguments to create many Operations.
     * @example
     * // Create many Operations
     * const operation = await prisma.operation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operations and only return the `id`
     * const operationWithIdOnly = await prisma.operation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends OperationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Operation.
     * @param {OperationDeleteArgs} args - Arguments to delete one Operation.
     * @example
     * // Delete one Operation
     * const Operation = await prisma.operation.delete({
     *   where: {
     *     // ... filter to delete one Operation
     *   }
     * })
     * 
    **/
    delete<T extends OperationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OperationDeleteArgs<ExtArgs>>
    ): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Operation.
     * @param {OperationUpdateArgs} args - Arguments to update one Operation.
     * @example
     * // Update one Operation
     * const operation = await prisma.operation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OperationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OperationUpdateArgs<ExtArgs>>
    ): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Operations.
     * @param {OperationDeleteManyArgs} args - Arguments to filter Operations to delete.
     * @example
     * // Delete a few Operations
     * const { count } = await prisma.operation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OperationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operations
     * const operation = await prisma.operation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OperationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OperationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operation.
     * @param {OperationUpsertArgs} args - Arguments to update or create a Operation.
     * @example
     * // Update or create a Operation
     * const operation = await prisma.operation.upsert({
     *   create: {
     *     // ... data to create a Operation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operation we want to update
     *   }
     * })
    **/
    upsert<T extends OperationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OperationUpsertArgs<ExtArgs>>
    ): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationCountArgs} args - Arguments to filter Operations to count.
     * @example
     * // Count the number of Operations
     * const count = await prisma.operation.count({
     *   where: {
     *     // ... the filter for the Operations we want to count
     *   }
     * })
    **/
    count<T extends OperationCountArgs>(
      args?: Subset<T, OperationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationAggregateArgs>(args: Subset<T, OperationAggregateArgs>): Prisma.PrismaPromise<GetOperationAggregateType<T>>

    /**
     * Group by Operation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationGroupByArgs['orderBy'] }
        : { orderBy?: OperationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operation model
   */
  readonly fields: OperationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Expertise<T extends Operation$ExpertiseArgs<ExtArgs> = {}>(args?: Subset<T, Operation$ExpertiseArgs<ExtArgs>>): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    plannings<T extends Operation$planningsArgs<ExtArgs> = {}>(args?: Subset<T, Operation$planningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findMany'> | Null>;

    posts<T extends Operation$postsArgs<ExtArgs> = {}>(args?: Subset<T, Operation$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'> | Null>;

    WorkflowNode<T extends Operation$WorkflowNodeArgs<ExtArgs> = {}>(args?: Subset<T, Operation$WorkflowNodeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Operation model
   */ 
  interface OperationFieldRefs {
    readonly id: FieldRef<"Operation", 'String'>
    readonly name: FieldRef<"Operation", 'String'>
    readonly code: FieldRef<"Operation", 'String'>
    readonly icon: FieldRef<"Operation", 'String'>
    readonly description: FieldRef<"Operation", 'String'>
    readonly isFinal: FieldRef<"Operation", 'Boolean'>
    readonly estimatedTime: FieldRef<"Operation", 'Int'>
    readonly createdAt: FieldRef<"Operation", 'DateTime'>
    readonly updatedAt: FieldRef<"Operation", 'DateTime'>
    readonly expertiseId: FieldRef<"Operation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Operation findUnique
   */
  export type OperationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operation to fetch.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation findUniqueOrThrow
   */
  export type OperationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operation to fetch.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation findFirst
   */
  export type OperationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operation to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operations.
     */
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * Operation findFirstOrThrow
   */
  export type OperationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operation to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operations.
     */
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * Operation findMany
   */
  export type OperationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operations to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * Operation create
   */
  export type OperationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * The data needed to create a Operation.
     */
    data: XOR<OperationCreateInput, OperationUncheckedCreateInput>
  }

  /**
   * Operation createMany
   */
  export type OperationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operations.
     */
    data: OperationCreateManyInput | OperationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operation createManyAndReturn
   */
  export type OperationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Operations.
     */
    data: OperationCreateManyInput | OperationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operation update
   */
  export type OperationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * The data needed to update a Operation.
     */
    data: XOR<OperationUpdateInput, OperationUncheckedUpdateInput>
    /**
     * Choose, which Operation to update.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation updateMany
   */
  export type OperationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operations.
     */
    data: XOR<OperationUpdateManyMutationInput, OperationUncheckedUpdateManyInput>
    /**
     * Filter which Operations to update
     */
    where?: OperationWhereInput
  }

  /**
   * Operation upsert
   */
  export type OperationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * The filter to search for the Operation to update in case it exists.
     */
    where: OperationWhereUniqueInput
    /**
     * In case the Operation found by the `where` argument doesn't exist, create a new Operation with this data.
     */
    create: XOR<OperationCreateInput, OperationUncheckedCreateInput>
    /**
     * In case the Operation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationUpdateInput, OperationUncheckedUpdateInput>
  }

  /**
   * Operation delete
   */
  export type OperationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter which Operation to delete.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation deleteMany
   */
  export type OperationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operations to delete
     */
    where?: OperationWhereInput
  }

  /**
   * Operation.Expertise
   */
  export type Operation$ExpertiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    where?: ExpertiseWhereInput
  }

  /**
   * Operation.plannings
   */
  export type Operation$planningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    cursor?: PlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Operation.posts
   */
  export type Operation$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Operation.WorkflowNode
   */
  export type Operation$WorkflowNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    where?: WorkFlowNodeWhereInput
    orderBy?: WorkFlowNodeOrderByWithRelationInput | WorkFlowNodeOrderByWithRelationInput[]
    cursor?: WorkFlowNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkFlowNodeScalarFieldEnum | WorkFlowNodeScalarFieldEnum[]
  }

  /**
   * Operation without action
   */
  export type OperationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
  }


  /**
   * Model WorkFlowNode
   */

  export type AggregateWorkFlowNode = {
    _count: WorkFlowNodeCountAggregateOutputType | null
    _min: WorkFlowNodeMinAggregateOutputType | null
    _max: WorkFlowNodeMaxAggregateOutputType | null
  }

  export type WorkFlowNodeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workFlowId: string | null
    operationId: string | null
  }

  export type WorkFlowNodeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workFlowId: string | null
    operationId: string | null
  }

  export type WorkFlowNodeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    workFlowId: number
    operationId: number
    data: number
    _all: number
  }


  export type WorkFlowNodeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workFlowId?: true
    operationId?: true
  }

  export type WorkFlowNodeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workFlowId?: true
    operationId?: true
  }

  export type WorkFlowNodeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workFlowId?: true
    operationId?: true
    data?: true
    _all?: true
  }

  export type WorkFlowNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkFlowNode to aggregate.
     */
    where?: WorkFlowNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlowNodes to fetch.
     */
    orderBy?: WorkFlowNodeOrderByWithRelationInput | WorkFlowNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkFlowNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlowNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlowNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkFlowNodes
    **/
    _count?: true | WorkFlowNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkFlowNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkFlowNodeMaxAggregateInputType
  }

  export type GetWorkFlowNodeAggregateType<T extends WorkFlowNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkFlowNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkFlowNode[P]>
      : GetScalarType<T[P], AggregateWorkFlowNode[P]>
  }




  export type WorkFlowNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkFlowNodeWhereInput
    orderBy?: WorkFlowNodeOrderByWithAggregationInput | WorkFlowNodeOrderByWithAggregationInput[]
    by: WorkFlowNodeScalarFieldEnum[] | WorkFlowNodeScalarFieldEnum
    having?: WorkFlowNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkFlowNodeCountAggregateInputType | true
    _min?: WorkFlowNodeMinAggregateInputType
    _max?: WorkFlowNodeMaxAggregateInputType
  }

  export type WorkFlowNodeGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    workFlowId: string
    operationId: string
    data: JsonValue
    _count: WorkFlowNodeCountAggregateOutputType | null
    _min: WorkFlowNodeMinAggregateOutputType | null
    _max: WorkFlowNodeMaxAggregateOutputType | null
  }

  type GetWorkFlowNodeGroupByPayload<T extends WorkFlowNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkFlowNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkFlowNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkFlowNodeGroupByOutputType[P]>
            : GetScalarType<T[P], WorkFlowNodeGroupByOutputType[P]>
        }
      >
    >


  export type WorkFlowNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workFlowId?: boolean
    operationId?: boolean
    data?: boolean
    targetEdges?: boolean | WorkFlowNode$targetEdgesArgs<ExtArgs>
    sourceEdges?: boolean | WorkFlowNode$sourceEdgesArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    WorkFlow?: boolean | WorkFlowDefaultArgs<ExtArgs>
    _count?: boolean | WorkFlowNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workFlowNode"]>

  export type WorkFlowNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workFlowId?: boolean
    operationId?: boolean
    data?: boolean
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    WorkFlow?: boolean | WorkFlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workFlowNode"]>

  export type WorkFlowNodeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workFlowId?: boolean
    operationId?: boolean
    data?: boolean
  }

  export type WorkFlowNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetEdges?: boolean | WorkFlowNode$targetEdgesArgs<ExtArgs>
    sourceEdges?: boolean | WorkFlowNode$sourceEdgesArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    WorkFlow?: boolean | WorkFlowDefaultArgs<ExtArgs>
    _count?: boolean | WorkFlowNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkFlowNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    WorkFlow?: boolean | WorkFlowDefaultArgs<ExtArgs>
  }

  export type $WorkFlowNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkFlowNode"
    objects: {
      targetEdges: Prisma.$WorkFlowEdgePayload<ExtArgs>[]
      sourceEdges: Prisma.$WorkFlowEdgePayload<ExtArgs>[]
      operation: Prisma.$OperationPayload<ExtArgs>
      WorkFlow: Prisma.$WorkFlowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      workFlowId: string
      operationId: string
      data: Prisma.JsonValue
    }, ExtArgs["result"]["workFlowNode"]>
    composites: {}
  }

  type WorkFlowNodeGetPayload<S extends boolean | null | undefined | WorkFlowNodeDefaultArgs> = $Result.GetResult<Prisma.$WorkFlowNodePayload, S>

  type WorkFlowNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkFlowNodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkFlowNodeCountAggregateInputType | true
    }

  export interface WorkFlowNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkFlowNode'], meta: { name: 'WorkFlowNode' } }
    /**
     * Find zero or one WorkFlowNode that matches the filter.
     * @param {WorkFlowNodeFindUniqueArgs} args - Arguments to find a WorkFlowNode
     * @example
     * // Get one WorkFlowNode
     * const workFlowNode = await prisma.workFlowNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkFlowNodeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowNodeFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WorkFlowNode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkFlowNodeFindUniqueOrThrowArgs} args - Arguments to find a WorkFlowNode
     * @example
     * // Get one WorkFlowNode
     * const workFlowNode = await prisma.workFlowNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkFlowNodeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowNodeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WorkFlowNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowNodeFindFirstArgs} args - Arguments to find a WorkFlowNode
     * @example
     * // Get one WorkFlowNode
     * const workFlowNode = await prisma.workFlowNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkFlowNodeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowNodeFindFirstArgs<ExtArgs>>
    ): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WorkFlowNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowNodeFindFirstOrThrowArgs} args - Arguments to find a WorkFlowNode
     * @example
     * // Get one WorkFlowNode
     * const workFlowNode = await prisma.workFlowNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkFlowNodeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowNodeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WorkFlowNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkFlowNodes
     * const workFlowNodes = await prisma.workFlowNode.findMany()
     * 
     * // Get first 10 WorkFlowNodes
     * const workFlowNodes = await prisma.workFlowNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workFlowNodeWithIdOnly = await prisma.workFlowNode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkFlowNodeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowNodeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WorkFlowNode.
     * @param {WorkFlowNodeCreateArgs} args - Arguments to create a WorkFlowNode.
     * @example
     * // Create one WorkFlowNode
     * const WorkFlowNode = await prisma.workFlowNode.create({
     *   data: {
     *     // ... data to create a WorkFlowNode
     *   }
     * })
     * 
    **/
    create<T extends WorkFlowNodeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowNodeCreateArgs<ExtArgs>>
    ): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WorkFlowNodes.
     * @param {WorkFlowNodeCreateManyArgs} args - Arguments to create many WorkFlowNodes.
     * @example
     * // Create many WorkFlowNodes
     * const workFlowNode = await prisma.workFlowNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends WorkFlowNodeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowNodeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkFlowNodes and returns the data saved in the database.
     * @param {WorkFlowNodeCreateManyAndReturnArgs} args - Arguments to create many WorkFlowNodes.
     * @example
     * // Create many WorkFlowNodes
     * const workFlowNode = await prisma.workFlowNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkFlowNodes and only return the `id`
     * const workFlowNodeWithIdOnly = await prisma.workFlowNode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends WorkFlowNodeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowNodeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a WorkFlowNode.
     * @param {WorkFlowNodeDeleteArgs} args - Arguments to delete one WorkFlowNode.
     * @example
     * // Delete one WorkFlowNode
     * const WorkFlowNode = await prisma.workFlowNode.delete({
     *   where: {
     *     // ... filter to delete one WorkFlowNode
     *   }
     * })
     * 
    **/
    delete<T extends WorkFlowNodeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowNodeDeleteArgs<ExtArgs>>
    ): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WorkFlowNode.
     * @param {WorkFlowNodeUpdateArgs} args - Arguments to update one WorkFlowNode.
     * @example
     * // Update one WorkFlowNode
     * const workFlowNode = await prisma.workFlowNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkFlowNodeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowNodeUpdateArgs<ExtArgs>>
    ): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WorkFlowNodes.
     * @param {WorkFlowNodeDeleteManyArgs} args - Arguments to filter WorkFlowNodes to delete.
     * @example
     * // Delete a few WorkFlowNodes
     * const { count } = await prisma.workFlowNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkFlowNodeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowNodeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkFlowNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkFlowNodes
     * const workFlowNode = await prisma.workFlowNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkFlowNodeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowNodeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkFlowNode.
     * @param {WorkFlowNodeUpsertArgs} args - Arguments to update or create a WorkFlowNode.
     * @example
     * // Update or create a WorkFlowNode
     * const workFlowNode = await prisma.workFlowNode.upsert({
     *   create: {
     *     // ... data to create a WorkFlowNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkFlowNode we want to update
     *   }
     * })
    **/
    upsert<T extends WorkFlowNodeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowNodeUpsertArgs<ExtArgs>>
    ): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WorkFlowNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowNodeCountArgs} args - Arguments to filter WorkFlowNodes to count.
     * @example
     * // Count the number of WorkFlowNodes
     * const count = await prisma.workFlowNode.count({
     *   where: {
     *     // ... the filter for the WorkFlowNodes we want to count
     *   }
     * })
    **/
    count<T extends WorkFlowNodeCountArgs>(
      args?: Subset<T, WorkFlowNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkFlowNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkFlowNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkFlowNodeAggregateArgs>(args: Subset<T, WorkFlowNodeAggregateArgs>): Prisma.PrismaPromise<GetWorkFlowNodeAggregateType<T>>

    /**
     * Group by WorkFlowNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkFlowNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkFlowNodeGroupByArgs['orderBy'] }
        : { orderBy?: WorkFlowNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkFlowNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkFlowNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkFlowNode model
   */
  readonly fields: WorkFlowNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkFlowNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkFlowNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    targetEdges<T extends WorkFlowNode$targetEdgesArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlowNode$targetEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'findMany'> | Null>;

    sourceEdges<T extends WorkFlowNode$sourceEdgesArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlowNode$sourceEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'findMany'> | Null>;

    operation<T extends OperationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperationDefaultArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    WorkFlow<T extends WorkFlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlowDefaultArgs<ExtArgs>>): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WorkFlowNode model
   */ 
  interface WorkFlowNodeFieldRefs {
    readonly id: FieldRef<"WorkFlowNode", 'String'>
    readonly createdAt: FieldRef<"WorkFlowNode", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkFlowNode", 'DateTime'>
    readonly workFlowId: FieldRef<"WorkFlowNode", 'String'>
    readonly operationId: FieldRef<"WorkFlowNode", 'String'>
    readonly data: FieldRef<"WorkFlowNode", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * WorkFlowNode findUnique
   */
  export type WorkFlowNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowNode to fetch.
     */
    where: WorkFlowNodeWhereUniqueInput
  }

  /**
   * WorkFlowNode findUniqueOrThrow
   */
  export type WorkFlowNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowNode to fetch.
     */
    where: WorkFlowNodeWhereUniqueInput
  }

  /**
   * WorkFlowNode findFirst
   */
  export type WorkFlowNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowNode to fetch.
     */
    where?: WorkFlowNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlowNodes to fetch.
     */
    orderBy?: WorkFlowNodeOrderByWithRelationInput | WorkFlowNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkFlowNodes.
     */
    cursor?: WorkFlowNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlowNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlowNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkFlowNodes.
     */
    distinct?: WorkFlowNodeScalarFieldEnum | WorkFlowNodeScalarFieldEnum[]
  }

  /**
   * WorkFlowNode findFirstOrThrow
   */
  export type WorkFlowNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowNode to fetch.
     */
    where?: WorkFlowNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlowNodes to fetch.
     */
    orderBy?: WorkFlowNodeOrderByWithRelationInput | WorkFlowNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkFlowNodes.
     */
    cursor?: WorkFlowNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlowNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlowNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkFlowNodes.
     */
    distinct?: WorkFlowNodeScalarFieldEnum | WorkFlowNodeScalarFieldEnum[]
  }

  /**
   * WorkFlowNode findMany
   */
  export type WorkFlowNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowNodes to fetch.
     */
    where?: WorkFlowNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlowNodes to fetch.
     */
    orderBy?: WorkFlowNodeOrderByWithRelationInput | WorkFlowNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkFlowNodes.
     */
    cursor?: WorkFlowNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlowNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlowNodes.
     */
    skip?: number
    distinct?: WorkFlowNodeScalarFieldEnum | WorkFlowNodeScalarFieldEnum[]
  }

  /**
   * WorkFlowNode create
   */
  export type WorkFlowNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkFlowNode.
     */
    data: XOR<WorkFlowNodeCreateInput, WorkFlowNodeUncheckedCreateInput>
  }

  /**
   * WorkFlowNode createMany
   */
  export type WorkFlowNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkFlowNodes.
     */
    data: WorkFlowNodeCreateManyInput | WorkFlowNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkFlowNode createManyAndReturn
   */
  export type WorkFlowNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkFlowNodes.
     */
    data: WorkFlowNodeCreateManyInput | WorkFlowNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkFlowNode update
   */
  export type WorkFlowNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkFlowNode.
     */
    data: XOR<WorkFlowNodeUpdateInput, WorkFlowNodeUncheckedUpdateInput>
    /**
     * Choose, which WorkFlowNode to update.
     */
    where: WorkFlowNodeWhereUniqueInput
  }

  /**
   * WorkFlowNode updateMany
   */
  export type WorkFlowNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkFlowNodes.
     */
    data: XOR<WorkFlowNodeUpdateManyMutationInput, WorkFlowNodeUncheckedUpdateManyInput>
    /**
     * Filter which WorkFlowNodes to update
     */
    where?: WorkFlowNodeWhereInput
  }

  /**
   * WorkFlowNode upsert
   */
  export type WorkFlowNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkFlowNode to update in case it exists.
     */
    where: WorkFlowNodeWhereUniqueInput
    /**
     * In case the WorkFlowNode found by the `where` argument doesn't exist, create a new WorkFlowNode with this data.
     */
    create: XOR<WorkFlowNodeCreateInput, WorkFlowNodeUncheckedCreateInput>
    /**
     * In case the WorkFlowNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkFlowNodeUpdateInput, WorkFlowNodeUncheckedUpdateInput>
  }

  /**
   * WorkFlowNode delete
   */
  export type WorkFlowNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    /**
     * Filter which WorkFlowNode to delete.
     */
    where: WorkFlowNodeWhereUniqueInput
  }

  /**
   * WorkFlowNode deleteMany
   */
  export type WorkFlowNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkFlowNodes to delete
     */
    where?: WorkFlowNodeWhereInput
  }

  /**
   * WorkFlowNode.targetEdges
   */
  export type WorkFlowNode$targetEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    where?: WorkFlowEdgeWhereInput
    orderBy?: WorkFlowEdgeOrderByWithRelationInput | WorkFlowEdgeOrderByWithRelationInput[]
    cursor?: WorkFlowEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkFlowEdgeScalarFieldEnum | WorkFlowEdgeScalarFieldEnum[]
  }

  /**
   * WorkFlowNode.sourceEdges
   */
  export type WorkFlowNode$sourceEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    where?: WorkFlowEdgeWhereInput
    orderBy?: WorkFlowEdgeOrderByWithRelationInput | WorkFlowEdgeOrderByWithRelationInput[]
    cursor?: WorkFlowEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkFlowEdgeScalarFieldEnum | WorkFlowEdgeScalarFieldEnum[]
  }

  /**
   * WorkFlowNode without action
   */
  export type WorkFlowNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
  }


  /**
   * Model WorkFlowEdge
   */

  export type AggregateWorkFlowEdge = {
    _count: WorkFlowEdgeCountAggregateOutputType | null
    _avg: WorkFlowEdgeAvgAggregateOutputType | null
    _sum: WorkFlowEdgeSumAggregateOutputType | null
    _min: WorkFlowEdgeMinAggregateOutputType | null
    _max: WorkFlowEdgeMaxAggregateOutputType | null
  }

  export type WorkFlowEdgeAvgAggregateOutputType = {
    count: number | null
  }

  export type WorkFlowEdgeSumAggregateOutputType = {
    count: number | null
  }

  export type WorkFlowEdgeMinAggregateOutputType = {
    id: string | null
    sourceId: string | null
    targetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workFlowId: string | null
    count: number | null
  }

  export type WorkFlowEdgeMaxAggregateOutputType = {
    id: string | null
    sourceId: string | null
    targetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workFlowId: string | null
    count: number | null
  }

  export type WorkFlowEdgeCountAggregateOutputType = {
    id: number
    sourceId: number
    targetId: number
    createdAt: number
    updatedAt: number
    workFlowId: number
    data: number
    count: number
    _all: number
  }


  export type WorkFlowEdgeAvgAggregateInputType = {
    count?: true
  }

  export type WorkFlowEdgeSumAggregateInputType = {
    count?: true
  }

  export type WorkFlowEdgeMinAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    workFlowId?: true
    count?: true
  }

  export type WorkFlowEdgeMaxAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    workFlowId?: true
    count?: true
  }

  export type WorkFlowEdgeCountAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    createdAt?: true
    updatedAt?: true
    workFlowId?: true
    data?: true
    count?: true
    _all?: true
  }

  export type WorkFlowEdgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkFlowEdge to aggregate.
     */
    where?: WorkFlowEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlowEdges to fetch.
     */
    orderBy?: WorkFlowEdgeOrderByWithRelationInput | WorkFlowEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkFlowEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlowEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlowEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkFlowEdges
    **/
    _count?: true | WorkFlowEdgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkFlowEdgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkFlowEdgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkFlowEdgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkFlowEdgeMaxAggregateInputType
  }

  export type GetWorkFlowEdgeAggregateType<T extends WorkFlowEdgeAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkFlowEdge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkFlowEdge[P]>
      : GetScalarType<T[P], AggregateWorkFlowEdge[P]>
  }




  export type WorkFlowEdgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkFlowEdgeWhereInput
    orderBy?: WorkFlowEdgeOrderByWithAggregationInput | WorkFlowEdgeOrderByWithAggregationInput[]
    by: WorkFlowEdgeScalarFieldEnum[] | WorkFlowEdgeScalarFieldEnum
    having?: WorkFlowEdgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkFlowEdgeCountAggregateInputType | true
    _avg?: WorkFlowEdgeAvgAggregateInputType
    _sum?: WorkFlowEdgeSumAggregateInputType
    _min?: WorkFlowEdgeMinAggregateInputType
    _max?: WorkFlowEdgeMaxAggregateInputType
  }

  export type WorkFlowEdgeGroupByOutputType = {
    id: string
    sourceId: string
    targetId: string
    createdAt: Date
    updatedAt: Date
    workFlowId: string
    data: JsonValue
    count: number
    _count: WorkFlowEdgeCountAggregateOutputType | null
    _avg: WorkFlowEdgeAvgAggregateOutputType | null
    _sum: WorkFlowEdgeSumAggregateOutputType | null
    _min: WorkFlowEdgeMinAggregateOutputType | null
    _max: WorkFlowEdgeMaxAggregateOutputType | null
  }

  type GetWorkFlowEdgeGroupByPayload<T extends WorkFlowEdgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkFlowEdgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkFlowEdgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkFlowEdgeGroupByOutputType[P]>
            : GetScalarType<T[P], WorkFlowEdgeGroupByOutputType[P]>
        }
      >
    >


  export type WorkFlowEdgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workFlowId?: boolean
    data?: boolean
    count?: boolean
    source?: boolean | WorkFlowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkFlowNodeDefaultArgs<ExtArgs>
    WorkFlow?: boolean | WorkFlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workFlowEdge"]>

  export type WorkFlowEdgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workFlowId?: boolean
    data?: boolean
    count?: boolean
    source?: boolean | WorkFlowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkFlowNodeDefaultArgs<ExtArgs>
    WorkFlow?: boolean | WorkFlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workFlowEdge"]>

  export type WorkFlowEdgeSelectScalar = {
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workFlowId?: boolean
    data?: boolean
    count?: boolean
  }

  export type WorkFlowEdgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | WorkFlowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkFlowNodeDefaultArgs<ExtArgs>
    WorkFlow?: boolean | WorkFlowDefaultArgs<ExtArgs>
  }
  export type WorkFlowEdgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | WorkFlowNodeDefaultArgs<ExtArgs>
    target?: boolean | WorkFlowNodeDefaultArgs<ExtArgs>
    WorkFlow?: boolean | WorkFlowDefaultArgs<ExtArgs>
  }

  export type $WorkFlowEdgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkFlowEdge"
    objects: {
      source: Prisma.$WorkFlowNodePayload<ExtArgs>
      target: Prisma.$WorkFlowNodePayload<ExtArgs>
      WorkFlow: Prisma.$WorkFlowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceId: string
      targetId: string
      createdAt: Date
      updatedAt: Date
      workFlowId: string
      data: Prisma.JsonValue
      count: number
    }, ExtArgs["result"]["workFlowEdge"]>
    composites: {}
  }

  type WorkFlowEdgeGetPayload<S extends boolean | null | undefined | WorkFlowEdgeDefaultArgs> = $Result.GetResult<Prisma.$WorkFlowEdgePayload, S>

  type WorkFlowEdgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkFlowEdgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkFlowEdgeCountAggregateInputType | true
    }

  export interface WorkFlowEdgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkFlowEdge'], meta: { name: 'WorkFlowEdge' } }
    /**
     * Find zero or one WorkFlowEdge that matches the filter.
     * @param {WorkFlowEdgeFindUniqueArgs} args - Arguments to find a WorkFlowEdge
     * @example
     * // Get one WorkFlowEdge
     * const workFlowEdge = await prisma.workFlowEdge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkFlowEdgeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowEdgeFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkFlowEdgeClient<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WorkFlowEdge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkFlowEdgeFindUniqueOrThrowArgs} args - Arguments to find a WorkFlowEdge
     * @example
     * // Get one WorkFlowEdge
     * const workFlowEdge = await prisma.workFlowEdge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkFlowEdgeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowEdgeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkFlowEdgeClient<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WorkFlowEdge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowEdgeFindFirstArgs} args - Arguments to find a WorkFlowEdge
     * @example
     * // Get one WorkFlowEdge
     * const workFlowEdge = await prisma.workFlowEdge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkFlowEdgeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowEdgeFindFirstArgs<ExtArgs>>
    ): Prisma__WorkFlowEdgeClient<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WorkFlowEdge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowEdgeFindFirstOrThrowArgs} args - Arguments to find a WorkFlowEdge
     * @example
     * // Get one WorkFlowEdge
     * const workFlowEdge = await prisma.workFlowEdge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkFlowEdgeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowEdgeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkFlowEdgeClient<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WorkFlowEdges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowEdgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkFlowEdges
     * const workFlowEdges = await prisma.workFlowEdge.findMany()
     * 
     * // Get first 10 WorkFlowEdges
     * const workFlowEdges = await prisma.workFlowEdge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workFlowEdgeWithIdOnly = await prisma.workFlowEdge.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkFlowEdgeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowEdgeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WorkFlowEdge.
     * @param {WorkFlowEdgeCreateArgs} args - Arguments to create a WorkFlowEdge.
     * @example
     * // Create one WorkFlowEdge
     * const WorkFlowEdge = await prisma.workFlowEdge.create({
     *   data: {
     *     // ... data to create a WorkFlowEdge
     *   }
     * })
     * 
    **/
    create<T extends WorkFlowEdgeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowEdgeCreateArgs<ExtArgs>>
    ): Prisma__WorkFlowEdgeClient<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WorkFlowEdges.
     * @param {WorkFlowEdgeCreateManyArgs} args - Arguments to create many WorkFlowEdges.
     * @example
     * // Create many WorkFlowEdges
     * const workFlowEdge = await prisma.workFlowEdge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends WorkFlowEdgeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowEdgeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkFlowEdges and returns the data saved in the database.
     * @param {WorkFlowEdgeCreateManyAndReturnArgs} args - Arguments to create many WorkFlowEdges.
     * @example
     * // Create many WorkFlowEdges
     * const workFlowEdge = await prisma.workFlowEdge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkFlowEdges and only return the `id`
     * const workFlowEdgeWithIdOnly = await prisma.workFlowEdge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends WorkFlowEdgeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowEdgeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a WorkFlowEdge.
     * @param {WorkFlowEdgeDeleteArgs} args - Arguments to delete one WorkFlowEdge.
     * @example
     * // Delete one WorkFlowEdge
     * const WorkFlowEdge = await prisma.workFlowEdge.delete({
     *   where: {
     *     // ... filter to delete one WorkFlowEdge
     *   }
     * })
     * 
    **/
    delete<T extends WorkFlowEdgeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowEdgeDeleteArgs<ExtArgs>>
    ): Prisma__WorkFlowEdgeClient<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WorkFlowEdge.
     * @param {WorkFlowEdgeUpdateArgs} args - Arguments to update one WorkFlowEdge.
     * @example
     * // Update one WorkFlowEdge
     * const workFlowEdge = await prisma.workFlowEdge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkFlowEdgeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowEdgeUpdateArgs<ExtArgs>>
    ): Prisma__WorkFlowEdgeClient<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WorkFlowEdges.
     * @param {WorkFlowEdgeDeleteManyArgs} args - Arguments to filter WorkFlowEdges to delete.
     * @example
     * // Delete a few WorkFlowEdges
     * const { count } = await prisma.workFlowEdge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkFlowEdgeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowEdgeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkFlowEdges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowEdgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkFlowEdges
     * const workFlowEdge = await prisma.workFlowEdge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkFlowEdgeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowEdgeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkFlowEdge.
     * @param {WorkFlowEdgeUpsertArgs} args - Arguments to update or create a WorkFlowEdge.
     * @example
     * // Update or create a WorkFlowEdge
     * const workFlowEdge = await prisma.workFlowEdge.upsert({
     *   create: {
     *     // ... data to create a WorkFlowEdge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkFlowEdge we want to update
     *   }
     * })
    **/
    upsert<T extends WorkFlowEdgeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowEdgeUpsertArgs<ExtArgs>>
    ): Prisma__WorkFlowEdgeClient<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WorkFlowEdges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowEdgeCountArgs} args - Arguments to filter WorkFlowEdges to count.
     * @example
     * // Count the number of WorkFlowEdges
     * const count = await prisma.workFlowEdge.count({
     *   where: {
     *     // ... the filter for the WorkFlowEdges we want to count
     *   }
     * })
    **/
    count<T extends WorkFlowEdgeCountArgs>(
      args?: Subset<T, WorkFlowEdgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkFlowEdgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkFlowEdge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowEdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkFlowEdgeAggregateArgs>(args: Subset<T, WorkFlowEdgeAggregateArgs>): Prisma.PrismaPromise<GetWorkFlowEdgeAggregateType<T>>

    /**
     * Group by WorkFlowEdge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowEdgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkFlowEdgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkFlowEdgeGroupByArgs['orderBy'] }
        : { orderBy?: WorkFlowEdgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkFlowEdgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkFlowEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkFlowEdge model
   */
  readonly fields: WorkFlowEdgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkFlowEdge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkFlowEdgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    source<T extends WorkFlowNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlowNodeDefaultArgs<ExtArgs>>): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    target<T extends WorkFlowNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlowNodeDefaultArgs<ExtArgs>>): Prisma__WorkFlowNodeClient<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    WorkFlow<T extends WorkFlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlowDefaultArgs<ExtArgs>>): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WorkFlowEdge model
   */ 
  interface WorkFlowEdgeFieldRefs {
    readonly id: FieldRef<"WorkFlowEdge", 'String'>
    readonly sourceId: FieldRef<"WorkFlowEdge", 'String'>
    readonly targetId: FieldRef<"WorkFlowEdge", 'String'>
    readonly createdAt: FieldRef<"WorkFlowEdge", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkFlowEdge", 'DateTime'>
    readonly workFlowId: FieldRef<"WorkFlowEdge", 'String'>
    readonly data: FieldRef<"WorkFlowEdge", 'Json'>
    readonly count: FieldRef<"WorkFlowEdge", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WorkFlowEdge findUnique
   */
  export type WorkFlowEdgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowEdge to fetch.
     */
    where: WorkFlowEdgeWhereUniqueInput
  }

  /**
   * WorkFlowEdge findUniqueOrThrow
   */
  export type WorkFlowEdgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowEdge to fetch.
     */
    where: WorkFlowEdgeWhereUniqueInput
  }

  /**
   * WorkFlowEdge findFirst
   */
  export type WorkFlowEdgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowEdge to fetch.
     */
    where?: WorkFlowEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlowEdges to fetch.
     */
    orderBy?: WorkFlowEdgeOrderByWithRelationInput | WorkFlowEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkFlowEdges.
     */
    cursor?: WorkFlowEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlowEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlowEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkFlowEdges.
     */
    distinct?: WorkFlowEdgeScalarFieldEnum | WorkFlowEdgeScalarFieldEnum[]
  }

  /**
   * WorkFlowEdge findFirstOrThrow
   */
  export type WorkFlowEdgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowEdge to fetch.
     */
    where?: WorkFlowEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlowEdges to fetch.
     */
    orderBy?: WorkFlowEdgeOrderByWithRelationInput | WorkFlowEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkFlowEdges.
     */
    cursor?: WorkFlowEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlowEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlowEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkFlowEdges.
     */
    distinct?: WorkFlowEdgeScalarFieldEnum | WorkFlowEdgeScalarFieldEnum[]
  }

  /**
   * WorkFlowEdge findMany
   */
  export type WorkFlowEdgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlowEdges to fetch.
     */
    where?: WorkFlowEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlowEdges to fetch.
     */
    orderBy?: WorkFlowEdgeOrderByWithRelationInput | WorkFlowEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkFlowEdges.
     */
    cursor?: WorkFlowEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlowEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlowEdges.
     */
    skip?: number
    distinct?: WorkFlowEdgeScalarFieldEnum | WorkFlowEdgeScalarFieldEnum[]
  }

  /**
   * WorkFlowEdge create
   */
  export type WorkFlowEdgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkFlowEdge.
     */
    data: XOR<WorkFlowEdgeCreateInput, WorkFlowEdgeUncheckedCreateInput>
  }

  /**
   * WorkFlowEdge createMany
   */
  export type WorkFlowEdgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkFlowEdges.
     */
    data: WorkFlowEdgeCreateManyInput | WorkFlowEdgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkFlowEdge createManyAndReturn
   */
  export type WorkFlowEdgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkFlowEdges.
     */
    data: WorkFlowEdgeCreateManyInput | WorkFlowEdgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkFlowEdge update
   */
  export type WorkFlowEdgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkFlowEdge.
     */
    data: XOR<WorkFlowEdgeUpdateInput, WorkFlowEdgeUncheckedUpdateInput>
    /**
     * Choose, which WorkFlowEdge to update.
     */
    where: WorkFlowEdgeWhereUniqueInput
  }

  /**
   * WorkFlowEdge updateMany
   */
  export type WorkFlowEdgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkFlowEdges.
     */
    data: XOR<WorkFlowEdgeUpdateManyMutationInput, WorkFlowEdgeUncheckedUpdateManyInput>
    /**
     * Filter which WorkFlowEdges to update
     */
    where?: WorkFlowEdgeWhereInput
  }

  /**
   * WorkFlowEdge upsert
   */
  export type WorkFlowEdgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkFlowEdge to update in case it exists.
     */
    where: WorkFlowEdgeWhereUniqueInput
    /**
     * In case the WorkFlowEdge found by the `where` argument doesn't exist, create a new WorkFlowEdge with this data.
     */
    create: XOR<WorkFlowEdgeCreateInput, WorkFlowEdgeUncheckedCreateInput>
    /**
     * In case the WorkFlowEdge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkFlowEdgeUpdateInput, WorkFlowEdgeUncheckedUpdateInput>
  }

  /**
   * WorkFlowEdge delete
   */
  export type WorkFlowEdgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    /**
     * Filter which WorkFlowEdge to delete.
     */
    where: WorkFlowEdgeWhereUniqueInput
  }

  /**
   * WorkFlowEdge deleteMany
   */
  export type WorkFlowEdgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkFlowEdges to delete
     */
    where?: WorkFlowEdgeWhereInput
  }

  /**
   * WorkFlowEdge without action
   */
  export type WorkFlowEdgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
  }


  /**
   * Model WorkFlow
   */

  export type AggregateWorkFlow = {
    _count: WorkFlowCountAggregateOutputType | null
    _min: WorkFlowMinAggregateOutputType | null
    _max: WorkFlowMaxAggregateOutputType | null
  }

  export type WorkFlowMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkFlowMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkFlowCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkFlowMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkFlowMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkFlowCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkFlowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkFlow to aggregate.
     */
    where?: WorkFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlows to fetch.
     */
    orderBy?: WorkFlowOrderByWithRelationInput | WorkFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkFlows
    **/
    _count?: true | WorkFlowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkFlowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkFlowMaxAggregateInputType
  }

  export type GetWorkFlowAggregateType<T extends WorkFlowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkFlow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkFlow[P]>
      : GetScalarType<T[P], AggregateWorkFlow[P]>
  }




  export type WorkFlowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkFlowWhereInput
    orderBy?: WorkFlowOrderByWithAggregationInput | WorkFlowOrderByWithAggregationInput[]
    by: WorkFlowScalarFieldEnum[] | WorkFlowScalarFieldEnum
    having?: WorkFlowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkFlowCountAggregateInputType | true
    _min?: WorkFlowMinAggregateInputType
    _max?: WorkFlowMaxAggregateInputType
  }

  export type WorkFlowGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: WorkFlowCountAggregateOutputType | null
    _min: WorkFlowMinAggregateOutputType | null
    _max: WorkFlowMaxAggregateOutputType | null
  }

  type GetWorkFlowGroupByPayload<T extends WorkFlowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkFlowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkFlowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkFlowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkFlowGroupByOutputType[P]>
        }
      >
    >


  export type WorkFlowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | WorkFlow$projectArgs<ExtArgs>
    WorkFlowEdge?: boolean | WorkFlow$WorkFlowEdgeArgs<ExtArgs>
    WorkflowNode?: boolean | WorkFlow$WorkflowNodeArgs<ExtArgs>
    _count?: boolean | WorkFlowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workFlow"]>

  export type WorkFlowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workFlow"]>

  export type WorkFlowSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkFlowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | WorkFlow$projectArgs<ExtArgs>
    WorkFlowEdge?: boolean | WorkFlow$WorkFlowEdgeArgs<ExtArgs>
    WorkflowNode?: boolean | WorkFlow$WorkflowNodeArgs<ExtArgs>
    _count?: boolean | WorkFlowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkFlowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkFlowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkFlow"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      WorkFlowEdge: Prisma.$WorkFlowEdgePayload<ExtArgs>[]
      WorkflowNode: Prisma.$WorkFlowNodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workFlow"]>
    composites: {}
  }

  type WorkFlowGetPayload<S extends boolean | null | undefined | WorkFlowDefaultArgs> = $Result.GetResult<Prisma.$WorkFlowPayload, S>

  type WorkFlowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkFlowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkFlowCountAggregateInputType | true
    }

  export interface WorkFlowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkFlow'], meta: { name: 'WorkFlow' } }
    /**
     * Find zero or one WorkFlow that matches the filter.
     * @param {WorkFlowFindUniqueArgs} args - Arguments to find a WorkFlow
     * @example
     * // Get one WorkFlow
     * const workFlow = await prisma.workFlow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkFlowFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WorkFlow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkFlowFindUniqueOrThrowArgs} args - Arguments to find a WorkFlow
     * @example
     * // Get one WorkFlow
     * const workFlow = await prisma.workFlow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkFlowFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WorkFlow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowFindFirstArgs} args - Arguments to find a WorkFlow
     * @example
     * // Get one WorkFlow
     * const workFlow = await prisma.workFlow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkFlowFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowFindFirstArgs<ExtArgs>>
    ): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WorkFlow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowFindFirstOrThrowArgs} args - Arguments to find a WorkFlow
     * @example
     * // Get one WorkFlow
     * const workFlow = await prisma.workFlow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkFlowFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WorkFlows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkFlows
     * const workFlows = await prisma.workFlow.findMany()
     * 
     * // Get first 10 WorkFlows
     * const workFlows = await prisma.workFlow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workFlowWithIdOnly = await prisma.workFlow.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkFlowFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WorkFlow.
     * @param {WorkFlowCreateArgs} args - Arguments to create a WorkFlow.
     * @example
     * // Create one WorkFlow
     * const WorkFlow = await prisma.workFlow.create({
     *   data: {
     *     // ... data to create a WorkFlow
     *   }
     * })
     * 
    **/
    create<T extends WorkFlowCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowCreateArgs<ExtArgs>>
    ): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WorkFlows.
     * @param {WorkFlowCreateManyArgs} args - Arguments to create many WorkFlows.
     * @example
     * // Create many WorkFlows
     * const workFlow = await prisma.workFlow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends WorkFlowCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkFlows and returns the data saved in the database.
     * @param {WorkFlowCreateManyAndReturnArgs} args - Arguments to create many WorkFlows.
     * @example
     * // Create many WorkFlows
     * const workFlow = await prisma.workFlow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkFlows and only return the `id`
     * const workFlowWithIdOnly = await prisma.workFlow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends WorkFlowCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a WorkFlow.
     * @param {WorkFlowDeleteArgs} args - Arguments to delete one WorkFlow.
     * @example
     * // Delete one WorkFlow
     * const WorkFlow = await prisma.workFlow.delete({
     *   where: {
     *     // ... filter to delete one WorkFlow
     *   }
     * })
     * 
    **/
    delete<T extends WorkFlowDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowDeleteArgs<ExtArgs>>
    ): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WorkFlow.
     * @param {WorkFlowUpdateArgs} args - Arguments to update one WorkFlow.
     * @example
     * // Update one WorkFlow
     * const workFlow = await prisma.workFlow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkFlowUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowUpdateArgs<ExtArgs>>
    ): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WorkFlows.
     * @param {WorkFlowDeleteManyArgs} args - Arguments to filter WorkFlows to delete.
     * @example
     * // Delete a few WorkFlows
     * const { count } = await prisma.workFlow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkFlowDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkFlowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkFlows
     * const workFlow = await prisma.workFlow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkFlowUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkFlow.
     * @param {WorkFlowUpsertArgs} args - Arguments to update or create a WorkFlow.
     * @example
     * // Update or create a WorkFlow
     * const workFlow = await prisma.workFlow.upsert({
     *   create: {
     *     // ... data to create a WorkFlow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkFlow we want to update
     *   }
     * })
    **/
    upsert<T extends WorkFlowUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkFlowUpsertArgs<ExtArgs>>
    ): Prisma__WorkFlowClient<$Result.GetResult<Prisma.$WorkFlowPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WorkFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowCountArgs} args - Arguments to filter WorkFlows to count.
     * @example
     * // Count the number of WorkFlows
     * const count = await prisma.workFlow.count({
     *   where: {
     *     // ... the filter for the WorkFlows we want to count
     *   }
     * })
    **/
    count<T extends WorkFlowCountArgs>(
      args?: Subset<T, WorkFlowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkFlowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkFlowAggregateArgs>(args: Subset<T, WorkFlowAggregateArgs>): Prisma.PrismaPromise<GetWorkFlowAggregateType<T>>

    /**
     * Group by WorkFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFlowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkFlowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkFlowGroupByArgs['orderBy'] }
        : { orderBy?: WorkFlowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkFlowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkFlowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkFlow model
   */
  readonly fields: WorkFlowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkFlow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkFlowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    project<T extends WorkFlow$projectArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlow$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    WorkFlowEdge<T extends WorkFlow$WorkFlowEdgeArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlow$WorkFlowEdgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowEdgePayload<ExtArgs>, T, 'findMany'> | Null>;

    WorkflowNode<T extends WorkFlow$WorkflowNodeArgs<ExtArgs> = {}>(args?: Subset<T, WorkFlow$WorkflowNodeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkFlowNodePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WorkFlow model
   */ 
  interface WorkFlowFieldRefs {
    readonly id: FieldRef<"WorkFlow", 'String'>
    readonly createdAt: FieldRef<"WorkFlow", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkFlow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkFlow findUnique
   */
  export type WorkFlowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlow to fetch.
     */
    where: WorkFlowWhereUniqueInput
  }

  /**
   * WorkFlow findUniqueOrThrow
   */
  export type WorkFlowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlow to fetch.
     */
    where: WorkFlowWhereUniqueInput
  }

  /**
   * WorkFlow findFirst
   */
  export type WorkFlowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlow to fetch.
     */
    where?: WorkFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlows to fetch.
     */
    orderBy?: WorkFlowOrderByWithRelationInput | WorkFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkFlows.
     */
    cursor?: WorkFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkFlows.
     */
    distinct?: WorkFlowScalarFieldEnum | WorkFlowScalarFieldEnum[]
  }

  /**
   * WorkFlow findFirstOrThrow
   */
  export type WorkFlowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlow to fetch.
     */
    where?: WorkFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlows to fetch.
     */
    orderBy?: WorkFlowOrderByWithRelationInput | WorkFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkFlows.
     */
    cursor?: WorkFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkFlows.
     */
    distinct?: WorkFlowScalarFieldEnum | WorkFlowScalarFieldEnum[]
  }

  /**
   * WorkFlow findMany
   */
  export type WorkFlowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * Filter, which WorkFlows to fetch.
     */
    where?: WorkFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkFlows to fetch.
     */
    orderBy?: WorkFlowOrderByWithRelationInput | WorkFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkFlows.
     */
    cursor?: WorkFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkFlows.
     */
    skip?: number
    distinct?: WorkFlowScalarFieldEnum | WorkFlowScalarFieldEnum[]
  }

  /**
   * WorkFlow create
   */
  export type WorkFlowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkFlow.
     */
    data?: XOR<WorkFlowCreateInput, WorkFlowUncheckedCreateInput>
  }

  /**
   * WorkFlow createMany
   */
  export type WorkFlowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkFlows.
     */
    data: WorkFlowCreateManyInput | WorkFlowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkFlow createManyAndReturn
   */
  export type WorkFlowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkFlows.
     */
    data: WorkFlowCreateManyInput | WorkFlowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkFlow update
   */
  export type WorkFlowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkFlow.
     */
    data: XOR<WorkFlowUpdateInput, WorkFlowUncheckedUpdateInput>
    /**
     * Choose, which WorkFlow to update.
     */
    where: WorkFlowWhereUniqueInput
  }

  /**
   * WorkFlow updateMany
   */
  export type WorkFlowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkFlows.
     */
    data: XOR<WorkFlowUpdateManyMutationInput, WorkFlowUncheckedUpdateManyInput>
    /**
     * Filter which WorkFlows to update
     */
    where?: WorkFlowWhereInput
  }

  /**
   * WorkFlow upsert
   */
  export type WorkFlowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkFlow to update in case it exists.
     */
    where: WorkFlowWhereUniqueInput
    /**
     * In case the WorkFlow found by the `where` argument doesn't exist, create a new WorkFlow with this data.
     */
    create: XOR<WorkFlowCreateInput, WorkFlowUncheckedCreateInput>
    /**
     * In case the WorkFlow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkFlowUpdateInput, WorkFlowUncheckedUpdateInput>
  }

  /**
   * WorkFlow delete
   */
  export type WorkFlowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
    /**
     * Filter which WorkFlow to delete.
     */
    where: WorkFlowWhereUniqueInput
  }

  /**
   * WorkFlow deleteMany
   */
  export type WorkFlowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkFlows to delete
     */
    where?: WorkFlowWhereInput
  }

  /**
   * WorkFlow.project
   */
  export type WorkFlow$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * WorkFlow.WorkFlowEdge
   */
  export type WorkFlow$WorkFlowEdgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowEdge
     */
    select?: WorkFlowEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowEdgeInclude<ExtArgs> | null
    where?: WorkFlowEdgeWhereInput
    orderBy?: WorkFlowEdgeOrderByWithRelationInput | WorkFlowEdgeOrderByWithRelationInput[]
    cursor?: WorkFlowEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkFlowEdgeScalarFieldEnum | WorkFlowEdgeScalarFieldEnum[]
  }

  /**
   * WorkFlow.WorkflowNode
   */
  export type WorkFlow$WorkflowNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlowNode
     */
    select?: WorkFlowNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowNodeInclude<ExtArgs> | null
    where?: WorkFlowNodeWhereInput
    orderBy?: WorkFlowNodeOrderByWithRelationInput | WorkFlowNodeOrderByWithRelationInput[]
    cursor?: WorkFlowNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkFlowNodeScalarFieldEnum | WorkFlowNodeScalarFieldEnum[]
  }

  /**
   * WorkFlow without action
   */
  export type WorkFlowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkFlow
     */
    select?: WorkFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkFlowInclude<ExtArgs> | null
  }


  /**
   * Model OperationHistory
   */

  export type AggregateOperationHistory = {
    _count: OperationHistoryCountAggregateOutputType | null
    _avg: OperationHistoryAvgAggregateOutputType | null
    _sum: OperationHistorySumAggregateOutputType | null
    _min: OperationHistoryMinAggregateOutputType | null
    _max: OperationHistoryMaxAggregateOutputType | null
  }

  export type OperationHistoryAvgAggregateOutputType = {
    count: number | null
  }

  export type OperationHistorySumAggregateOutputType = {
    count: number | null
  }

  export type OperationHistoryMinAggregateOutputType = {
    id: string | null
    planningId: string | null
    count: number | null
    createdAt: Date | null
  }

  export type OperationHistoryMaxAggregateOutputType = {
    id: string | null
    planningId: string | null
    count: number | null
    createdAt: Date | null
  }

  export type OperationHistoryCountAggregateOutputType = {
    id: number
    planningId: number
    count: number
    createdAt: number
    _all: number
  }


  export type OperationHistoryAvgAggregateInputType = {
    count?: true
  }

  export type OperationHistorySumAggregateInputType = {
    count?: true
  }

  export type OperationHistoryMinAggregateInputType = {
    id?: true
    planningId?: true
    count?: true
    createdAt?: true
  }

  export type OperationHistoryMaxAggregateInputType = {
    id?: true
    planningId?: true
    count?: true
    createdAt?: true
  }

  export type OperationHistoryCountAggregateInputType = {
    id?: true
    planningId?: true
    count?: true
    createdAt?: true
    _all?: true
  }

  export type OperationHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationHistory to aggregate.
     */
    where?: OperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationHistories to fetch.
     */
    orderBy?: OperationHistoryOrderByWithRelationInput | OperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationHistories
    **/
    _count?: true | OperationHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationHistoryMaxAggregateInputType
  }

  export type GetOperationHistoryAggregateType<T extends OperationHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationHistory[P]>
      : GetScalarType<T[P], AggregateOperationHistory[P]>
  }




  export type OperationHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationHistoryWhereInput
    orderBy?: OperationHistoryOrderByWithAggregationInput | OperationHistoryOrderByWithAggregationInput[]
    by: OperationHistoryScalarFieldEnum[] | OperationHistoryScalarFieldEnum
    having?: OperationHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationHistoryCountAggregateInputType | true
    _avg?: OperationHistoryAvgAggregateInputType
    _sum?: OperationHistorySumAggregateInputType
    _min?: OperationHistoryMinAggregateInputType
    _max?: OperationHistoryMaxAggregateInputType
  }

  export type OperationHistoryGroupByOutputType = {
    id: string
    planningId: string
    count: number
    createdAt: Date
    _count: OperationHistoryCountAggregateOutputType | null
    _avg: OperationHistoryAvgAggregateOutputType | null
    _sum: OperationHistorySumAggregateOutputType | null
    _min: OperationHistoryMinAggregateOutputType | null
    _max: OperationHistoryMaxAggregateOutputType | null
  }

  type GetOperationHistoryGroupByPayload<T extends OperationHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], OperationHistoryGroupByOutputType[P]>
        }
      >
    >


  export type OperationHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planningId?: boolean
    count?: boolean
    createdAt?: boolean
    planning?: boolean | PlanningDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationHistory"]>

  export type OperationHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planningId?: boolean
    count?: boolean
    createdAt?: boolean
    planning?: boolean | PlanningDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationHistory"]>

  export type OperationHistorySelectScalar = {
    id?: boolean
    planningId?: boolean
    count?: boolean
    createdAt?: boolean
  }

  export type OperationHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planning?: boolean | PlanningDefaultArgs<ExtArgs>
  }
  export type OperationHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planning?: boolean | PlanningDefaultArgs<ExtArgs>
  }

  export type $OperationHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationHistory"
    objects: {
      planning: Prisma.$PlanningPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planningId: string
      count: number
      createdAt: Date
    }, ExtArgs["result"]["operationHistory"]>
    composites: {}
  }

  type OperationHistoryGetPayload<S extends boolean | null | undefined | OperationHistoryDefaultArgs> = $Result.GetResult<Prisma.$OperationHistoryPayload, S>

  type OperationHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationHistoryCountAggregateInputType | true
    }

  export interface OperationHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationHistory'], meta: { name: 'OperationHistory' } }
    /**
     * Find zero or one OperationHistory that matches the filter.
     * @param {OperationHistoryFindUniqueArgs} args - Arguments to find a OperationHistory
     * @example
     * // Get one OperationHistory
     * const operationHistory = await prisma.operationHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OperationHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OperationHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__OperationHistoryClient<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OperationHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationHistoryFindUniqueOrThrowArgs} args - Arguments to find a OperationHistory
     * @example
     * // Get one OperationHistory
     * const operationHistory = await prisma.operationHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OperationHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OperationHistoryClient<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OperationHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationHistoryFindFirstArgs} args - Arguments to find a OperationHistory
     * @example
     * // Get one OperationHistory
     * const operationHistory = await prisma.operationHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OperationHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__OperationHistoryClient<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OperationHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationHistoryFindFirstOrThrowArgs} args - Arguments to find a OperationHistory
     * @example
     * // Get one OperationHistory
     * const operationHistory = await prisma.operationHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OperationHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OperationHistoryClient<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OperationHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationHistories
     * const operationHistories = await prisma.operationHistory.findMany()
     * 
     * // Get first 10 OperationHistories
     * const operationHistories = await prisma.operationHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationHistoryWithIdOnly = await prisma.operationHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OperationHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OperationHistory.
     * @param {OperationHistoryCreateArgs} args - Arguments to create a OperationHistory.
     * @example
     * // Create one OperationHistory
     * const OperationHistory = await prisma.operationHistory.create({
     *   data: {
     *     // ... data to create a OperationHistory
     *   }
     * })
     * 
    **/
    create<T extends OperationHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OperationHistoryCreateArgs<ExtArgs>>
    ): Prisma__OperationHistoryClient<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OperationHistories.
     * @param {OperationHistoryCreateManyArgs} args - Arguments to create many OperationHistories.
     * @example
     * // Create many OperationHistories
     * const operationHistory = await prisma.operationHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends OperationHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperationHistories and returns the data saved in the database.
     * @param {OperationHistoryCreateManyAndReturnArgs} args - Arguments to create many OperationHistories.
     * @example
     * // Create many OperationHistories
     * const operationHistory = await prisma.operationHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperationHistories and only return the `id`
     * const operationHistoryWithIdOnly = await prisma.operationHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends OperationHistoryCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationHistoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a OperationHistory.
     * @param {OperationHistoryDeleteArgs} args - Arguments to delete one OperationHistory.
     * @example
     * // Delete one OperationHistory
     * const OperationHistory = await prisma.operationHistory.delete({
     *   where: {
     *     // ... filter to delete one OperationHistory
     *   }
     * })
     * 
    **/
    delete<T extends OperationHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OperationHistoryDeleteArgs<ExtArgs>>
    ): Prisma__OperationHistoryClient<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OperationHistory.
     * @param {OperationHistoryUpdateArgs} args - Arguments to update one OperationHistory.
     * @example
     * // Update one OperationHistory
     * const operationHistory = await prisma.operationHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OperationHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OperationHistoryUpdateArgs<ExtArgs>>
    ): Prisma__OperationHistoryClient<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OperationHistories.
     * @param {OperationHistoryDeleteManyArgs} args - Arguments to filter OperationHistories to delete.
     * @example
     * // Delete a few OperationHistories
     * const { count } = await prisma.operationHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OperationHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationHistories
     * const operationHistory = await prisma.operationHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OperationHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OperationHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationHistory.
     * @param {OperationHistoryUpsertArgs} args - Arguments to update or create a OperationHistory.
     * @example
     * // Update or create a OperationHistory
     * const operationHistory = await prisma.operationHistory.upsert({
     *   create: {
     *     // ... data to create a OperationHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationHistory we want to update
     *   }
     * })
    **/
    upsert<T extends OperationHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OperationHistoryUpsertArgs<ExtArgs>>
    ): Prisma__OperationHistoryClient<$Result.GetResult<Prisma.$OperationHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OperationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationHistoryCountArgs} args - Arguments to filter OperationHistories to count.
     * @example
     * // Count the number of OperationHistories
     * const count = await prisma.operationHistory.count({
     *   where: {
     *     // ... the filter for the OperationHistories we want to count
     *   }
     * })
    **/
    count<T extends OperationHistoryCountArgs>(
      args?: Subset<T, OperationHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationHistoryAggregateArgs>(args: Subset<T, OperationHistoryAggregateArgs>): Prisma.PrismaPromise<GetOperationHistoryAggregateType<T>>

    /**
     * Group by OperationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationHistoryGroupByArgs['orderBy'] }
        : { orderBy?: OperationHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationHistory model
   */
  readonly fields: OperationHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    planning<T extends PlanningDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanningDefaultArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OperationHistory model
   */ 
  interface OperationHistoryFieldRefs {
    readonly id: FieldRef<"OperationHistory", 'String'>
    readonly planningId: FieldRef<"OperationHistory", 'String'>
    readonly count: FieldRef<"OperationHistory", 'Int'>
    readonly createdAt: FieldRef<"OperationHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperationHistory findUnique
   */
  export type OperationHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OperationHistory to fetch.
     */
    where: OperationHistoryWhereUniqueInput
  }

  /**
   * OperationHistory findUniqueOrThrow
   */
  export type OperationHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OperationHistory to fetch.
     */
    where: OperationHistoryWhereUniqueInput
  }

  /**
   * OperationHistory findFirst
   */
  export type OperationHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OperationHistory to fetch.
     */
    where?: OperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationHistories to fetch.
     */
    orderBy?: OperationHistoryOrderByWithRelationInput | OperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationHistories.
     */
    cursor?: OperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationHistories.
     */
    distinct?: OperationHistoryScalarFieldEnum | OperationHistoryScalarFieldEnum[]
  }

  /**
   * OperationHistory findFirstOrThrow
   */
  export type OperationHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OperationHistory to fetch.
     */
    where?: OperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationHistories to fetch.
     */
    orderBy?: OperationHistoryOrderByWithRelationInput | OperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationHistories.
     */
    cursor?: OperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationHistories.
     */
    distinct?: OperationHistoryScalarFieldEnum | OperationHistoryScalarFieldEnum[]
  }

  /**
   * OperationHistory findMany
   */
  export type OperationHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OperationHistories to fetch.
     */
    where?: OperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationHistories to fetch.
     */
    orderBy?: OperationHistoryOrderByWithRelationInput | OperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationHistories.
     */
    cursor?: OperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationHistories.
     */
    skip?: number
    distinct?: OperationHistoryScalarFieldEnum | OperationHistoryScalarFieldEnum[]
  }

  /**
   * OperationHistory create
   */
  export type OperationHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationHistory.
     */
    data: XOR<OperationHistoryCreateInput, OperationHistoryUncheckedCreateInput>
  }

  /**
   * OperationHistory createMany
   */
  export type OperationHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationHistories.
     */
    data: OperationHistoryCreateManyInput | OperationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationHistory createManyAndReturn
   */
  export type OperationHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OperationHistories.
     */
    data: OperationHistoryCreateManyInput | OperationHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationHistory update
   */
  export type OperationHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationHistory.
     */
    data: XOR<OperationHistoryUpdateInput, OperationHistoryUncheckedUpdateInput>
    /**
     * Choose, which OperationHistory to update.
     */
    where: OperationHistoryWhereUniqueInput
  }

  /**
   * OperationHistory updateMany
   */
  export type OperationHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationHistories.
     */
    data: XOR<OperationHistoryUpdateManyMutationInput, OperationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which OperationHistories to update
     */
    where?: OperationHistoryWhereInput
  }

  /**
   * OperationHistory upsert
   */
  export type OperationHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationHistory to update in case it exists.
     */
    where: OperationHistoryWhereUniqueInput
    /**
     * In case the OperationHistory found by the `where` argument doesn't exist, create a new OperationHistory with this data.
     */
    create: XOR<OperationHistoryCreateInput, OperationHistoryUncheckedCreateInput>
    /**
     * In case the OperationHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationHistoryUpdateInput, OperationHistoryUncheckedUpdateInput>
  }

  /**
   * OperationHistory delete
   */
  export type OperationHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
    /**
     * Filter which OperationHistory to delete.
     */
    where: OperationHistoryWhereUniqueInput
  }

  /**
   * OperationHistory deleteMany
   */
  export type OperationHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationHistories to delete
     */
    where?: OperationHistoryWhereInput
  }

  /**
   * OperationHistory without action
   */
  export type OperationHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationHistory
     */
    select?: OperationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Expertise
   */

  export type AggregateExpertise = {
    _count: ExpertiseCountAggregateOutputType | null
    _min: ExpertiseMinAggregateOutputType | null
    _max: ExpertiseMaxAggregateOutputType | null
  }

  export type ExpertiseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpertiseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpertiseCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpertiseMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpertiseMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpertiseCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpertiseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expertise to aggregate.
     */
    where?: ExpertiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expertise to fetch.
     */
    orderBy?: ExpertiseOrderByWithRelationInput | ExpertiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpertiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expertise from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expertise.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expertise
    **/
    _count?: true | ExpertiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpertiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpertiseMaxAggregateInputType
  }

  export type GetExpertiseAggregateType<T extends ExpertiseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpertise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpertise[P]>
      : GetScalarType<T[P], AggregateExpertise[P]>
  }




  export type ExpertiseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpertiseWhereInput
    orderBy?: ExpertiseOrderByWithAggregationInput | ExpertiseOrderByWithAggregationInput[]
    by: ExpertiseScalarFieldEnum[] | ExpertiseScalarFieldEnum
    having?: ExpertiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpertiseCountAggregateInputType | true
    _min?: ExpertiseMinAggregateInputType
    _max?: ExpertiseMaxAggregateInputType
  }

  export type ExpertiseGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    code: string
    createdAt: Date
    updatedAt: Date
    _count: ExpertiseCountAggregateOutputType | null
    _min: ExpertiseMinAggregateOutputType | null
    _max: ExpertiseMaxAggregateOutputType | null
  }

  type GetExpertiseGroupByPayload<T extends ExpertiseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpertiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpertiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpertiseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpertiseGroupByOutputType[P]>
        }
      >
    >


  export type ExpertiseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
    operations?: boolean | Expertise$operationsArgs<ExtArgs>
    posts?: boolean | Expertise$postsArgs<ExtArgs>
    _count?: boolean | ExpertiseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expertise"]>

  export type ExpertiseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expertise"]>

  export type ExpertiseSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpertiseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
    operations?: boolean | Expertise$operationsArgs<ExtArgs>
    posts?: boolean | Expertise$postsArgs<ExtArgs>
    _count?: boolean | ExpertiseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpertiseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExpertisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expertise"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
      operations: Prisma.$OperationPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      code: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expertise"]>
    composites: {}
  }

  type ExpertiseGetPayload<S extends boolean | null | undefined | ExpertiseDefaultArgs> = $Result.GetResult<Prisma.$ExpertisePayload, S>

  type ExpertiseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpertiseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpertiseCountAggregateInputType | true
    }

  export interface ExpertiseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expertise'], meta: { name: 'Expertise' } }
    /**
     * Find zero or one Expertise that matches the filter.
     * @param {ExpertiseFindUniqueArgs} args - Arguments to find a Expertise
     * @example
     * // Get one Expertise
     * const expertise = await prisma.expertise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExpertiseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ExpertiseFindUniqueArgs<ExtArgs>>
    ): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Expertise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpertiseFindUniqueOrThrowArgs} args - Arguments to find a Expertise
     * @example
     * // Get one Expertise
     * const expertise = await prisma.expertise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExpertiseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpertiseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Expertise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertiseFindFirstArgs} args - Arguments to find a Expertise
     * @example
     * // Get one Expertise
     * const expertise = await prisma.expertise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExpertiseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpertiseFindFirstArgs<ExtArgs>>
    ): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Expertise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertiseFindFirstOrThrowArgs} args - Arguments to find a Expertise
     * @example
     * // Get one Expertise
     * const expertise = await prisma.expertise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExpertiseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpertiseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Expertise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertiseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expertise
     * const expertise = await prisma.expertise.findMany()
     * 
     * // Get first 10 Expertise
     * const expertise = await prisma.expertise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expertiseWithIdOnly = await prisma.expertise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExpertiseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpertiseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Expertise.
     * @param {ExpertiseCreateArgs} args - Arguments to create a Expertise.
     * @example
     * // Create one Expertise
     * const Expertise = await prisma.expertise.create({
     *   data: {
     *     // ... data to create a Expertise
     *   }
     * })
     * 
    **/
    create<T extends ExpertiseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExpertiseCreateArgs<ExtArgs>>
    ): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Expertise.
     * @param {ExpertiseCreateManyArgs} args - Arguments to create many Expertise.
     * @example
     * // Create many Expertise
     * const expertise = await prisma.expertise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ExpertiseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpertiseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expertise and returns the data saved in the database.
     * @param {ExpertiseCreateManyAndReturnArgs} args - Arguments to create many Expertise.
     * @example
     * // Create many Expertise
     * const expertise = await prisma.expertise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expertise and only return the `id`
     * const expertiseWithIdOnly = await prisma.expertise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ExpertiseCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpertiseCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Expertise.
     * @param {ExpertiseDeleteArgs} args - Arguments to delete one Expertise.
     * @example
     * // Delete one Expertise
     * const Expertise = await prisma.expertise.delete({
     *   where: {
     *     // ... filter to delete one Expertise
     *   }
     * })
     * 
    **/
    delete<T extends ExpertiseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExpertiseDeleteArgs<ExtArgs>>
    ): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Expertise.
     * @param {ExpertiseUpdateArgs} args - Arguments to update one Expertise.
     * @example
     * // Update one Expertise
     * const expertise = await prisma.expertise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExpertiseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExpertiseUpdateArgs<ExtArgs>>
    ): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Expertise.
     * @param {ExpertiseDeleteManyArgs} args - Arguments to filter Expertise to delete.
     * @example
     * // Delete a few Expertise
     * const { count } = await prisma.expertise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExpertiseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpertiseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expertise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expertise
     * const expertise = await prisma.expertise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExpertiseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExpertiseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expertise.
     * @param {ExpertiseUpsertArgs} args - Arguments to update or create a Expertise.
     * @example
     * // Update or create a Expertise
     * const expertise = await prisma.expertise.upsert({
     *   create: {
     *     // ... data to create a Expertise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expertise we want to update
     *   }
     * })
    **/
    upsert<T extends ExpertiseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExpertiseUpsertArgs<ExtArgs>>
    ): Prisma__ExpertiseClient<$Result.GetResult<Prisma.$ExpertisePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Expertise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertiseCountArgs} args - Arguments to filter Expertise to count.
     * @example
     * // Count the number of Expertise
     * const count = await prisma.expertise.count({
     *   where: {
     *     // ... the filter for the Expertise we want to count
     *   }
     * })
    **/
    count<T extends ExpertiseCountArgs>(
      args?: Subset<T, ExpertiseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpertiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expertise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpertiseAggregateArgs>(args: Subset<T, ExpertiseAggregateArgs>): Prisma.PrismaPromise<GetExpertiseAggregateType<T>>

    /**
     * Group by Expertise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpertiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpertiseGroupByArgs['orderBy'] }
        : { orderBy?: ExpertiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpertiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpertiseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expertise model
   */
  readonly fields: ExpertiseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expertise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpertiseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    operations<T extends Expertise$operationsArgs<ExtArgs> = {}>(args?: Subset<T, Expertise$operationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, 'findMany'> | Null>;

    posts<T extends Expertise$postsArgs<ExtArgs> = {}>(args?: Subset<T, Expertise$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Expertise model
   */ 
  interface ExpertiseFieldRefs {
    readonly id: FieldRef<"Expertise", 'String'>
    readonly userId: FieldRef<"Expertise", 'String'>
    readonly name: FieldRef<"Expertise", 'String'>
    readonly description: FieldRef<"Expertise", 'String'>
    readonly code: FieldRef<"Expertise", 'String'>
    readonly createdAt: FieldRef<"Expertise", 'DateTime'>
    readonly updatedAt: FieldRef<"Expertise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expertise findUnique
   */
  export type ExpertiseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * Filter, which Expertise to fetch.
     */
    where: ExpertiseWhereUniqueInput
  }

  /**
   * Expertise findUniqueOrThrow
   */
  export type ExpertiseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * Filter, which Expertise to fetch.
     */
    where: ExpertiseWhereUniqueInput
  }

  /**
   * Expertise findFirst
   */
  export type ExpertiseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * Filter, which Expertise to fetch.
     */
    where?: ExpertiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expertise to fetch.
     */
    orderBy?: ExpertiseOrderByWithRelationInput | ExpertiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expertise.
     */
    cursor?: ExpertiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expertise from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expertise.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expertise.
     */
    distinct?: ExpertiseScalarFieldEnum | ExpertiseScalarFieldEnum[]
  }

  /**
   * Expertise findFirstOrThrow
   */
  export type ExpertiseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * Filter, which Expertise to fetch.
     */
    where?: ExpertiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expertise to fetch.
     */
    orderBy?: ExpertiseOrderByWithRelationInput | ExpertiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expertise.
     */
    cursor?: ExpertiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expertise from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expertise.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expertise.
     */
    distinct?: ExpertiseScalarFieldEnum | ExpertiseScalarFieldEnum[]
  }

  /**
   * Expertise findMany
   */
  export type ExpertiseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * Filter, which Expertise to fetch.
     */
    where?: ExpertiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expertise to fetch.
     */
    orderBy?: ExpertiseOrderByWithRelationInput | ExpertiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expertise.
     */
    cursor?: ExpertiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expertise from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expertise.
     */
    skip?: number
    distinct?: ExpertiseScalarFieldEnum | ExpertiseScalarFieldEnum[]
  }

  /**
   * Expertise create
   */
  export type ExpertiseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expertise.
     */
    data: XOR<ExpertiseCreateInput, ExpertiseUncheckedCreateInput>
  }

  /**
   * Expertise createMany
   */
  export type ExpertiseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expertise.
     */
    data: ExpertiseCreateManyInput | ExpertiseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expertise createManyAndReturn
   */
  export type ExpertiseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expertise.
     */
    data: ExpertiseCreateManyInput | ExpertiseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expertise update
   */
  export type ExpertiseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expertise.
     */
    data: XOR<ExpertiseUpdateInput, ExpertiseUncheckedUpdateInput>
    /**
     * Choose, which Expertise to update.
     */
    where: ExpertiseWhereUniqueInput
  }

  /**
   * Expertise updateMany
   */
  export type ExpertiseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expertise.
     */
    data: XOR<ExpertiseUpdateManyMutationInput, ExpertiseUncheckedUpdateManyInput>
    /**
     * Filter which Expertise to update
     */
    where?: ExpertiseWhereInput
  }

  /**
   * Expertise upsert
   */
  export type ExpertiseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expertise to update in case it exists.
     */
    where: ExpertiseWhereUniqueInput
    /**
     * In case the Expertise found by the `where` argument doesn't exist, create a new Expertise with this data.
     */
    create: XOR<ExpertiseCreateInput, ExpertiseUncheckedCreateInput>
    /**
     * In case the Expertise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpertiseUpdateInput, ExpertiseUncheckedUpdateInput>
  }

  /**
   * Expertise delete
   */
  export type ExpertiseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
    /**
     * Filter which Expertise to delete.
     */
    where: ExpertiseWhereUniqueInput
  }

  /**
   * Expertise deleteMany
   */
  export type ExpertiseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expertise to delete
     */
    where?: ExpertiseWhereInput
  }

  /**
   * Expertise.operations
   */
  export type Expertise$operationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    where?: OperationWhereInput
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    cursor?: OperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * Expertise.posts
   */
  export type Expertise$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Expertise without action
   */
  export type ExpertiseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expertise
     */
    select?: ExpertiseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertiseInclude<ExtArgs> | null
  }


  /**
   * Model History
   */

  export type AggregateHistory = {
    _count: HistoryCountAggregateOutputType | null
    _min: HistoryMinAggregateOutputType | null
    _max: HistoryMaxAggregateOutputType | null
  }

  export type HistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: $Enums.ActionType | null
    entity: $Enums.EntityType | null
    entityId: string | null
    details: string | null
    createdAt: Date | null
  }

  export type HistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: $Enums.ActionType | null
    entity: $Enums.EntityType | null
    entityId: string | null
    details: string | null
    createdAt: Date | null
  }

  export type HistoryCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    details: number
    createdAt: number
    _all: number
  }


  export type HistoryMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    createdAt?: true
  }

  export type HistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    createdAt?: true
  }

  export type HistoryCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type HistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which History to aggregate.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Histories
    **/
    _count?: true | HistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoryMaxAggregateInputType
  }

  export type GetHistoryAggregateType<T extends HistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistory[P]>
      : GetScalarType<T[P], AggregateHistory[P]>
  }




  export type HistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoryWhereInput
    orderBy?: HistoryOrderByWithAggregationInput | HistoryOrderByWithAggregationInput[]
    by: HistoryScalarFieldEnum[] | HistoryScalarFieldEnum
    having?: HistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoryCountAggregateInputType | true
    _min?: HistoryMinAggregateInputType
    _max?: HistoryMaxAggregateInputType
  }

  export type HistoryGroupByOutputType = {
    id: string
    userId: string
    action: $Enums.ActionType
    entity: $Enums.EntityType | null
    entityId: string
    details: string
    createdAt: Date
    _count: HistoryCountAggregateOutputType | null
    _min: HistoryMinAggregateOutputType | null
    _max: HistoryMaxAggregateOutputType | null
  }

  type GetHistoryGroupByPayload<T extends HistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoryGroupByOutputType[P]>
            : GetScalarType<T[P], HistoryGroupByOutputType[P]>
        }
      >
    >


  export type HistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["history"]>

  export type HistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["history"]>

  export type HistorySelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type HistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "History"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: $Enums.ActionType
      entity: $Enums.EntityType | null
      entityId: string
      details: string
      createdAt: Date
    }, ExtArgs["result"]["history"]>
    composites: {}
  }

  type HistoryGetPayload<S extends boolean | null | undefined | HistoryDefaultArgs> = $Result.GetResult<Prisma.$HistoryPayload, S>

  type HistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistoryCountAggregateInputType | true
    }

  export interface HistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['History'], meta: { name: 'History' } }
    /**
     * Find zero or one History that matches the filter.
     * @param {HistoryFindUniqueArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one History that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HistoryFindUniqueOrThrowArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first History that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindFirstArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HistoryFindFirstArgs<ExtArgs>>
    ): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first History that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindFirstOrThrowArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Histories
     * const histories = await prisma.history.findMany()
     * 
     * // Get first 10 Histories
     * const histories = await prisma.history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historyWithIdOnly = await prisma.history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a History.
     * @param {HistoryCreateArgs} args - Arguments to create a History.
     * @example
     * // Create one History
     * const History = await prisma.history.create({
     *   data: {
     *     // ... data to create a History
     *   }
     * })
     * 
    **/
    create<T extends HistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HistoryCreateArgs<ExtArgs>>
    ): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Histories.
     * @param {HistoryCreateManyArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const history = await prisma.history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends HistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Histories and returns the data saved in the database.
     * @param {HistoryCreateManyAndReturnArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const history = await prisma.history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Histories and only return the `id`
     * const historyWithIdOnly = await prisma.history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends HistoryCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, HistoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a History.
     * @param {HistoryDeleteArgs} args - Arguments to delete one History.
     * @example
     * // Delete one History
     * const History = await prisma.history.delete({
     *   where: {
     *     // ... filter to delete one History
     *   }
     * })
     * 
    **/
    delete<T extends HistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HistoryDeleteArgs<ExtArgs>>
    ): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one History.
     * @param {HistoryUpdateArgs} args - Arguments to update one History.
     * @example
     * // Update one History
     * const history = await prisma.history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HistoryUpdateArgs<ExtArgs>>
    ): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Histories.
     * @param {HistoryDeleteManyArgs} args - Arguments to filter Histories to delete.
     * @example
     * // Delete a few Histories
     * const { count } = await prisma.history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Histories
     * const history = await prisma.history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one History.
     * @param {HistoryUpsertArgs} args - Arguments to update or create a History.
     * @example
     * // Update or create a History
     * const history = await prisma.history.upsert({
     *   create: {
     *     // ... data to create a History
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the History we want to update
     *   }
     * })
    **/
    upsert<T extends HistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HistoryUpsertArgs<ExtArgs>>
    ): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryCountArgs} args - Arguments to filter Histories to count.
     * @example
     * // Count the number of Histories
     * const count = await prisma.history.count({
     *   where: {
     *     // ... the filter for the Histories we want to count
     *   }
     * })
    **/
    count<T extends HistoryCountArgs>(
      args?: Subset<T, HistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a History.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoryAggregateArgs>(args: Subset<T, HistoryAggregateArgs>): Prisma.PrismaPromise<GetHistoryAggregateType<T>>

    /**
     * Group by History.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoryGroupByArgs['orderBy'] }
        : { orderBy?: HistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the History model
   */
  readonly fields: HistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for History.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the History model
   */ 
  interface HistoryFieldRefs {
    readonly id: FieldRef<"History", 'String'>
    readonly userId: FieldRef<"History", 'String'>
    readonly action: FieldRef<"History", 'ActionType'>
    readonly entity: FieldRef<"History", 'EntityType'>
    readonly entityId: FieldRef<"History", 'String'>
    readonly details: FieldRef<"History", 'String'>
    readonly createdAt: FieldRef<"History", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * History findUnique
   */
  export type HistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History findUniqueOrThrow
   */
  export type HistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History findFirst
   */
  export type HistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Histories.
     */
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History findFirstOrThrow
   */
  export type HistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Histories.
     */
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History findMany
   */
  export type HistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which Histories to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History create
   */
  export type HistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a History.
     */
    data: XOR<HistoryCreateInput, HistoryUncheckedCreateInput>
  }

  /**
   * History createMany
   */
  export type HistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Histories.
     */
    data: HistoryCreateManyInput | HistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * History createManyAndReturn
   */
  export type HistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Histories.
     */
    data: HistoryCreateManyInput | HistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * History update
   */
  export type HistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a History.
     */
    data: XOR<HistoryUpdateInput, HistoryUncheckedUpdateInput>
    /**
     * Choose, which History to update.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History updateMany
   */
  export type HistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Histories.
     */
    data: XOR<HistoryUpdateManyMutationInput, HistoryUncheckedUpdateManyInput>
    /**
     * Filter which Histories to update
     */
    where?: HistoryWhereInput
  }

  /**
   * History upsert
   */
  export type HistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the History to update in case it exists.
     */
    where: HistoryWhereUniqueInput
    /**
     * In case the History found by the `where` argument doesn't exist, create a new History with this data.
     */
    create: XOR<HistoryCreateInput, HistoryUncheckedCreateInput>
    /**
     * In case the History was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoryUpdateInput, HistoryUncheckedUpdateInput>
  }

  /**
   * History delete
   */
  export type HistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter which History to delete.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History deleteMany
   */
  export type HistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Histories to delete
     */
    where?: HistoryWhereInput
  }

  /**
   * History without action
   */
  export type HistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    count: number | null
  }

  export type DeviceSumAggregateOutputType = {
    count: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    planningId: string | null
    postId: string | null
    count: number | null
    createdAt: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    planningId: string | null
    postId: string | null
    count: number | null
    createdAt: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    deviceId: number
    planningId: number
    postId: number
    count: number
    createdAt: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    count?: true
  }

  export type DeviceSumAggregateInputType = {
    count?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    deviceId?: true
    planningId?: true
    postId?: true
    count?: true
    createdAt?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    deviceId?: true
    planningId?: true
    postId?: true
    count?: true
    createdAt?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    deviceId?: true
    planningId?: true
    postId?: true
    count?: true
    createdAt?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    deviceId: string
    planningId: string | null
    postId: string | null
    count: number | null
    createdAt: Date
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    planningId?: boolean
    postId?: boolean
    count?: boolean
    createdAt?: boolean
    planning?: boolean | Device$planningArgs<ExtArgs>
    post?: boolean | Device$postArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    planningId?: boolean
    postId?: boolean
    count?: boolean
    createdAt?: boolean
    planning?: boolean | Device$planningArgs<ExtArgs>
    post?: boolean | Device$postArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    deviceId?: boolean
    planningId?: boolean
    postId?: boolean
    count?: boolean
    createdAt?: boolean
  }

  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planning?: boolean | Device$planningArgs<ExtArgs>
    post?: boolean | Device$postArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planning?: boolean | Device$planningArgs<ExtArgs>
    post?: boolean | Device$postArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      planning: Prisma.$PlanningPayload<ExtArgs> | null
      post: Prisma.$PostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      planningId: string | null
      postId: string | null
      count: number | null
      createdAt: Date
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>
    ): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>
    ): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeviceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
    **/
    create<T extends DeviceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>
    ): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DeviceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
    **/
    delete<T extends DeviceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>
    ): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>
    ): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>
    ): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    planning<T extends Device$planningArgs<ExtArgs> = {}>(args?: Subset<T, Device$planningArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    post<T extends Device$postArgs<ExtArgs> = {}>(args?: Subset<T, Device$postArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Device model
   */ 
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly deviceId: FieldRef<"Device", 'String'>
    readonly planningId: FieldRef<"Device", 'String'>
    readonly postId: FieldRef<"Device", 'String'>
    readonly count: FieldRef<"Device", 'Int'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
  }

  /**
   * Device.planning
   */
  export type Device$planningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    where?: PlanningWhereInput
  }

  /**
   * Device.post
   */
  export type Device$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model OperationRecord
   */

  export type AggregateOperationRecord = {
    _count: OperationRecordCountAggregateOutputType | null
    _avg: OperationRecordAvgAggregateOutputType | null
    _sum: OperationRecordSumAggregateOutputType | null
    _min: OperationRecordMinAggregateOutputType | null
    _max: OperationRecordMaxAggregateOutputType | null
  }

  export type OperationRecordAvgAggregateOutputType = {
    count: number | null
  }

  export type OperationRecordSumAggregateOutputType = {
    count: number | null
  }

  export type OperationRecordMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    count: number | null
    createdAt: Date | null
  }

  export type OperationRecordMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    count: number | null
    createdAt: Date | null
  }

  export type OperationRecordCountAggregateOutputType = {
    id: number
    deviceId: number
    count: number
    createdAt: number
    _all: number
  }


  export type OperationRecordAvgAggregateInputType = {
    count?: true
  }

  export type OperationRecordSumAggregateInputType = {
    count?: true
  }

  export type OperationRecordMinAggregateInputType = {
    id?: true
    deviceId?: true
    count?: true
    createdAt?: true
  }

  export type OperationRecordMaxAggregateInputType = {
    id?: true
    deviceId?: true
    count?: true
    createdAt?: true
  }

  export type OperationRecordCountAggregateInputType = {
    id?: true
    deviceId?: true
    count?: true
    createdAt?: true
    _all?: true
  }

  export type OperationRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationRecord to aggregate.
     */
    where?: OperationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationRecords to fetch.
     */
    orderBy?: OperationRecordOrderByWithRelationInput | OperationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationRecords
    **/
    _count?: true | OperationRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationRecordMaxAggregateInputType
  }

  export type GetOperationRecordAggregateType<T extends OperationRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationRecord[P]>
      : GetScalarType<T[P], AggregateOperationRecord[P]>
  }




  export type OperationRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationRecordWhereInput
    orderBy?: OperationRecordOrderByWithAggregationInput | OperationRecordOrderByWithAggregationInput[]
    by: OperationRecordScalarFieldEnum[] | OperationRecordScalarFieldEnum
    having?: OperationRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationRecordCountAggregateInputType | true
    _avg?: OperationRecordAvgAggregateInputType
    _sum?: OperationRecordSumAggregateInputType
    _min?: OperationRecordMinAggregateInputType
    _max?: OperationRecordMaxAggregateInputType
  }

  export type OperationRecordGroupByOutputType = {
    id: string
    deviceId: string
    count: number | null
    createdAt: Date
    _count: OperationRecordCountAggregateOutputType | null
    _avg: OperationRecordAvgAggregateOutputType | null
    _sum: OperationRecordSumAggregateOutputType | null
    _min: OperationRecordMinAggregateOutputType | null
    _max: OperationRecordMaxAggregateOutputType | null
  }

  type GetOperationRecordGroupByPayload<T extends OperationRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationRecordGroupByOutputType[P]>
            : GetScalarType<T[P], OperationRecordGroupByOutputType[P]>
        }
      >
    >


  export type OperationRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    count?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["operationRecord"]>

  export type OperationRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    count?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["operationRecord"]>

  export type OperationRecordSelectScalar = {
    id?: boolean
    deviceId?: boolean
    count?: boolean
    createdAt?: boolean
  }


  export type $OperationRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      count: number | null
      createdAt: Date
    }, ExtArgs["result"]["operationRecord"]>
    composites: {}
  }

  type OperationRecordGetPayload<S extends boolean | null | undefined | OperationRecordDefaultArgs> = $Result.GetResult<Prisma.$OperationRecordPayload, S>

  type OperationRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationRecordCountAggregateInputType | true
    }

  export interface OperationRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationRecord'], meta: { name: 'OperationRecord' } }
    /**
     * Find zero or one OperationRecord that matches the filter.
     * @param {OperationRecordFindUniqueArgs} args - Arguments to find a OperationRecord
     * @example
     * // Get one OperationRecord
     * const operationRecord = await prisma.operationRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OperationRecordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OperationRecordFindUniqueArgs<ExtArgs>>
    ): Prisma__OperationRecordClient<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OperationRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationRecordFindUniqueOrThrowArgs} args - Arguments to find a OperationRecord
     * @example
     * // Get one OperationRecord
     * const operationRecord = await prisma.operationRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OperationRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OperationRecordClient<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OperationRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationRecordFindFirstArgs} args - Arguments to find a OperationRecord
     * @example
     * // Get one OperationRecord
     * const operationRecord = await prisma.operationRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OperationRecordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationRecordFindFirstArgs<ExtArgs>>
    ): Prisma__OperationRecordClient<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OperationRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationRecordFindFirstOrThrowArgs} args - Arguments to find a OperationRecord
     * @example
     * // Get one OperationRecord
     * const operationRecord = await prisma.operationRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OperationRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OperationRecordClient<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OperationRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationRecords
     * const operationRecords = await prisma.operationRecord.findMany()
     * 
     * // Get first 10 OperationRecords
     * const operationRecords = await prisma.operationRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationRecordWithIdOnly = await prisma.operationRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OperationRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OperationRecord.
     * @param {OperationRecordCreateArgs} args - Arguments to create a OperationRecord.
     * @example
     * // Create one OperationRecord
     * const OperationRecord = await prisma.operationRecord.create({
     *   data: {
     *     // ... data to create a OperationRecord
     *   }
     * })
     * 
    **/
    create<T extends OperationRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OperationRecordCreateArgs<ExtArgs>>
    ): Prisma__OperationRecordClient<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OperationRecords.
     * @param {OperationRecordCreateManyArgs} args - Arguments to create many OperationRecords.
     * @example
     * // Create many OperationRecords
     * const operationRecord = await prisma.operationRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends OperationRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperationRecords and returns the data saved in the database.
     * @param {OperationRecordCreateManyAndReturnArgs} args - Arguments to create many OperationRecords.
     * @example
     * // Create many OperationRecords
     * const operationRecord = await prisma.operationRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperationRecords and only return the `id`
     * const operationRecordWithIdOnly = await prisma.operationRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends OperationRecordCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationRecordCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a OperationRecord.
     * @param {OperationRecordDeleteArgs} args - Arguments to delete one OperationRecord.
     * @example
     * // Delete one OperationRecord
     * const OperationRecord = await prisma.operationRecord.delete({
     *   where: {
     *     // ... filter to delete one OperationRecord
     *   }
     * })
     * 
    **/
    delete<T extends OperationRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OperationRecordDeleteArgs<ExtArgs>>
    ): Prisma__OperationRecordClient<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OperationRecord.
     * @param {OperationRecordUpdateArgs} args - Arguments to update one OperationRecord.
     * @example
     * // Update one OperationRecord
     * const operationRecord = await prisma.operationRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OperationRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OperationRecordUpdateArgs<ExtArgs>>
    ): Prisma__OperationRecordClient<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OperationRecords.
     * @param {OperationRecordDeleteManyArgs} args - Arguments to filter OperationRecords to delete.
     * @example
     * // Delete a few OperationRecords
     * const { count } = await prisma.operationRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OperationRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OperationRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationRecords
     * const operationRecord = await prisma.operationRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OperationRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OperationRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationRecord.
     * @param {OperationRecordUpsertArgs} args - Arguments to update or create a OperationRecord.
     * @example
     * // Update or create a OperationRecord
     * const operationRecord = await prisma.operationRecord.upsert({
     *   create: {
     *     // ... data to create a OperationRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationRecord we want to update
     *   }
     * })
    **/
    upsert<T extends OperationRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OperationRecordUpsertArgs<ExtArgs>>
    ): Prisma__OperationRecordClient<$Result.GetResult<Prisma.$OperationRecordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OperationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationRecordCountArgs} args - Arguments to filter OperationRecords to count.
     * @example
     * // Count the number of OperationRecords
     * const count = await prisma.operationRecord.count({
     *   where: {
     *     // ... the filter for the OperationRecords we want to count
     *   }
     * })
    **/
    count<T extends OperationRecordCountArgs>(
      args?: Subset<T, OperationRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationRecordAggregateArgs>(args: Subset<T, OperationRecordAggregateArgs>): Prisma.PrismaPromise<GetOperationRecordAggregateType<T>>

    /**
     * Group by OperationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationRecordGroupByArgs['orderBy'] }
        : { orderBy?: OperationRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationRecord model
   */
  readonly fields: OperationRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OperationRecord model
   */ 
  interface OperationRecordFieldRefs {
    readonly id: FieldRef<"OperationRecord", 'String'>
    readonly deviceId: FieldRef<"OperationRecord", 'String'>
    readonly count: FieldRef<"OperationRecord", 'Int'>
    readonly createdAt: FieldRef<"OperationRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperationRecord findUnique
   */
  export type OperationRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * Filter, which OperationRecord to fetch.
     */
    where: OperationRecordWhereUniqueInput
  }

  /**
   * OperationRecord findUniqueOrThrow
   */
  export type OperationRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * Filter, which OperationRecord to fetch.
     */
    where: OperationRecordWhereUniqueInput
  }

  /**
   * OperationRecord findFirst
   */
  export type OperationRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * Filter, which OperationRecord to fetch.
     */
    where?: OperationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationRecords to fetch.
     */
    orderBy?: OperationRecordOrderByWithRelationInput | OperationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationRecords.
     */
    cursor?: OperationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationRecords.
     */
    distinct?: OperationRecordScalarFieldEnum | OperationRecordScalarFieldEnum[]
  }

  /**
   * OperationRecord findFirstOrThrow
   */
  export type OperationRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * Filter, which OperationRecord to fetch.
     */
    where?: OperationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationRecords to fetch.
     */
    orderBy?: OperationRecordOrderByWithRelationInput | OperationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationRecords.
     */
    cursor?: OperationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationRecords.
     */
    distinct?: OperationRecordScalarFieldEnum | OperationRecordScalarFieldEnum[]
  }

  /**
   * OperationRecord findMany
   */
  export type OperationRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * Filter, which OperationRecords to fetch.
     */
    where?: OperationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationRecords to fetch.
     */
    orderBy?: OperationRecordOrderByWithRelationInput | OperationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationRecords.
     */
    cursor?: OperationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationRecords.
     */
    skip?: number
    distinct?: OperationRecordScalarFieldEnum | OperationRecordScalarFieldEnum[]
  }

  /**
   * OperationRecord create
   */
  export type OperationRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * The data needed to create a OperationRecord.
     */
    data: XOR<OperationRecordCreateInput, OperationRecordUncheckedCreateInput>
  }

  /**
   * OperationRecord createMany
   */
  export type OperationRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationRecords.
     */
    data: OperationRecordCreateManyInput | OperationRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationRecord createManyAndReturn
   */
  export type OperationRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OperationRecords.
     */
    data: OperationRecordCreateManyInput | OperationRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationRecord update
   */
  export type OperationRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * The data needed to update a OperationRecord.
     */
    data: XOR<OperationRecordUpdateInput, OperationRecordUncheckedUpdateInput>
    /**
     * Choose, which OperationRecord to update.
     */
    where: OperationRecordWhereUniqueInput
  }

  /**
   * OperationRecord updateMany
   */
  export type OperationRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationRecords.
     */
    data: XOR<OperationRecordUpdateManyMutationInput, OperationRecordUncheckedUpdateManyInput>
    /**
     * Filter which OperationRecords to update
     */
    where?: OperationRecordWhereInput
  }

  /**
   * OperationRecord upsert
   */
  export type OperationRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * The filter to search for the OperationRecord to update in case it exists.
     */
    where: OperationRecordWhereUniqueInput
    /**
     * In case the OperationRecord found by the `where` argument doesn't exist, create a new OperationRecord with this data.
     */
    create: XOR<OperationRecordCreateInput, OperationRecordUncheckedCreateInput>
    /**
     * In case the OperationRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationRecordUpdateInput, OperationRecordUncheckedUpdateInput>
  }

  /**
   * OperationRecord delete
   */
  export type OperationRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
    /**
     * Filter which OperationRecord to delete.
     */
    where: OperationRecordWhereUniqueInput
  }

  /**
   * OperationRecord deleteMany
   */
  export type OperationRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationRecords to delete
     */
    where?: OperationRecordWhereInput
  }

  /**
   * OperationRecord without action
   */
  export type OperationRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationRecord
     */
    select?: OperationRecordSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    password: 'password',
    image: 'image',
    phone: 'phone',
    attributes: 'attributes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    workFlowId: 'workFlowId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const CommandScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommandScalarFieldEnum = (typeof CommandScalarFieldEnum)[keyof typeof CommandScalarFieldEnum]


  export const CommandProjectScalarFieldEnum: {
    id: 'id',
    commandId: 'commandId',
    projectId: 'projectId',
    target: 'target',
    done: 'done',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommandProjectScalarFieldEnum = (typeof CommandProjectScalarFieldEnum)[keyof typeof CommandProjectScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    operationId: 'operationId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PlanningScalarFieldEnum: {
    id: 'id',
    operatorId: 'operatorId',
    postId: 'postId',
    operationId: 'operationId',
    commandProjectId: 'commandProjectId',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanningScalarFieldEnum = (typeof PlanningScalarFieldEnum)[keyof typeof PlanningScalarFieldEnum]


  export const SprintScalarFieldEnum: {
    id: 'id',
    target: 'target',
    days: 'days',
    status: 'status',
    commandProjectId: 'commandProjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SprintScalarFieldEnum = (typeof SprintScalarFieldEnum)[keyof typeof SprintScalarFieldEnum]


  export const OperationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    icon: 'icon',
    description: 'description',
    isFinal: 'isFinal',
    estimatedTime: 'estimatedTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expertiseId: 'expertiseId'
  };

  export type OperationScalarFieldEnum = (typeof OperationScalarFieldEnum)[keyof typeof OperationScalarFieldEnum]


  export const WorkFlowNodeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workFlowId: 'workFlowId',
    operationId: 'operationId',
    data: 'data'
  };

  export type WorkFlowNodeScalarFieldEnum = (typeof WorkFlowNodeScalarFieldEnum)[keyof typeof WorkFlowNodeScalarFieldEnum]


  export const WorkFlowEdgeScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    targetId: 'targetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workFlowId: 'workFlowId',
    data: 'data',
    count: 'count'
  };

  export type WorkFlowEdgeScalarFieldEnum = (typeof WorkFlowEdgeScalarFieldEnum)[keyof typeof WorkFlowEdgeScalarFieldEnum]


  export const WorkFlowScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkFlowScalarFieldEnum = (typeof WorkFlowScalarFieldEnum)[keyof typeof WorkFlowScalarFieldEnum]


  export const OperationHistoryScalarFieldEnum: {
    id: 'id',
    planningId: 'planningId',
    count: 'count',
    createdAt: 'createdAt'
  };

  export type OperationHistoryScalarFieldEnum = (typeof OperationHistoryScalarFieldEnum)[keyof typeof OperationHistoryScalarFieldEnum]


  export const ExpertiseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    code: 'code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpertiseScalarFieldEnum = (typeof ExpertiseScalarFieldEnum)[keyof typeof ExpertiseScalarFieldEnum]


  export const HistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type HistoryScalarFieldEnum = (typeof HistoryScalarFieldEnum)[keyof typeof HistoryScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    planningId: 'planningId',
    postId: 'postId',
    count: 'count',
    createdAt: 'createdAt'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const OperationRecordScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    count: 'count',
    createdAt: 'createdAt'
  };

  export type OperationRecordScalarFieldEnum = (typeof OperationRecordScalarFieldEnum)[keyof typeof OperationRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'ActionType[]'
   */
  export type ListEnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType[]'>
    


  /**
   * Reference to a field of type 'EntityType'
   */
  export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


  /**
   * Reference to a field of type 'EntityType[]'
   */
  export type ListEnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    password?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    attributes?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    commands?: CommandListRelationFilter
    expertises?: ExpertiseListRelationFilter
    histories?: HistoryListRelationFilter
    plannings?: PlanningListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    password?: SortOrder
    image?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    attributes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commands?: CommandOrderByRelationAggregateInput
    expertises?: ExpertiseOrderByRelationAggregateInput
    histories?: HistoryOrderByRelationAggregateInput
    plannings?: PlanningOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    password?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    attributes?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    commands?: CommandListRelationFilter
    expertises?: ExpertiseListRelationFilter
    histories?: HistoryListRelationFilter
    plannings?: PlanningListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    password?: SortOrder
    image?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    attributes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    password?: StringWithAggregatesFilter<"User"> | string
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    attributes?: JsonWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: BoolFilter<"Project"> | boolean
    workFlowId?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    commandProjects?: CommandProjectListRelationFilter
    workFlow?: XOR<WorkFlowNullableRelationFilter, WorkFlowWhereInput> | null
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    workFlowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandProjects?: CommandProjectOrderByRelationAggregateInput
    workFlow?: WorkFlowOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workFlowId?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    commandProjects?: CommandProjectListRelationFilter
    workFlow?: XOR<WorkFlowNullableRelationFilter, WorkFlowWhereInput> | null
  }, "id" | "workFlowId">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    workFlowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: BoolWithAggregatesFilter<"Project"> | boolean
    workFlowId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type CommandWhereInput = {
    AND?: CommandWhereInput | CommandWhereInput[]
    OR?: CommandWhereInput[]
    NOT?: CommandWhereInput | CommandWhereInput[]
    id?: StringFilter<"Command"> | string
    reference?: StringFilter<"Command"> | string
    clientId?: StringNullableFilter<"Command"> | string | null
    createdAt?: DateTimeFilter<"Command"> | Date | string
    updatedAt?: DateTimeFilter<"Command"> | Date | string
    commandProjects?: CommandProjectListRelationFilter
    client?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CommandOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandProjects?: CommandProjectOrderByRelationAggregateInput
    client?: UserOrderByWithRelationInput
  }

  export type CommandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: CommandWhereInput | CommandWhereInput[]
    OR?: CommandWhereInput[]
    NOT?: CommandWhereInput | CommandWhereInput[]
    clientId?: StringNullableFilter<"Command"> | string | null
    createdAt?: DateTimeFilter<"Command"> | Date | string
    updatedAt?: DateTimeFilter<"Command"> | Date | string
    commandProjects?: CommandProjectListRelationFilter
    client?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "reference">

  export type CommandOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommandCountOrderByAggregateInput
    _max?: CommandMaxOrderByAggregateInput
    _min?: CommandMinOrderByAggregateInput
  }

  export type CommandScalarWhereWithAggregatesInput = {
    AND?: CommandScalarWhereWithAggregatesInput | CommandScalarWhereWithAggregatesInput[]
    OR?: CommandScalarWhereWithAggregatesInput[]
    NOT?: CommandScalarWhereWithAggregatesInput | CommandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Command"> | string
    reference?: StringWithAggregatesFilter<"Command"> | string
    clientId?: StringNullableWithAggregatesFilter<"Command"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Command"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Command"> | Date | string
  }

  export type CommandProjectWhereInput = {
    AND?: CommandProjectWhereInput | CommandProjectWhereInput[]
    OR?: CommandProjectWhereInput[]
    NOT?: CommandProjectWhereInput | CommandProjectWhereInput[]
    id?: StringFilter<"CommandProject"> | string
    commandId?: StringFilter<"CommandProject"> | string
    projectId?: StringFilter<"CommandProject"> | string
    target?: IntFilter<"CommandProject"> | number
    done?: IntFilter<"CommandProject"> | number
    startDate?: DateTimeNullableFilter<"CommandProject"> | Date | string | null
    endDate?: DateTimeFilter<"CommandProject"> | Date | string
    status?: EnumStatusFilter<"CommandProject"> | $Enums.Status
    createdAt?: DateTimeFilter<"CommandProject"> | Date | string
    updatedAt?: DateTimeFilter<"CommandProject"> | Date | string
    command?: XOR<CommandRelationFilter, CommandWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    planings?: PlanningListRelationFilter
    sprint?: XOR<SprintNullableRelationFilter, SprintWhereInput> | null
  }

  export type CommandProjectOrderByWithRelationInput = {
    id?: SortOrder
    commandId?: SortOrder
    projectId?: SortOrder
    target?: SortOrder
    done?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    command?: CommandOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    planings?: PlanningOrderByRelationAggregateInput
    sprint?: SprintOrderByWithRelationInput
  }

  export type CommandProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    commandId_projectId?: CommandProjectCommandIdProjectIdCompoundUniqueInput
    AND?: CommandProjectWhereInput | CommandProjectWhereInput[]
    OR?: CommandProjectWhereInput[]
    NOT?: CommandProjectWhereInput | CommandProjectWhereInput[]
    commandId?: StringFilter<"CommandProject"> | string
    projectId?: StringFilter<"CommandProject"> | string
    target?: IntFilter<"CommandProject"> | number
    done?: IntFilter<"CommandProject"> | number
    startDate?: DateTimeNullableFilter<"CommandProject"> | Date | string | null
    endDate?: DateTimeFilter<"CommandProject"> | Date | string
    status?: EnumStatusFilter<"CommandProject"> | $Enums.Status
    createdAt?: DateTimeFilter<"CommandProject"> | Date | string
    updatedAt?: DateTimeFilter<"CommandProject"> | Date | string
    command?: XOR<CommandRelationFilter, CommandWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    planings?: PlanningListRelationFilter
    sprint?: XOR<SprintNullableRelationFilter, SprintWhereInput> | null
  }, "id" | "commandId_projectId">

  export type CommandProjectOrderByWithAggregationInput = {
    id?: SortOrder
    commandId?: SortOrder
    projectId?: SortOrder
    target?: SortOrder
    done?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommandProjectCountOrderByAggregateInput
    _avg?: CommandProjectAvgOrderByAggregateInput
    _max?: CommandProjectMaxOrderByAggregateInput
    _min?: CommandProjectMinOrderByAggregateInput
    _sum?: CommandProjectSumOrderByAggregateInput
  }

  export type CommandProjectScalarWhereWithAggregatesInput = {
    AND?: CommandProjectScalarWhereWithAggregatesInput | CommandProjectScalarWhereWithAggregatesInput[]
    OR?: CommandProjectScalarWhereWithAggregatesInput[]
    NOT?: CommandProjectScalarWhereWithAggregatesInput | CommandProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommandProject"> | string
    commandId?: StringWithAggregatesFilter<"CommandProject"> | string
    projectId?: StringWithAggregatesFilter<"CommandProject"> | string
    target?: IntWithAggregatesFilter<"CommandProject"> | number
    done?: IntWithAggregatesFilter<"CommandProject"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"CommandProject"> | Date | string | null
    endDate?: DateTimeWithAggregatesFilter<"CommandProject"> | Date | string
    status?: EnumStatusWithAggregatesFilter<"CommandProject"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"CommandProject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommandProject"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    operationId?: StringNullableFilter<"Post"> | string | null
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    plannings?: PlanningListRelationFilter
    Operation?: XOR<OperationNullableRelationFilter, OperationWhereInput> | null
    expertises?: ExpertiseListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operationId?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
    plannings?: PlanningOrderByRelationAggregateInput
    Operation?: OperationOrderByWithRelationInput
    expertises?: ExpertiseOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    operationId?: StringNullableFilter<"Post"> | string | null
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    plannings?: PlanningListRelationFilter
    Operation?: XOR<OperationNullableRelationFilter, OperationWhereInput> | null
    expertises?: ExpertiseListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operationId?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    name?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    operationId?: StringNullableWithAggregatesFilter<"Post"> | string | null
  }

  export type PlanningWhereInput = {
    AND?: PlanningWhereInput | PlanningWhereInput[]
    OR?: PlanningWhereInput[]
    NOT?: PlanningWhereInput | PlanningWhereInput[]
    id?: StringFilter<"Planning"> | string
    operatorId?: StringFilter<"Planning"> | string
    postId?: StringFilter<"Planning"> | string
    operationId?: StringFilter<"Planning"> | string
    commandProjectId?: StringFilter<"Planning"> | string
    startDate?: DateTimeFilter<"Planning"> | Date | string
    endDate?: DateTimeFilter<"Planning"> | Date | string
    createdAt?: DateTimeFilter<"Planning"> | Date | string
    updatedAt?: DateTimeFilter<"Planning"> | Date | string
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    operationHistory?: OperationHistoryListRelationFilter
    commandProject?: XOR<CommandProjectRelationFilter, CommandProjectWhereInput>
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
    operator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PlanningOrderByWithRelationInput = {
    id?: SortOrder
    operatorId?: SortOrder
    postId?: SortOrder
    operationId?: SortOrder
    commandProjectId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    device?: DeviceOrderByWithRelationInput
    operationHistory?: OperationHistoryOrderByRelationAggregateInput
    commandProject?: CommandProjectOrderByWithRelationInput
    operation?: OperationOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    operator?: UserOrderByWithRelationInput
  }

  export type PlanningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanningWhereInput | PlanningWhereInput[]
    OR?: PlanningWhereInput[]
    NOT?: PlanningWhereInput | PlanningWhereInput[]
    operatorId?: StringFilter<"Planning"> | string
    postId?: StringFilter<"Planning"> | string
    operationId?: StringFilter<"Planning"> | string
    commandProjectId?: StringFilter<"Planning"> | string
    startDate?: DateTimeFilter<"Planning"> | Date | string
    endDate?: DateTimeFilter<"Planning"> | Date | string
    createdAt?: DateTimeFilter<"Planning"> | Date | string
    updatedAt?: DateTimeFilter<"Planning"> | Date | string
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    operationHistory?: OperationHistoryListRelationFilter
    commandProject?: XOR<CommandProjectRelationFilter, CommandProjectWhereInput>
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
    operator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PlanningOrderByWithAggregationInput = {
    id?: SortOrder
    operatorId?: SortOrder
    postId?: SortOrder
    operationId?: SortOrder
    commandProjectId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanningCountOrderByAggregateInput
    _max?: PlanningMaxOrderByAggregateInput
    _min?: PlanningMinOrderByAggregateInput
  }

  export type PlanningScalarWhereWithAggregatesInput = {
    AND?: PlanningScalarWhereWithAggregatesInput | PlanningScalarWhereWithAggregatesInput[]
    OR?: PlanningScalarWhereWithAggregatesInput[]
    NOT?: PlanningScalarWhereWithAggregatesInput | PlanningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Planning"> | string
    operatorId?: StringWithAggregatesFilter<"Planning"> | string
    postId?: StringWithAggregatesFilter<"Planning"> | string
    operationId?: StringWithAggregatesFilter<"Planning"> | string
    commandProjectId?: StringWithAggregatesFilter<"Planning"> | string
    startDate?: DateTimeWithAggregatesFilter<"Planning"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Planning"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Planning"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Planning"> | Date | string
  }

  export type SprintWhereInput = {
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    id?: StringFilter<"Sprint"> | string
    target?: IntFilter<"Sprint"> | number
    days?: IntFilter<"Sprint"> | number
    status?: EnumStatusFilter<"Sprint"> | $Enums.Status
    commandProjectId?: StringFilter<"Sprint"> | string
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    commandProject?: XOR<CommandProjectRelationFilter, CommandProjectWhereInput>
  }

  export type SprintOrderByWithRelationInput = {
    id?: SortOrder
    target?: SortOrder
    days?: SortOrder
    status?: SortOrder
    commandProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandProject?: CommandProjectOrderByWithRelationInput
  }

  export type SprintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    commandProjectId?: string
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    target?: IntFilter<"Sprint"> | number
    days?: IntFilter<"Sprint"> | number
    status?: EnumStatusFilter<"Sprint"> | $Enums.Status
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    commandProject?: XOR<CommandProjectRelationFilter, CommandProjectWhereInput>
  }, "id" | "commandProjectId">

  export type SprintOrderByWithAggregationInput = {
    id?: SortOrder
    target?: SortOrder
    days?: SortOrder
    status?: SortOrder
    commandProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SprintCountOrderByAggregateInput
    _avg?: SprintAvgOrderByAggregateInput
    _max?: SprintMaxOrderByAggregateInput
    _min?: SprintMinOrderByAggregateInput
    _sum?: SprintSumOrderByAggregateInput
  }

  export type SprintScalarWhereWithAggregatesInput = {
    AND?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    OR?: SprintScalarWhereWithAggregatesInput[]
    NOT?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sprint"> | string
    target?: IntWithAggregatesFilter<"Sprint"> | number
    days?: IntWithAggregatesFilter<"Sprint"> | number
    status?: EnumStatusWithAggregatesFilter<"Sprint"> | $Enums.Status
    commandProjectId?: StringWithAggregatesFilter<"Sprint"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
  }

  export type OperationWhereInput = {
    AND?: OperationWhereInput | OperationWhereInput[]
    OR?: OperationWhereInput[]
    NOT?: OperationWhereInput | OperationWhereInput[]
    id?: StringFilter<"Operation"> | string
    name?: StringFilter<"Operation"> | string
    code?: StringFilter<"Operation"> | string
    icon?: StringFilter<"Operation"> | string
    description?: StringNullableFilter<"Operation"> | string | null
    isFinal?: BoolFilter<"Operation"> | boolean
    estimatedTime?: IntFilter<"Operation"> | number
    createdAt?: DateTimeFilter<"Operation"> | Date | string
    updatedAt?: DateTimeFilter<"Operation"> | Date | string
    expertiseId?: StringNullableFilter<"Operation"> | string | null
    Expertise?: XOR<ExpertiseNullableRelationFilter, ExpertiseWhereInput> | null
    plannings?: PlanningListRelationFilter
    posts?: PostListRelationFilter
    WorkflowNode?: WorkFlowNodeListRelationFilter
  }

  export type OperationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    isFinal?: SortOrder
    estimatedTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expertiseId?: SortOrderInput | SortOrder
    Expertise?: ExpertiseOrderByWithRelationInput
    plannings?: PlanningOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    WorkflowNode?: WorkFlowNodeOrderByRelationAggregateInput
  }

  export type OperationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: OperationWhereInput | OperationWhereInput[]
    OR?: OperationWhereInput[]
    NOT?: OperationWhereInput | OperationWhereInput[]
    name?: StringFilter<"Operation"> | string
    icon?: StringFilter<"Operation"> | string
    description?: StringNullableFilter<"Operation"> | string | null
    isFinal?: BoolFilter<"Operation"> | boolean
    estimatedTime?: IntFilter<"Operation"> | number
    createdAt?: DateTimeFilter<"Operation"> | Date | string
    updatedAt?: DateTimeFilter<"Operation"> | Date | string
    expertiseId?: StringNullableFilter<"Operation"> | string | null
    Expertise?: XOR<ExpertiseNullableRelationFilter, ExpertiseWhereInput> | null
    plannings?: PlanningListRelationFilter
    posts?: PostListRelationFilter
    WorkflowNode?: WorkFlowNodeListRelationFilter
  }, "id" | "code">

  export type OperationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    isFinal?: SortOrder
    estimatedTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expertiseId?: SortOrderInput | SortOrder
    _count?: OperationCountOrderByAggregateInput
    _avg?: OperationAvgOrderByAggregateInput
    _max?: OperationMaxOrderByAggregateInput
    _min?: OperationMinOrderByAggregateInput
    _sum?: OperationSumOrderByAggregateInput
  }

  export type OperationScalarWhereWithAggregatesInput = {
    AND?: OperationScalarWhereWithAggregatesInput | OperationScalarWhereWithAggregatesInput[]
    OR?: OperationScalarWhereWithAggregatesInput[]
    NOT?: OperationScalarWhereWithAggregatesInput | OperationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Operation"> | string
    name?: StringWithAggregatesFilter<"Operation"> | string
    code?: StringWithAggregatesFilter<"Operation"> | string
    icon?: StringWithAggregatesFilter<"Operation"> | string
    description?: StringNullableWithAggregatesFilter<"Operation"> | string | null
    isFinal?: BoolWithAggregatesFilter<"Operation"> | boolean
    estimatedTime?: IntWithAggregatesFilter<"Operation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Operation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Operation"> | Date | string
    expertiseId?: StringNullableWithAggregatesFilter<"Operation"> | string | null
  }

  export type WorkFlowNodeWhereInput = {
    AND?: WorkFlowNodeWhereInput | WorkFlowNodeWhereInput[]
    OR?: WorkFlowNodeWhereInput[]
    NOT?: WorkFlowNodeWhereInput | WorkFlowNodeWhereInput[]
    id?: StringFilter<"WorkFlowNode"> | string
    createdAt?: DateTimeFilter<"WorkFlowNode"> | Date | string
    updatedAt?: DateTimeFilter<"WorkFlowNode"> | Date | string
    workFlowId?: StringFilter<"WorkFlowNode"> | string
    operationId?: StringFilter<"WorkFlowNode"> | string
    data?: JsonFilter<"WorkFlowNode">
    targetEdges?: WorkFlowEdgeListRelationFilter
    sourceEdges?: WorkFlowEdgeListRelationFilter
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    WorkFlow?: XOR<WorkFlowRelationFilter, WorkFlowWhereInput>
  }

  export type WorkFlowNodeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    operationId?: SortOrder
    data?: SortOrder
    targetEdges?: WorkFlowEdgeOrderByRelationAggregateInput
    sourceEdges?: WorkFlowEdgeOrderByRelationAggregateInput
    operation?: OperationOrderByWithRelationInput
    WorkFlow?: WorkFlowOrderByWithRelationInput
  }

  export type WorkFlowNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkFlowNodeWhereInput | WorkFlowNodeWhereInput[]
    OR?: WorkFlowNodeWhereInput[]
    NOT?: WorkFlowNodeWhereInput | WorkFlowNodeWhereInput[]
    createdAt?: DateTimeFilter<"WorkFlowNode"> | Date | string
    updatedAt?: DateTimeFilter<"WorkFlowNode"> | Date | string
    workFlowId?: StringFilter<"WorkFlowNode"> | string
    operationId?: StringFilter<"WorkFlowNode"> | string
    data?: JsonFilter<"WorkFlowNode">
    targetEdges?: WorkFlowEdgeListRelationFilter
    sourceEdges?: WorkFlowEdgeListRelationFilter
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    WorkFlow?: XOR<WorkFlowRelationFilter, WorkFlowWhereInput>
  }, "id">

  export type WorkFlowNodeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    operationId?: SortOrder
    data?: SortOrder
    _count?: WorkFlowNodeCountOrderByAggregateInput
    _max?: WorkFlowNodeMaxOrderByAggregateInput
    _min?: WorkFlowNodeMinOrderByAggregateInput
  }

  export type WorkFlowNodeScalarWhereWithAggregatesInput = {
    AND?: WorkFlowNodeScalarWhereWithAggregatesInput | WorkFlowNodeScalarWhereWithAggregatesInput[]
    OR?: WorkFlowNodeScalarWhereWithAggregatesInput[]
    NOT?: WorkFlowNodeScalarWhereWithAggregatesInput | WorkFlowNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkFlowNode"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkFlowNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkFlowNode"> | Date | string
    workFlowId?: StringWithAggregatesFilter<"WorkFlowNode"> | string
    operationId?: StringWithAggregatesFilter<"WorkFlowNode"> | string
    data?: JsonWithAggregatesFilter<"WorkFlowNode">
  }

  export type WorkFlowEdgeWhereInput = {
    AND?: WorkFlowEdgeWhereInput | WorkFlowEdgeWhereInput[]
    OR?: WorkFlowEdgeWhereInput[]
    NOT?: WorkFlowEdgeWhereInput | WorkFlowEdgeWhereInput[]
    id?: StringFilter<"WorkFlowEdge"> | string
    sourceId?: StringFilter<"WorkFlowEdge"> | string
    targetId?: StringFilter<"WorkFlowEdge"> | string
    createdAt?: DateTimeFilter<"WorkFlowEdge"> | Date | string
    updatedAt?: DateTimeFilter<"WorkFlowEdge"> | Date | string
    workFlowId?: StringFilter<"WorkFlowEdge"> | string
    data?: JsonFilter<"WorkFlowEdge">
    count?: IntFilter<"WorkFlowEdge"> | number
    source?: XOR<WorkFlowNodeRelationFilter, WorkFlowNodeWhereInput>
    target?: XOR<WorkFlowNodeRelationFilter, WorkFlowNodeWhereInput>
    WorkFlow?: XOR<WorkFlowRelationFilter, WorkFlowWhereInput>
  }

  export type WorkFlowEdgeOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    data?: SortOrder
    count?: SortOrder
    source?: WorkFlowNodeOrderByWithRelationInput
    target?: WorkFlowNodeOrderByWithRelationInput
    WorkFlow?: WorkFlowOrderByWithRelationInput
  }

  export type WorkFlowEdgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkFlowEdgeWhereInput | WorkFlowEdgeWhereInput[]
    OR?: WorkFlowEdgeWhereInput[]
    NOT?: WorkFlowEdgeWhereInput | WorkFlowEdgeWhereInput[]
    sourceId?: StringFilter<"WorkFlowEdge"> | string
    targetId?: StringFilter<"WorkFlowEdge"> | string
    createdAt?: DateTimeFilter<"WorkFlowEdge"> | Date | string
    updatedAt?: DateTimeFilter<"WorkFlowEdge"> | Date | string
    workFlowId?: StringFilter<"WorkFlowEdge"> | string
    data?: JsonFilter<"WorkFlowEdge">
    count?: IntFilter<"WorkFlowEdge"> | number
    source?: XOR<WorkFlowNodeRelationFilter, WorkFlowNodeWhereInput>
    target?: XOR<WorkFlowNodeRelationFilter, WorkFlowNodeWhereInput>
    WorkFlow?: XOR<WorkFlowRelationFilter, WorkFlowWhereInput>
  }, "id">

  export type WorkFlowEdgeOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    data?: SortOrder
    count?: SortOrder
    _count?: WorkFlowEdgeCountOrderByAggregateInput
    _avg?: WorkFlowEdgeAvgOrderByAggregateInput
    _max?: WorkFlowEdgeMaxOrderByAggregateInput
    _min?: WorkFlowEdgeMinOrderByAggregateInput
    _sum?: WorkFlowEdgeSumOrderByAggregateInput
  }

  export type WorkFlowEdgeScalarWhereWithAggregatesInput = {
    AND?: WorkFlowEdgeScalarWhereWithAggregatesInput | WorkFlowEdgeScalarWhereWithAggregatesInput[]
    OR?: WorkFlowEdgeScalarWhereWithAggregatesInput[]
    NOT?: WorkFlowEdgeScalarWhereWithAggregatesInput | WorkFlowEdgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkFlowEdge"> | string
    sourceId?: StringWithAggregatesFilter<"WorkFlowEdge"> | string
    targetId?: StringWithAggregatesFilter<"WorkFlowEdge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkFlowEdge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkFlowEdge"> | Date | string
    workFlowId?: StringWithAggregatesFilter<"WorkFlowEdge"> | string
    data?: JsonWithAggregatesFilter<"WorkFlowEdge">
    count?: IntWithAggregatesFilter<"WorkFlowEdge"> | number
  }

  export type WorkFlowWhereInput = {
    AND?: WorkFlowWhereInput | WorkFlowWhereInput[]
    OR?: WorkFlowWhereInput[]
    NOT?: WorkFlowWhereInput | WorkFlowWhereInput[]
    id?: StringFilter<"WorkFlow"> | string
    createdAt?: DateTimeFilter<"WorkFlow"> | Date | string
    updatedAt?: DateTimeFilter<"WorkFlow"> | Date | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    WorkFlowEdge?: WorkFlowEdgeListRelationFilter
    WorkflowNode?: WorkFlowNodeListRelationFilter
  }

  export type WorkFlowOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    WorkFlowEdge?: WorkFlowEdgeOrderByRelationAggregateInput
    WorkflowNode?: WorkFlowNodeOrderByRelationAggregateInput
  }

  export type WorkFlowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkFlowWhereInput | WorkFlowWhereInput[]
    OR?: WorkFlowWhereInput[]
    NOT?: WorkFlowWhereInput | WorkFlowWhereInput[]
    createdAt?: DateTimeFilter<"WorkFlow"> | Date | string
    updatedAt?: DateTimeFilter<"WorkFlow"> | Date | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    WorkFlowEdge?: WorkFlowEdgeListRelationFilter
    WorkflowNode?: WorkFlowNodeListRelationFilter
  }, "id">

  export type WorkFlowOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkFlowCountOrderByAggregateInput
    _max?: WorkFlowMaxOrderByAggregateInput
    _min?: WorkFlowMinOrderByAggregateInput
  }

  export type WorkFlowScalarWhereWithAggregatesInput = {
    AND?: WorkFlowScalarWhereWithAggregatesInput | WorkFlowScalarWhereWithAggregatesInput[]
    OR?: WorkFlowScalarWhereWithAggregatesInput[]
    NOT?: WorkFlowScalarWhereWithAggregatesInput | WorkFlowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkFlow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkFlow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkFlow"> | Date | string
  }

  export type OperationHistoryWhereInput = {
    AND?: OperationHistoryWhereInput | OperationHistoryWhereInput[]
    OR?: OperationHistoryWhereInput[]
    NOT?: OperationHistoryWhereInput | OperationHistoryWhereInput[]
    id?: StringFilter<"OperationHistory"> | string
    planningId?: StringFilter<"OperationHistory"> | string
    count?: IntFilter<"OperationHistory"> | number
    createdAt?: DateTimeFilter<"OperationHistory"> | Date | string
    planning?: XOR<PlanningRelationFilter, PlanningWhereInput>
  }

  export type OperationHistoryOrderByWithRelationInput = {
    id?: SortOrder
    planningId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    planning?: PlanningOrderByWithRelationInput
  }

  export type OperationHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperationHistoryWhereInput | OperationHistoryWhereInput[]
    OR?: OperationHistoryWhereInput[]
    NOT?: OperationHistoryWhereInput | OperationHistoryWhereInput[]
    planningId?: StringFilter<"OperationHistory"> | string
    count?: IntFilter<"OperationHistory"> | number
    createdAt?: DateTimeFilter<"OperationHistory"> | Date | string
    planning?: XOR<PlanningRelationFilter, PlanningWhereInput>
  }, "id">

  export type OperationHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    planningId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    _count?: OperationHistoryCountOrderByAggregateInput
    _avg?: OperationHistoryAvgOrderByAggregateInput
    _max?: OperationHistoryMaxOrderByAggregateInput
    _min?: OperationHistoryMinOrderByAggregateInput
    _sum?: OperationHistorySumOrderByAggregateInput
  }

  export type OperationHistoryScalarWhereWithAggregatesInput = {
    AND?: OperationHistoryScalarWhereWithAggregatesInput | OperationHistoryScalarWhereWithAggregatesInput[]
    OR?: OperationHistoryScalarWhereWithAggregatesInput[]
    NOT?: OperationHistoryScalarWhereWithAggregatesInput | OperationHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OperationHistory"> | string
    planningId?: StringWithAggregatesFilter<"OperationHistory"> | string
    count?: IntWithAggregatesFilter<"OperationHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OperationHistory"> | Date | string
  }

  export type ExpertiseWhereInput = {
    AND?: ExpertiseWhereInput | ExpertiseWhereInput[]
    OR?: ExpertiseWhereInput[]
    NOT?: ExpertiseWhereInput | ExpertiseWhereInput[]
    id?: StringFilter<"Expertise"> | string
    userId?: StringFilter<"Expertise"> | string
    name?: StringFilter<"Expertise"> | string
    description?: StringNullableFilter<"Expertise"> | string | null
    code?: StringFilter<"Expertise"> | string
    createdAt?: DateTimeFilter<"Expertise"> | Date | string
    updatedAt?: DateTimeFilter<"Expertise"> | Date | string
    users?: XOR<UserRelationFilter, UserWhereInput>
    operations?: OperationListRelationFilter
    posts?: PostListRelationFilter
  }

  export type ExpertiseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByWithRelationInput
    operations?: OperationOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type ExpertiseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ExpertiseWhereInput | ExpertiseWhereInput[]
    OR?: ExpertiseWhereInput[]
    NOT?: ExpertiseWhereInput | ExpertiseWhereInput[]
    userId?: StringFilter<"Expertise"> | string
    name?: StringFilter<"Expertise"> | string
    description?: StringNullableFilter<"Expertise"> | string | null
    createdAt?: DateTimeFilter<"Expertise"> | Date | string
    updatedAt?: DateTimeFilter<"Expertise"> | Date | string
    users?: XOR<UserRelationFilter, UserWhereInput>
    operations?: OperationListRelationFilter
    posts?: PostListRelationFilter
  }, "id" | "code">

  export type ExpertiseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpertiseCountOrderByAggregateInput
    _max?: ExpertiseMaxOrderByAggregateInput
    _min?: ExpertiseMinOrderByAggregateInput
  }

  export type ExpertiseScalarWhereWithAggregatesInput = {
    AND?: ExpertiseScalarWhereWithAggregatesInput | ExpertiseScalarWhereWithAggregatesInput[]
    OR?: ExpertiseScalarWhereWithAggregatesInput[]
    NOT?: ExpertiseScalarWhereWithAggregatesInput | ExpertiseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expertise"> | string
    userId?: StringWithAggregatesFilter<"Expertise"> | string
    name?: StringWithAggregatesFilter<"Expertise"> | string
    description?: StringNullableWithAggregatesFilter<"Expertise"> | string | null
    code?: StringWithAggregatesFilter<"Expertise"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Expertise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expertise"> | Date | string
  }

  export type HistoryWhereInput = {
    AND?: HistoryWhereInput | HistoryWhereInput[]
    OR?: HistoryWhereInput[]
    NOT?: HistoryWhereInput | HistoryWhereInput[]
    id?: StringFilter<"History"> | string
    userId?: StringFilter<"History"> | string
    action?: EnumActionTypeFilter<"History"> | $Enums.ActionType
    entity?: EnumEntityTypeNullableFilter<"History"> | $Enums.EntityType | null
    entityId?: StringFilter<"History"> | string
    details?: StringFilter<"History"> | string
    createdAt?: DateTimeFilter<"History"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrderInput | SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type HistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HistoryWhereInput | HistoryWhereInput[]
    OR?: HistoryWhereInput[]
    NOT?: HistoryWhereInput | HistoryWhereInput[]
    userId?: StringFilter<"History"> | string
    action?: EnumActionTypeFilter<"History"> | $Enums.ActionType
    entity?: EnumEntityTypeNullableFilter<"History"> | $Enums.EntityType | null
    entityId?: StringFilter<"History"> | string
    details?: StringFilter<"History"> | string
    createdAt?: DateTimeFilter<"History"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type HistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrderInput | SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    _count?: HistoryCountOrderByAggregateInput
    _max?: HistoryMaxOrderByAggregateInput
    _min?: HistoryMinOrderByAggregateInput
  }

  export type HistoryScalarWhereWithAggregatesInput = {
    AND?: HistoryScalarWhereWithAggregatesInput | HistoryScalarWhereWithAggregatesInput[]
    OR?: HistoryScalarWhereWithAggregatesInput[]
    NOT?: HistoryScalarWhereWithAggregatesInput | HistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"History"> | string
    userId?: StringWithAggregatesFilter<"History"> | string
    action?: EnumActionTypeWithAggregatesFilter<"History"> | $Enums.ActionType
    entity?: EnumEntityTypeNullableWithAggregatesFilter<"History"> | $Enums.EntityType | null
    entityId?: StringWithAggregatesFilter<"History"> | string
    details?: StringWithAggregatesFilter<"History"> | string
    createdAt?: DateTimeWithAggregatesFilter<"History"> | Date | string
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: StringFilter<"Device"> | string
    deviceId?: StringFilter<"Device"> | string
    planningId?: StringNullableFilter<"Device"> | string | null
    postId?: StringNullableFilter<"Device"> | string | null
    count?: IntNullableFilter<"Device"> | number | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    planning?: XOR<PlanningNullableRelationFilter, PlanningWhereInput> | null
    post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    planningId?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    planning?: PlanningOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceId?: string
    planningId?: string
    postId?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    count?: IntNullableFilter<"Device"> | number | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    planning?: XOR<PlanningNullableRelationFilter, PlanningWhereInput> | null
    post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
  }, "id" | "deviceId" | "planningId" | "postId">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    planningId?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Device"> | string
    deviceId?: StringWithAggregatesFilter<"Device"> | string
    planningId?: StringNullableWithAggregatesFilter<"Device"> | string | null
    postId?: StringNullableWithAggregatesFilter<"Device"> | string | null
    count?: IntNullableWithAggregatesFilter<"Device"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
  }

  export type OperationRecordWhereInput = {
    AND?: OperationRecordWhereInput | OperationRecordWhereInput[]
    OR?: OperationRecordWhereInput[]
    NOT?: OperationRecordWhereInput | OperationRecordWhereInput[]
    id?: StringFilter<"OperationRecord"> | string
    deviceId?: StringFilter<"OperationRecord"> | string
    count?: IntNullableFilter<"OperationRecord"> | number | null
    createdAt?: DateTimeFilter<"OperationRecord"> | Date | string
  }

  export type OperationRecordOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    count?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type OperationRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperationRecordWhereInput | OperationRecordWhereInput[]
    OR?: OperationRecordWhereInput[]
    NOT?: OperationRecordWhereInput | OperationRecordWhereInput[]
    deviceId?: StringFilter<"OperationRecord"> | string
    count?: IntNullableFilter<"OperationRecord"> | number | null
    createdAt?: DateTimeFilter<"OperationRecord"> | Date | string
  }, "id">

  export type OperationRecordOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    count?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OperationRecordCountOrderByAggregateInput
    _avg?: OperationRecordAvgOrderByAggregateInput
    _max?: OperationRecordMaxOrderByAggregateInput
    _min?: OperationRecordMinOrderByAggregateInput
    _sum?: OperationRecordSumOrderByAggregateInput
  }

  export type OperationRecordScalarWhereWithAggregatesInput = {
    AND?: OperationRecordScalarWhereWithAggregatesInput | OperationRecordScalarWhereWithAggregatesInput[]
    OR?: OperationRecordScalarWhereWithAggregatesInput[]
    NOT?: OperationRecordScalarWhereWithAggregatesInput | OperationRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OperationRecord"> | string
    deviceId?: StringWithAggregatesFilter<"OperationRecord"> | string
    count?: IntNullableWithAggregatesFilter<"OperationRecord"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"OperationRecord"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutClientInput
    expertises?: ExpertiseCreateNestedManyWithoutUsersInput
    histories?: HistoryCreateNestedManyWithoutUserInput
    plannings?: PlanningCreateNestedManyWithoutOperatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandUncheckedCreateNestedManyWithoutClientInput
    expertises?: ExpertiseUncheckedCreateNestedManyWithoutUsersInput
    histories?: HistoryUncheckedCreateNestedManyWithoutUserInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutClientNestedInput
    expertises?: ExpertiseUpdateManyWithoutUsersNestedInput
    histories?: HistoryUpdateManyWithoutUserNestedInput
    plannings?: PlanningUpdateManyWithoutOperatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUncheckedUpdateManyWithoutClientNestedInput
    expertises?: ExpertiseUncheckedUpdateManyWithoutUsersNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutUserNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProjects?: CommandProjectCreateNestedManyWithoutProjectInput
    workFlow?: WorkFlowCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: boolean
    workFlowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProjects?: CommandProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProjects?: CommandProjectUpdateManyWithoutProjectNestedInput
    workFlow?: WorkFlowUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    workFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProjects?: CommandProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: boolean
    workFlowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    workFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandCreateInput = {
    id?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProjects?: CommandProjectCreateNestedManyWithoutCommandInput
    client?: UserCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateInput = {
    id?: string
    reference: string
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProjects?: CommandProjectUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProjects?: CommandProjectUpdateManyWithoutCommandNestedInput
    client?: UserUpdateOneWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProjects?: CommandProjectUncheckedUpdateManyWithoutCommandNestedInput
  }

  export type CommandCreateManyInput = {
    id?: string
    reference: string
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandProjectCreateInput = {
    id?: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    command: CommandCreateNestedOneWithoutCommandProjectsInput
    project: ProjectCreateNestedOneWithoutCommandProjectsInput
    planings?: PlanningCreateNestedManyWithoutCommandProjectInput
    sprint?: SprintCreateNestedOneWithoutCommandProjectInput
  }

  export type CommandProjectUncheckedCreateInput = {
    id?: string
    commandId: string
    projectId: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    planings?: PlanningUncheckedCreateNestedManyWithoutCommandProjectInput
    sprint?: SprintUncheckedCreateNestedOneWithoutCommandProjectInput
  }

  export type CommandProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    command?: CommandUpdateOneRequiredWithoutCommandProjectsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCommandProjectsNestedInput
    planings?: PlanningUpdateManyWithoutCommandProjectNestedInput
    sprint?: SprintUpdateOneWithoutCommandProjectNestedInput
  }

  export type CommandProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planings?: PlanningUncheckedUpdateManyWithoutCommandProjectNestedInput
    sprint?: SprintUncheckedUpdateOneWithoutCommandProjectNestedInput
  }

  export type CommandProjectCreateManyInput = {
    id?: string
    commandId: string
    projectId: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPostInput
    plannings?: PlanningCreateNestedManyWithoutPostInput
    Operation?: OperationCreateNestedOneWithoutPostsInput
    expertises?: ExpertiseCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationId?: string | null
    device?: DeviceUncheckedCreateNestedOneWithoutPostInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutPostInput
    expertises?: ExpertiseUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPostNestedInput
    plannings?: PlanningUpdateManyWithoutPostNestedInput
    Operation?: OperationUpdateOneWithoutPostsNestedInput
    expertises?: ExpertiseUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUncheckedUpdateOneWithoutPostNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutPostNestedInput
    expertises?: ExpertiseUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationId?: string | null
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryCreateNestedManyWithoutPlanningInput
    commandProject: CommandProjectCreateNestedOneWithoutPlaningsInput
    operation: OperationCreateNestedOneWithoutPlanningsInput
    post: PostCreateNestedOneWithoutPlanningsInput
    operator: UserCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateInput = {
    id?: string
    operatorId: string
    postId: string
    operationId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceUncheckedCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUpdateManyWithoutPlanningNestedInput
    commandProject?: CommandProjectUpdateOneRequiredWithoutPlaningsNestedInput
    operation?: OperationUpdateOneRequiredWithoutPlanningsNestedInput
    post?: PostUpdateOneRequiredWithoutPlanningsNestedInput
    operator?: UserUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUncheckedUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type PlanningCreateManyInput = {
    id?: string
    operatorId: string
    postId: string
    operationId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintCreateInput = {
    id?: string
    target: number
    days: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProject: CommandProjectCreateNestedOneWithoutSprintInput
  }

  export type SprintUncheckedCreateInput = {
    id?: string
    target: number
    days: number
    status?: $Enums.Status
    commandProjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProject?: CommandProjectUpdateOneRequiredWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    commandProjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintCreateManyInput = {
    id?: string
    target: number
    days: number
    status?: $Enums.Status
    commandProjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    commandProjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationCreateInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Expertise?: ExpertiseCreateNestedOneWithoutOperationsInput
    plannings?: PlanningCreateNestedManyWithoutOperationInput
    posts?: PostCreateNestedManyWithoutOperationInput
    WorkflowNode?: WorkFlowNodeCreateNestedManyWithoutOperationInput
  }

  export type OperationUncheckedCreateInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expertiseId?: string | null
    plannings?: PlanningUncheckedCreateNestedManyWithoutOperationInput
    posts?: PostUncheckedCreateNestedManyWithoutOperationInput
    WorkflowNode?: WorkFlowNodeUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Expertise?: ExpertiseUpdateOneWithoutOperationsNestedInput
    plannings?: PlanningUpdateManyWithoutOperationNestedInput
    posts?: PostUpdateManyWithoutOperationNestedInput
    WorkflowNode?: WorkFlowNodeUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertiseId?: NullableStringFieldUpdateOperationsInput | string | null
    plannings?: PlanningUncheckedUpdateManyWithoutOperationNestedInput
    posts?: PostUncheckedUpdateManyWithoutOperationNestedInput
    WorkflowNode?: WorkFlowNodeUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type OperationCreateManyInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expertiseId?: string | null
  }

  export type OperationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertiseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkFlowNodeCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeCreateNestedManyWithoutSourceInput
    sourceEdges?: WorkFlowEdgeCreateNestedManyWithoutTargetInput
    operation: OperationCreateNestedOneWithoutWorkflowNodeInput
    WorkFlow: WorkFlowCreateNestedOneWithoutWorkflowNodeInput
  }

  export type WorkFlowNodeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    operationId: string
    data: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUncheckedCreateNestedManyWithoutSourceInput
    sourceEdges?: WorkFlowEdgeUncheckedCreateNestedManyWithoutTargetInput
  }

  export type WorkFlowNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUpdateManyWithoutSourceNestedInput
    sourceEdges?: WorkFlowEdgeUpdateManyWithoutTargetNestedInput
    operation?: OperationUpdateOneRequiredWithoutWorkflowNodeNestedInput
    WorkFlow?: WorkFlowUpdateOneRequiredWithoutWorkflowNodeNestedInput
  }

  export type WorkFlowNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUncheckedUpdateManyWithoutSourceNestedInput
    sourceEdges?: WorkFlowEdgeUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type WorkFlowNodeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    operationId: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type WorkFlowNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type WorkFlowNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type WorkFlowEdgeCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    count?: number
    source: WorkFlowNodeCreateNestedOneWithoutTargetEdgesInput
    target: WorkFlowNodeCreateNestedOneWithoutSourceEdgesInput
    WorkFlow: WorkFlowCreateNestedOneWithoutWorkFlowEdgeInput
  }

  export type WorkFlowEdgeUncheckedCreateInput = {
    id?: string
    sourceId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    data: JsonNullValueInput | InputJsonValue
    count?: number
  }

  export type WorkFlowEdgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    source?: WorkFlowNodeUpdateOneRequiredWithoutTargetEdgesNestedInput
    target?: WorkFlowNodeUpdateOneRequiredWithoutSourceEdgesNestedInput
    WorkFlow?: WorkFlowUpdateOneRequiredWithoutWorkFlowEdgeNestedInput
  }

  export type WorkFlowEdgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowEdgeCreateManyInput = {
    id?: string
    sourceId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    data: JsonNullValueInput | InputJsonValue
    count?: number
  }

  export type WorkFlowEdgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowEdgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutWorkFlowInput
    WorkFlowEdge?: WorkFlowEdgeCreateNestedManyWithoutWorkFlowInput
    WorkflowNode?: WorkFlowNodeCreateNestedManyWithoutWorkFlowInput
  }

  export type WorkFlowUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectUncheckedCreateNestedOneWithoutWorkFlowInput
    WorkFlowEdge?: WorkFlowEdgeUncheckedCreateNestedManyWithoutWorkFlowInput
    WorkflowNode?: WorkFlowNodeUncheckedCreateNestedManyWithoutWorkFlowInput
  }

  export type WorkFlowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutWorkFlowNestedInput
    WorkFlowEdge?: WorkFlowEdgeUpdateManyWithoutWorkFlowNestedInput
    WorkflowNode?: WorkFlowNodeUpdateManyWithoutWorkFlowNestedInput
  }

  export type WorkFlowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUncheckedUpdateOneWithoutWorkFlowNestedInput
    WorkFlowEdge?: WorkFlowEdgeUncheckedUpdateManyWithoutWorkFlowNestedInput
    WorkflowNode?: WorkFlowNodeUncheckedUpdateManyWithoutWorkFlowNestedInput
  }

  export type WorkFlowCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkFlowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkFlowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationHistoryCreateInput = {
    id?: string
    count: number
    createdAt?: Date | string
    planning: PlanningCreateNestedOneWithoutOperationHistoryInput
  }

  export type OperationHistoryUncheckedCreateInput = {
    id?: string
    planningId: string
    count: number
    createdAt?: Date | string
  }

  export type OperationHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planning?: PlanningUpdateOneRequiredWithoutOperationHistoryNestedInput
  }

  export type OperationHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningId?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationHistoryCreateManyInput = {
    id?: string
    planningId: string
    count: number
    createdAt?: Date | string
  }

  export type OperationHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningId?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertiseCreateInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UserCreateNestedOneWithoutExpertisesInput
    operations?: OperationCreateNestedManyWithoutExpertiseInput
    posts?: PostCreateNestedManyWithoutExpertisesInput
  }

  export type ExpertiseUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operations?: OperationUncheckedCreateNestedManyWithoutExpertiseInput
    posts?: PostUncheckedCreateNestedManyWithoutExpertisesInput
  }

  export type ExpertiseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutExpertisesNestedInput
    operations?: OperationUpdateManyWithoutExpertiseNestedInput
    posts?: PostUpdateManyWithoutExpertisesNestedInput
  }

  export type ExpertiseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operations?: OperationUncheckedUpdateManyWithoutExpertiseNestedInput
    posts?: PostUncheckedUpdateManyWithoutExpertisesNestedInput
  }

  export type ExpertiseCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpertiseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertiseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryCreateInput = {
    id?: string
    action: $Enums.ActionType
    entity?: $Enums.EntityType | null
    entityId: string
    details: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHistoriesInput
  }

  export type HistoryUncheckedCreateInput = {
    id?: string
    userId: string
    action: $Enums.ActionType
    entity?: $Enums.EntityType | null
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type HistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entity?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHistoriesNestedInput
  }

  export type HistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entity?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryCreateManyInput = {
    id?: string
    userId: string
    action: $Enums.ActionType
    entity?: $Enums.EntityType | null
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type HistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entity?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entity?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateInput = {
    id?: string
    deviceId: string
    count?: number | null
    createdAt?: Date | string
    planning?: PlanningCreateNestedOneWithoutDeviceInput
    post?: PostCreateNestedOneWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    deviceId: string
    planningId?: string | null
    postId?: string | null
    count?: number | null
    createdAt?: Date | string
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planning?: PlanningUpdateOneWithoutDeviceNestedInput
    post?: PostUpdateOneWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateManyInput = {
    id?: string
    deviceId: string
    planningId?: string | null
    postId?: string | null
    count?: number | null
    createdAt?: Date | string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationRecordCreateInput = {
    id?: string
    deviceId: string
    count?: number | null
    createdAt?: Date | string
  }

  export type OperationRecordUncheckedCreateInput = {
    id?: string
    deviceId: string
    count?: number | null
    createdAt?: Date | string
  }

  export type OperationRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationRecordCreateManyInput = {
    id?: string
    deviceId: string
    count?: number | null
    createdAt?: Date | string
  }

  export type OperationRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CommandListRelationFilter = {
    every?: CommandWhereInput
    some?: CommandWhereInput
    none?: CommandWhereInput
  }

  export type ExpertiseListRelationFilter = {
    every?: ExpertiseWhereInput
    some?: ExpertiseWhereInput
    none?: ExpertiseWhereInput
  }

  export type HistoryListRelationFilter = {
    every?: HistoryWhereInput
    some?: HistoryWhereInput
    none?: HistoryWhereInput
  }

  export type PlanningListRelationFilter = {
    every?: PlanningWhereInput
    some?: PlanningWhereInput
    none?: PlanningWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CommandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpertiseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    password?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    attributes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    password?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    password?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CommandProjectListRelationFilter = {
    every?: CommandProjectWhereInput
    some?: CommandProjectWhereInput
    none?: CommandProjectWhereInput
  }

  export type WorkFlowNullableRelationFilter = {
    is?: WorkFlowWhereInput | null
    isNot?: WorkFlowWhereInput | null
  }

  export type CommandProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workFlowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workFlowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workFlowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CommandCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type CommandRelationFilter = {
    is?: CommandWhereInput
    isNot?: CommandWhereInput
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type SprintNullableRelationFilter = {
    is?: SprintWhereInput | null
    isNot?: SprintWhereInput | null
  }

  export type CommandProjectCommandIdProjectIdCompoundUniqueInput = {
    commandId: string
    projectId: string
  }

  export type CommandProjectCountOrderByAggregateInput = {
    id?: SortOrder
    commandId?: SortOrder
    projectId?: SortOrder
    target?: SortOrder
    done?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandProjectAvgOrderByAggregateInput = {
    target?: SortOrder
    done?: SortOrder
  }

  export type CommandProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    commandId?: SortOrder
    projectId?: SortOrder
    target?: SortOrder
    done?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandProjectMinOrderByAggregateInput = {
    id?: SortOrder
    commandId?: SortOrder
    projectId?: SortOrder
    target?: SortOrder
    done?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandProjectSumOrderByAggregateInput = {
    target?: SortOrder
    done?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type DeviceNullableRelationFilter = {
    is?: DeviceWhereInput | null
    isNot?: DeviceWhereInput | null
  }

  export type OperationNullableRelationFilter = {
    is?: OperationWhereInput | null
    isNot?: OperationWhereInput | null
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operationId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operationId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operationId?: SortOrder
  }

  export type OperationHistoryListRelationFilter = {
    every?: OperationHistoryWhereInput
    some?: OperationHistoryWhereInput
    none?: OperationHistoryWhereInput
  }

  export type CommandProjectRelationFilter = {
    is?: CommandProjectWhereInput
    isNot?: CommandProjectWhereInput
  }

  export type OperationRelationFilter = {
    is?: OperationWhereInput
    isNot?: OperationWhereInput
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OperationHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanningCountOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    postId?: SortOrder
    operationId?: SortOrder
    commandProjectId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanningMaxOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    postId?: SortOrder
    operationId?: SortOrder
    commandProjectId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanningMinOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    postId?: SortOrder
    operationId?: SortOrder
    commandProjectId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintCountOrderByAggregateInput = {
    id?: SortOrder
    target?: SortOrder
    days?: SortOrder
    status?: SortOrder
    commandProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintAvgOrderByAggregateInput = {
    target?: SortOrder
    days?: SortOrder
  }

  export type SprintMaxOrderByAggregateInput = {
    id?: SortOrder
    target?: SortOrder
    days?: SortOrder
    status?: SortOrder
    commandProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintMinOrderByAggregateInput = {
    id?: SortOrder
    target?: SortOrder
    days?: SortOrder
    status?: SortOrder
    commandProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintSumOrderByAggregateInput = {
    target?: SortOrder
    days?: SortOrder
  }

  export type ExpertiseNullableRelationFilter = {
    is?: ExpertiseWhereInput | null
    isNot?: ExpertiseWhereInput | null
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type WorkFlowNodeListRelationFilter = {
    every?: WorkFlowNodeWhereInput
    some?: WorkFlowNodeWhereInput
    none?: WorkFlowNodeWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkFlowNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isFinal?: SortOrder
    estimatedTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expertiseId?: SortOrder
  }

  export type OperationAvgOrderByAggregateInput = {
    estimatedTime?: SortOrder
  }

  export type OperationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isFinal?: SortOrder
    estimatedTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expertiseId?: SortOrder
  }

  export type OperationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isFinal?: SortOrder
    estimatedTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expertiseId?: SortOrder
  }

  export type OperationSumOrderByAggregateInput = {
    estimatedTime?: SortOrder
  }

  export type WorkFlowEdgeListRelationFilter = {
    every?: WorkFlowEdgeWhereInput
    some?: WorkFlowEdgeWhereInput
    none?: WorkFlowEdgeWhereInput
  }

  export type WorkFlowRelationFilter = {
    is?: WorkFlowWhereInput
    isNot?: WorkFlowWhereInput
  }

  export type WorkFlowEdgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkFlowNodeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    operationId?: SortOrder
    data?: SortOrder
  }

  export type WorkFlowNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    operationId?: SortOrder
  }

  export type WorkFlowNodeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    operationId?: SortOrder
  }

  export type WorkFlowNodeRelationFilter = {
    is?: WorkFlowNodeWhereInput
    isNot?: WorkFlowNodeWhereInput
  }

  export type WorkFlowEdgeCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    data?: SortOrder
    count?: SortOrder
  }

  export type WorkFlowEdgeAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type WorkFlowEdgeMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    count?: SortOrder
  }

  export type WorkFlowEdgeMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workFlowId?: SortOrder
    count?: SortOrder
  }

  export type WorkFlowEdgeSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type WorkFlowCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkFlowMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkFlowMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanningRelationFilter = {
    is?: PlanningWhereInput
    isNot?: PlanningWhereInput
  }

  export type OperationHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    planningId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationHistoryAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type OperationHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    planningId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    planningId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationHistorySumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type OperationListRelationFilter = {
    every?: OperationWhereInput
    some?: OperationWhereInput
    none?: OperationWhereInput
  }

  export type OperationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpertiseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpertiseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpertiseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type EnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type HistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type HistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type HistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type EnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PlanningNullableRelationFilter = {
    is?: PlanningWhereInput | null
    isNot?: PlanningWhereInput | null
  }

  export type PostNullableRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    planningId?: SortOrder
    postId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    planningId?: SortOrder
    postId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    planningId?: SortOrder
    postId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OperationRecordCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationRecordAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type OperationRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationRecordMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationRecordSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type CommandCreateNestedManyWithoutClientInput = {
    create?: XOR<CommandCreateWithoutClientInput, CommandUncheckedCreateWithoutClientInput> | CommandCreateWithoutClientInput[] | CommandUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutClientInput | CommandCreateOrConnectWithoutClientInput[]
    createMany?: CommandCreateManyClientInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type ExpertiseCreateNestedManyWithoutUsersInput = {
    create?: XOR<ExpertiseCreateWithoutUsersInput, ExpertiseUncheckedCreateWithoutUsersInput> | ExpertiseCreateWithoutUsersInput[] | ExpertiseUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExpertiseCreateOrConnectWithoutUsersInput | ExpertiseCreateOrConnectWithoutUsersInput[]
    createMany?: ExpertiseCreateManyUsersInputEnvelope
    connect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
  }

  export type HistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput> | HistoryCreateWithoutUserInput[] | HistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutUserInput | HistoryCreateOrConnectWithoutUserInput[]
    createMany?: HistoryCreateManyUserInputEnvelope
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
  }

  export type PlanningCreateNestedManyWithoutOperatorInput = {
    create?: XOR<PlanningCreateWithoutOperatorInput, PlanningUncheckedCreateWithoutOperatorInput> | PlanningCreateWithoutOperatorInput[] | PlanningUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutOperatorInput | PlanningCreateOrConnectWithoutOperatorInput[]
    createMany?: PlanningCreateManyOperatorInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type CommandUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<CommandCreateWithoutClientInput, CommandUncheckedCreateWithoutClientInput> | CommandCreateWithoutClientInput[] | CommandUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutClientInput | CommandCreateOrConnectWithoutClientInput[]
    createMany?: CommandCreateManyClientInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type ExpertiseUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ExpertiseCreateWithoutUsersInput, ExpertiseUncheckedCreateWithoutUsersInput> | ExpertiseCreateWithoutUsersInput[] | ExpertiseUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExpertiseCreateOrConnectWithoutUsersInput | ExpertiseCreateOrConnectWithoutUsersInput[]
    createMany?: ExpertiseCreateManyUsersInputEnvelope
    connect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
  }

  export type HistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput> | HistoryCreateWithoutUserInput[] | HistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutUserInput | HistoryCreateOrConnectWithoutUserInput[]
    createMany?: HistoryCreateManyUserInputEnvelope
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
  }

  export type PlanningUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<PlanningCreateWithoutOperatorInput, PlanningUncheckedCreateWithoutOperatorInput> | PlanningCreateWithoutOperatorInput[] | PlanningUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutOperatorInput | PlanningCreateOrConnectWithoutOperatorInput[]
    createMany?: PlanningCreateManyOperatorInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CommandUpdateManyWithoutClientNestedInput = {
    create?: XOR<CommandCreateWithoutClientInput, CommandUncheckedCreateWithoutClientInput> | CommandCreateWithoutClientInput[] | CommandUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutClientInput | CommandCreateOrConnectWithoutClientInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutClientInput | CommandUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CommandCreateManyClientInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutClientInput | CommandUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutClientInput | CommandUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type ExpertiseUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ExpertiseCreateWithoutUsersInput, ExpertiseUncheckedCreateWithoutUsersInput> | ExpertiseCreateWithoutUsersInput[] | ExpertiseUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExpertiseCreateOrConnectWithoutUsersInput | ExpertiseCreateOrConnectWithoutUsersInput[]
    upsert?: ExpertiseUpsertWithWhereUniqueWithoutUsersInput | ExpertiseUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ExpertiseCreateManyUsersInputEnvelope
    set?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    disconnect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    delete?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    connect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    update?: ExpertiseUpdateWithWhereUniqueWithoutUsersInput | ExpertiseUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ExpertiseUpdateManyWithWhereWithoutUsersInput | ExpertiseUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ExpertiseScalarWhereInput | ExpertiseScalarWhereInput[]
  }

  export type HistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput> | HistoryCreateWithoutUserInput[] | HistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutUserInput | HistoryCreateOrConnectWithoutUserInput[]
    upsert?: HistoryUpsertWithWhereUniqueWithoutUserInput | HistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HistoryCreateManyUserInputEnvelope
    set?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    disconnect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    delete?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    update?: HistoryUpdateWithWhereUniqueWithoutUserInput | HistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HistoryUpdateManyWithWhereWithoutUserInput | HistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
  }

  export type PlanningUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<PlanningCreateWithoutOperatorInput, PlanningUncheckedCreateWithoutOperatorInput> | PlanningCreateWithoutOperatorInput[] | PlanningUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutOperatorInput | PlanningCreateOrConnectWithoutOperatorInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutOperatorInput | PlanningUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: PlanningCreateManyOperatorInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutOperatorInput | PlanningUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutOperatorInput | PlanningUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type CommandUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<CommandCreateWithoutClientInput, CommandUncheckedCreateWithoutClientInput> | CommandCreateWithoutClientInput[] | CommandUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutClientInput | CommandCreateOrConnectWithoutClientInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutClientInput | CommandUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CommandCreateManyClientInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutClientInput | CommandUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutClientInput | CommandUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type ExpertiseUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ExpertiseCreateWithoutUsersInput, ExpertiseUncheckedCreateWithoutUsersInput> | ExpertiseCreateWithoutUsersInput[] | ExpertiseUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExpertiseCreateOrConnectWithoutUsersInput | ExpertiseCreateOrConnectWithoutUsersInput[]
    upsert?: ExpertiseUpsertWithWhereUniqueWithoutUsersInput | ExpertiseUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ExpertiseCreateManyUsersInputEnvelope
    set?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    disconnect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    delete?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    connect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    update?: ExpertiseUpdateWithWhereUniqueWithoutUsersInput | ExpertiseUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ExpertiseUpdateManyWithWhereWithoutUsersInput | ExpertiseUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ExpertiseScalarWhereInput | ExpertiseScalarWhereInput[]
  }

  export type HistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput> | HistoryCreateWithoutUserInput[] | HistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutUserInput | HistoryCreateOrConnectWithoutUserInput[]
    upsert?: HistoryUpsertWithWhereUniqueWithoutUserInput | HistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HistoryCreateManyUserInputEnvelope
    set?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    disconnect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    delete?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    update?: HistoryUpdateWithWhereUniqueWithoutUserInput | HistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HistoryUpdateManyWithWhereWithoutUserInput | HistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
  }

  export type PlanningUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<PlanningCreateWithoutOperatorInput, PlanningUncheckedCreateWithoutOperatorInput> | PlanningCreateWithoutOperatorInput[] | PlanningUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutOperatorInput | PlanningCreateOrConnectWithoutOperatorInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutOperatorInput | PlanningUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: PlanningCreateManyOperatorInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutOperatorInput | PlanningUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutOperatorInput | PlanningUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type CommandProjectCreateNestedManyWithoutProjectInput = {
    create?: XOR<CommandProjectCreateWithoutProjectInput, CommandProjectUncheckedCreateWithoutProjectInput> | CommandProjectCreateWithoutProjectInput[] | CommandProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommandProjectCreateOrConnectWithoutProjectInput | CommandProjectCreateOrConnectWithoutProjectInput[]
    createMany?: CommandProjectCreateManyProjectInputEnvelope
    connect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
  }

  export type WorkFlowCreateNestedOneWithoutProjectInput = {
    create?: XOR<WorkFlowCreateWithoutProjectInput, WorkFlowUncheckedCreateWithoutProjectInput>
    connectOrCreate?: WorkFlowCreateOrConnectWithoutProjectInput
    connect?: WorkFlowWhereUniqueInput
  }

  export type CommandProjectUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CommandProjectCreateWithoutProjectInput, CommandProjectUncheckedCreateWithoutProjectInput> | CommandProjectCreateWithoutProjectInput[] | CommandProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommandProjectCreateOrConnectWithoutProjectInput | CommandProjectCreateOrConnectWithoutProjectInput[]
    createMany?: CommandProjectCreateManyProjectInputEnvelope
    connect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CommandProjectUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CommandProjectCreateWithoutProjectInput, CommandProjectUncheckedCreateWithoutProjectInput> | CommandProjectCreateWithoutProjectInput[] | CommandProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommandProjectCreateOrConnectWithoutProjectInput | CommandProjectCreateOrConnectWithoutProjectInput[]
    upsert?: CommandProjectUpsertWithWhereUniqueWithoutProjectInput | CommandProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CommandProjectCreateManyProjectInputEnvelope
    set?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    disconnect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    delete?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    connect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    update?: CommandProjectUpdateWithWhereUniqueWithoutProjectInput | CommandProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CommandProjectUpdateManyWithWhereWithoutProjectInput | CommandProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CommandProjectScalarWhereInput | CommandProjectScalarWhereInput[]
  }

  export type WorkFlowUpdateOneWithoutProjectNestedInput = {
    create?: XOR<WorkFlowCreateWithoutProjectInput, WorkFlowUncheckedCreateWithoutProjectInput>
    connectOrCreate?: WorkFlowCreateOrConnectWithoutProjectInput
    upsert?: WorkFlowUpsertWithoutProjectInput
    disconnect?: WorkFlowWhereInput | boolean
    delete?: WorkFlowWhereInput | boolean
    connect?: WorkFlowWhereUniqueInput
    update?: XOR<XOR<WorkFlowUpdateToOneWithWhereWithoutProjectInput, WorkFlowUpdateWithoutProjectInput>, WorkFlowUncheckedUpdateWithoutProjectInput>
  }

  export type CommandProjectUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CommandProjectCreateWithoutProjectInput, CommandProjectUncheckedCreateWithoutProjectInput> | CommandProjectCreateWithoutProjectInput[] | CommandProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommandProjectCreateOrConnectWithoutProjectInput | CommandProjectCreateOrConnectWithoutProjectInput[]
    upsert?: CommandProjectUpsertWithWhereUniqueWithoutProjectInput | CommandProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CommandProjectCreateManyProjectInputEnvelope
    set?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    disconnect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    delete?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    connect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    update?: CommandProjectUpdateWithWhereUniqueWithoutProjectInput | CommandProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CommandProjectUpdateManyWithWhereWithoutProjectInput | CommandProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CommandProjectScalarWhereInput | CommandProjectScalarWhereInput[]
  }

  export type CommandProjectCreateNestedManyWithoutCommandInput = {
    create?: XOR<CommandProjectCreateWithoutCommandInput, CommandProjectUncheckedCreateWithoutCommandInput> | CommandProjectCreateWithoutCommandInput[] | CommandProjectUncheckedCreateWithoutCommandInput[]
    connectOrCreate?: CommandProjectCreateOrConnectWithoutCommandInput | CommandProjectCreateOrConnectWithoutCommandInput[]
    createMany?: CommandProjectCreateManyCommandInputEnvelope
    connect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCommandsInput = {
    create?: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommandsInput
    connect?: UserWhereUniqueInput
  }

  export type CommandProjectUncheckedCreateNestedManyWithoutCommandInput = {
    create?: XOR<CommandProjectCreateWithoutCommandInput, CommandProjectUncheckedCreateWithoutCommandInput> | CommandProjectCreateWithoutCommandInput[] | CommandProjectUncheckedCreateWithoutCommandInput[]
    connectOrCreate?: CommandProjectCreateOrConnectWithoutCommandInput | CommandProjectCreateOrConnectWithoutCommandInput[]
    createMany?: CommandProjectCreateManyCommandInputEnvelope
    connect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
  }

  export type CommandProjectUpdateManyWithoutCommandNestedInput = {
    create?: XOR<CommandProjectCreateWithoutCommandInput, CommandProjectUncheckedCreateWithoutCommandInput> | CommandProjectCreateWithoutCommandInput[] | CommandProjectUncheckedCreateWithoutCommandInput[]
    connectOrCreate?: CommandProjectCreateOrConnectWithoutCommandInput | CommandProjectCreateOrConnectWithoutCommandInput[]
    upsert?: CommandProjectUpsertWithWhereUniqueWithoutCommandInput | CommandProjectUpsertWithWhereUniqueWithoutCommandInput[]
    createMany?: CommandProjectCreateManyCommandInputEnvelope
    set?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    disconnect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    delete?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    connect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    update?: CommandProjectUpdateWithWhereUniqueWithoutCommandInput | CommandProjectUpdateWithWhereUniqueWithoutCommandInput[]
    updateMany?: CommandProjectUpdateManyWithWhereWithoutCommandInput | CommandProjectUpdateManyWithWhereWithoutCommandInput[]
    deleteMany?: CommandProjectScalarWhereInput | CommandProjectScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCommandsNestedInput = {
    create?: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommandsInput
    upsert?: UserUpsertWithoutCommandsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommandsInput, UserUpdateWithoutCommandsInput>, UserUncheckedUpdateWithoutCommandsInput>
  }

  export type CommandProjectUncheckedUpdateManyWithoutCommandNestedInput = {
    create?: XOR<CommandProjectCreateWithoutCommandInput, CommandProjectUncheckedCreateWithoutCommandInput> | CommandProjectCreateWithoutCommandInput[] | CommandProjectUncheckedCreateWithoutCommandInput[]
    connectOrCreate?: CommandProjectCreateOrConnectWithoutCommandInput | CommandProjectCreateOrConnectWithoutCommandInput[]
    upsert?: CommandProjectUpsertWithWhereUniqueWithoutCommandInput | CommandProjectUpsertWithWhereUniqueWithoutCommandInput[]
    createMany?: CommandProjectCreateManyCommandInputEnvelope
    set?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    disconnect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    delete?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    connect?: CommandProjectWhereUniqueInput | CommandProjectWhereUniqueInput[]
    update?: CommandProjectUpdateWithWhereUniqueWithoutCommandInput | CommandProjectUpdateWithWhereUniqueWithoutCommandInput[]
    updateMany?: CommandProjectUpdateManyWithWhereWithoutCommandInput | CommandProjectUpdateManyWithWhereWithoutCommandInput[]
    deleteMany?: CommandProjectScalarWhereInput | CommandProjectScalarWhereInput[]
  }

  export type CommandCreateNestedOneWithoutCommandProjectsInput = {
    create?: XOR<CommandCreateWithoutCommandProjectsInput, CommandUncheckedCreateWithoutCommandProjectsInput>
    connectOrCreate?: CommandCreateOrConnectWithoutCommandProjectsInput
    connect?: CommandWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCommandProjectsInput = {
    create?: XOR<ProjectCreateWithoutCommandProjectsInput, ProjectUncheckedCreateWithoutCommandProjectsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommandProjectsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PlanningCreateNestedManyWithoutCommandProjectInput = {
    create?: XOR<PlanningCreateWithoutCommandProjectInput, PlanningUncheckedCreateWithoutCommandProjectInput> | PlanningCreateWithoutCommandProjectInput[] | PlanningUncheckedCreateWithoutCommandProjectInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutCommandProjectInput | PlanningCreateOrConnectWithoutCommandProjectInput[]
    createMany?: PlanningCreateManyCommandProjectInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type SprintCreateNestedOneWithoutCommandProjectInput = {
    create?: XOR<SprintCreateWithoutCommandProjectInput, SprintUncheckedCreateWithoutCommandProjectInput>
    connectOrCreate?: SprintCreateOrConnectWithoutCommandProjectInput
    connect?: SprintWhereUniqueInput
  }

  export type PlanningUncheckedCreateNestedManyWithoutCommandProjectInput = {
    create?: XOR<PlanningCreateWithoutCommandProjectInput, PlanningUncheckedCreateWithoutCommandProjectInput> | PlanningCreateWithoutCommandProjectInput[] | PlanningUncheckedCreateWithoutCommandProjectInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutCommandProjectInput | PlanningCreateOrConnectWithoutCommandProjectInput[]
    createMany?: PlanningCreateManyCommandProjectInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type SprintUncheckedCreateNestedOneWithoutCommandProjectInput = {
    create?: XOR<SprintCreateWithoutCommandProjectInput, SprintUncheckedCreateWithoutCommandProjectInput>
    connectOrCreate?: SprintCreateOrConnectWithoutCommandProjectInput
    connect?: SprintWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type CommandUpdateOneRequiredWithoutCommandProjectsNestedInput = {
    create?: XOR<CommandCreateWithoutCommandProjectsInput, CommandUncheckedCreateWithoutCommandProjectsInput>
    connectOrCreate?: CommandCreateOrConnectWithoutCommandProjectsInput
    upsert?: CommandUpsertWithoutCommandProjectsInput
    connect?: CommandWhereUniqueInput
    update?: XOR<XOR<CommandUpdateToOneWithWhereWithoutCommandProjectsInput, CommandUpdateWithoutCommandProjectsInput>, CommandUncheckedUpdateWithoutCommandProjectsInput>
  }

  export type ProjectUpdateOneRequiredWithoutCommandProjectsNestedInput = {
    create?: XOR<ProjectCreateWithoutCommandProjectsInput, ProjectUncheckedCreateWithoutCommandProjectsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommandProjectsInput
    upsert?: ProjectUpsertWithoutCommandProjectsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCommandProjectsInput, ProjectUpdateWithoutCommandProjectsInput>, ProjectUncheckedUpdateWithoutCommandProjectsInput>
  }

  export type PlanningUpdateManyWithoutCommandProjectNestedInput = {
    create?: XOR<PlanningCreateWithoutCommandProjectInput, PlanningUncheckedCreateWithoutCommandProjectInput> | PlanningCreateWithoutCommandProjectInput[] | PlanningUncheckedCreateWithoutCommandProjectInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutCommandProjectInput | PlanningCreateOrConnectWithoutCommandProjectInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutCommandProjectInput | PlanningUpsertWithWhereUniqueWithoutCommandProjectInput[]
    createMany?: PlanningCreateManyCommandProjectInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutCommandProjectInput | PlanningUpdateWithWhereUniqueWithoutCommandProjectInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutCommandProjectInput | PlanningUpdateManyWithWhereWithoutCommandProjectInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type SprintUpdateOneWithoutCommandProjectNestedInput = {
    create?: XOR<SprintCreateWithoutCommandProjectInput, SprintUncheckedCreateWithoutCommandProjectInput>
    connectOrCreate?: SprintCreateOrConnectWithoutCommandProjectInput
    upsert?: SprintUpsertWithoutCommandProjectInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutCommandProjectInput, SprintUpdateWithoutCommandProjectInput>, SprintUncheckedUpdateWithoutCommandProjectInput>
  }

  export type PlanningUncheckedUpdateManyWithoutCommandProjectNestedInput = {
    create?: XOR<PlanningCreateWithoutCommandProjectInput, PlanningUncheckedCreateWithoutCommandProjectInput> | PlanningCreateWithoutCommandProjectInput[] | PlanningUncheckedCreateWithoutCommandProjectInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutCommandProjectInput | PlanningCreateOrConnectWithoutCommandProjectInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutCommandProjectInput | PlanningUpsertWithWhereUniqueWithoutCommandProjectInput[]
    createMany?: PlanningCreateManyCommandProjectInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutCommandProjectInput | PlanningUpdateWithWhereUniqueWithoutCommandProjectInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutCommandProjectInput | PlanningUpdateManyWithWhereWithoutCommandProjectInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type SprintUncheckedUpdateOneWithoutCommandProjectNestedInput = {
    create?: XOR<SprintCreateWithoutCommandProjectInput, SprintUncheckedCreateWithoutCommandProjectInput>
    connectOrCreate?: SprintCreateOrConnectWithoutCommandProjectInput
    upsert?: SprintUpsertWithoutCommandProjectInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutCommandProjectInput, SprintUpdateWithoutCommandProjectInput>, SprintUncheckedUpdateWithoutCommandProjectInput>
  }

  export type DeviceCreateNestedOneWithoutPostInput = {
    create?: XOR<DeviceCreateWithoutPostInput, DeviceUncheckedCreateWithoutPostInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPostInput
    connect?: DeviceWhereUniqueInput
  }

  export type PlanningCreateNestedManyWithoutPostInput = {
    create?: XOR<PlanningCreateWithoutPostInput, PlanningUncheckedCreateWithoutPostInput> | PlanningCreateWithoutPostInput[] | PlanningUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutPostInput | PlanningCreateOrConnectWithoutPostInput[]
    createMany?: PlanningCreateManyPostInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type OperationCreateNestedOneWithoutPostsInput = {
    create?: XOR<OperationCreateWithoutPostsInput, OperationUncheckedCreateWithoutPostsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutPostsInput
    connect?: OperationWhereUniqueInput
  }

  export type ExpertiseCreateNestedManyWithoutPostsInput = {
    create?: XOR<ExpertiseCreateWithoutPostsInput, ExpertiseUncheckedCreateWithoutPostsInput> | ExpertiseCreateWithoutPostsInput[] | ExpertiseUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: ExpertiseCreateOrConnectWithoutPostsInput | ExpertiseCreateOrConnectWithoutPostsInput[]
    connect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedOneWithoutPostInput = {
    create?: XOR<DeviceCreateWithoutPostInput, DeviceUncheckedCreateWithoutPostInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPostInput
    connect?: DeviceWhereUniqueInput
  }

  export type PlanningUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PlanningCreateWithoutPostInput, PlanningUncheckedCreateWithoutPostInput> | PlanningCreateWithoutPostInput[] | PlanningUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutPostInput | PlanningCreateOrConnectWithoutPostInput[]
    createMany?: PlanningCreateManyPostInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type ExpertiseUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<ExpertiseCreateWithoutPostsInput, ExpertiseUncheckedCreateWithoutPostsInput> | ExpertiseCreateWithoutPostsInput[] | ExpertiseUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: ExpertiseCreateOrConnectWithoutPostsInput | ExpertiseCreateOrConnectWithoutPostsInput[]
    connect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
  }

  export type DeviceUpdateOneWithoutPostNestedInput = {
    create?: XOR<DeviceCreateWithoutPostInput, DeviceUncheckedCreateWithoutPostInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPostInput
    upsert?: DeviceUpsertWithoutPostInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutPostInput, DeviceUpdateWithoutPostInput>, DeviceUncheckedUpdateWithoutPostInput>
  }

  export type PlanningUpdateManyWithoutPostNestedInput = {
    create?: XOR<PlanningCreateWithoutPostInput, PlanningUncheckedCreateWithoutPostInput> | PlanningCreateWithoutPostInput[] | PlanningUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutPostInput | PlanningCreateOrConnectWithoutPostInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutPostInput | PlanningUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PlanningCreateManyPostInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutPostInput | PlanningUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutPostInput | PlanningUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type OperationUpdateOneWithoutPostsNestedInput = {
    create?: XOR<OperationCreateWithoutPostsInput, OperationUncheckedCreateWithoutPostsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutPostsInput
    upsert?: OperationUpsertWithoutPostsInput
    disconnect?: OperationWhereInput | boolean
    delete?: OperationWhereInput | boolean
    connect?: OperationWhereUniqueInput
    update?: XOR<XOR<OperationUpdateToOneWithWhereWithoutPostsInput, OperationUpdateWithoutPostsInput>, OperationUncheckedUpdateWithoutPostsInput>
  }

  export type ExpertiseUpdateManyWithoutPostsNestedInput = {
    create?: XOR<ExpertiseCreateWithoutPostsInput, ExpertiseUncheckedCreateWithoutPostsInput> | ExpertiseCreateWithoutPostsInput[] | ExpertiseUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: ExpertiseCreateOrConnectWithoutPostsInput | ExpertiseCreateOrConnectWithoutPostsInput[]
    upsert?: ExpertiseUpsertWithWhereUniqueWithoutPostsInput | ExpertiseUpsertWithWhereUniqueWithoutPostsInput[]
    set?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    disconnect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    delete?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    connect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    update?: ExpertiseUpdateWithWhereUniqueWithoutPostsInput | ExpertiseUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: ExpertiseUpdateManyWithWhereWithoutPostsInput | ExpertiseUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: ExpertiseScalarWhereInput | ExpertiseScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateOneWithoutPostNestedInput = {
    create?: XOR<DeviceCreateWithoutPostInput, DeviceUncheckedCreateWithoutPostInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPostInput
    upsert?: DeviceUpsertWithoutPostInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutPostInput, DeviceUpdateWithoutPostInput>, DeviceUncheckedUpdateWithoutPostInput>
  }

  export type PlanningUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PlanningCreateWithoutPostInput, PlanningUncheckedCreateWithoutPostInput> | PlanningCreateWithoutPostInput[] | PlanningUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutPostInput | PlanningCreateOrConnectWithoutPostInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutPostInput | PlanningUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PlanningCreateManyPostInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutPostInput | PlanningUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutPostInput | PlanningUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type ExpertiseUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<ExpertiseCreateWithoutPostsInput, ExpertiseUncheckedCreateWithoutPostsInput> | ExpertiseCreateWithoutPostsInput[] | ExpertiseUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: ExpertiseCreateOrConnectWithoutPostsInput | ExpertiseCreateOrConnectWithoutPostsInput[]
    upsert?: ExpertiseUpsertWithWhereUniqueWithoutPostsInput | ExpertiseUpsertWithWhereUniqueWithoutPostsInput[]
    set?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    disconnect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    delete?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    connect?: ExpertiseWhereUniqueInput | ExpertiseWhereUniqueInput[]
    update?: ExpertiseUpdateWithWhereUniqueWithoutPostsInput | ExpertiseUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: ExpertiseUpdateManyWithWhereWithoutPostsInput | ExpertiseUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: ExpertiseScalarWhereInput | ExpertiseScalarWhereInput[]
  }

  export type DeviceCreateNestedOneWithoutPlanningInput = {
    create?: XOR<DeviceCreateWithoutPlanningInput, DeviceUncheckedCreateWithoutPlanningInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPlanningInput
    connect?: DeviceWhereUniqueInput
  }

  export type OperationHistoryCreateNestedManyWithoutPlanningInput = {
    create?: XOR<OperationHistoryCreateWithoutPlanningInput, OperationHistoryUncheckedCreateWithoutPlanningInput> | OperationHistoryCreateWithoutPlanningInput[] | OperationHistoryUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: OperationHistoryCreateOrConnectWithoutPlanningInput | OperationHistoryCreateOrConnectWithoutPlanningInput[]
    createMany?: OperationHistoryCreateManyPlanningInputEnvelope
    connect?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
  }

  export type CommandProjectCreateNestedOneWithoutPlaningsInput = {
    create?: XOR<CommandProjectCreateWithoutPlaningsInput, CommandProjectUncheckedCreateWithoutPlaningsInput>
    connectOrCreate?: CommandProjectCreateOrConnectWithoutPlaningsInput
    connect?: CommandProjectWhereUniqueInput
  }

  export type OperationCreateNestedOneWithoutPlanningsInput = {
    create?: XOR<OperationCreateWithoutPlanningsInput, OperationUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutPlanningsInput
    connect?: OperationWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutPlanningsInput = {
    create?: XOR<PostCreateWithoutPlanningsInput, PostUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPlanningsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPlanningsInput = {
    create?: XOR<UserCreateWithoutPlanningsInput, UserUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlanningsInput
    connect?: UserWhereUniqueInput
  }

  export type DeviceUncheckedCreateNestedOneWithoutPlanningInput = {
    create?: XOR<DeviceCreateWithoutPlanningInput, DeviceUncheckedCreateWithoutPlanningInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPlanningInput
    connect?: DeviceWhereUniqueInput
  }

  export type OperationHistoryUncheckedCreateNestedManyWithoutPlanningInput = {
    create?: XOR<OperationHistoryCreateWithoutPlanningInput, OperationHistoryUncheckedCreateWithoutPlanningInput> | OperationHistoryCreateWithoutPlanningInput[] | OperationHistoryUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: OperationHistoryCreateOrConnectWithoutPlanningInput | OperationHistoryCreateOrConnectWithoutPlanningInput[]
    createMany?: OperationHistoryCreateManyPlanningInputEnvelope
    connect?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
  }

  export type DeviceUpdateOneWithoutPlanningNestedInput = {
    create?: XOR<DeviceCreateWithoutPlanningInput, DeviceUncheckedCreateWithoutPlanningInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPlanningInput
    upsert?: DeviceUpsertWithoutPlanningInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutPlanningInput, DeviceUpdateWithoutPlanningInput>, DeviceUncheckedUpdateWithoutPlanningInput>
  }

  export type OperationHistoryUpdateManyWithoutPlanningNestedInput = {
    create?: XOR<OperationHistoryCreateWithoutPlanningInput, OperationHistoryUncheckedCreateWithoutPlanningInput> | OperationHistoryCreateWithoutPlanningInput[] | OperationHistoryUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: OperationHistoryCreateOrConnectWithoutPlanningInput | OperationHistoryCreateOrConnectWithoutPlanningInput[]
    upsert?: OperationHistoryUpsertWithWhereUniqueWithoutPlanningInput | OperationHistoryUpsertWithWhereUniqueWithoutPlanningInput[]
    createMany?: OperationHistoryCreateManyPlanningInputEnvelope
    set?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
    disconnect?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
    delete?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
    connect?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
    update?: OperationHistoryUpdateWithWhereUniqueWithoutPlanningInput | OperationHistoryUpdateWithWhereUniqueWithoutPlanningInput[]
    updateMany?: OperationHistoryUpdateManyWithWhereWithoutPlanningInput | OperationHistoryUpdateManyWithWhereWithoutPlanningInput[]
    deleteMany?: OperationHistoryScalarWhereInput | OperationHistoryScalarWhereInput[]
  }

  export type CommandProjectUpdateOneRequiredWithoutPlaningsNestedInput = {
    create?: XOR<CommandProjectCreateWithoutPlaningsInput, CommandProjectUncheckedCreateWithoutPlaningsInput>
    connectOrCreate?: CommandProjectCreateOrConnectWithoutPlaningsInput
    upsert?: CommandProjectUpsertWithoutPlaningsInput
    connect?: CommandProjectWhereUniqueInput
    update?: XOR<XOR<CommandProjectUpdateToOneWithWhereWithoutPlaningsInput, CommandProjectUpdateWithoutPlaningsInput>, CommandProjectUncheckedUpdateWithoutPlaningsInput>
  }

  export type OperationUpdateOneRequiredWithoutPlanningsNestedInput = {
    create?: XOR<OperationCreateWithoutPlanningsInput, OperationUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutPlanningsInput
    upsert?: OperationUpsertWithoutPlanningsInput
    connect?: OperationWhereUniqueInput
    update?: XOR<XOR<OperationUpdateToOneWithWhereWithoutPlanningsInput, OperationUpdateWithoutPlanningsInput>, OperationUncheckedUpdateWithoutPlanningsInput>
  }

  export type PostUpdateOneRequiredWithoutPlanningsNestedInput = {
    create?: XOR<PostCreateWithoutPlanningsInput, PostUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPlanningsInput
    upsert?: PostUpsertWithoutPlanningsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutPlanningsInput, PostUpdateWithoutPlanningsInput>, PostUncheckedUpdateWithoutPlanningsInput>
  }

  export type UserUpdateOneRequiredWithoutPlanningsNestedInput = {
    create?: XOR<UserCreateWithoutPlanningsInput, UserUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlanningsInput
    upsert?: UserUpsertWithoutPlanningsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlanningsInput, UserUpdateWithoutPlanningsInput>, UserUncheckedUpdateWithoutPlanningsInput>
  }

  export type DeviceUncheckedUpdateOneWithoutPlanningNestedInput = {
    create?: XOR<DeviceCreateWithoutPlanningInput, DeviceUncheckedCreateWithoutPlanningInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPlanningInput
    upsert?: DeviceUpsertWithoutPlanningInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutPlanningInput, DeviceUpdateWithoutPlanningInput>, DeviceUncheckedUpdateWithoutPlanningInput>
  }

  export type OperationHistoryUncheckedUpdateManyWithoutPlanningNestedInput = {
    create?: XOR<OperationHistoryCreateWithoutPlanningInput, OperationHistoryUncheckedCreateWithoutPlanningInput> | OperationHistoryCreateWithoutPlanningInput[] | OperationHistoryUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: OperationHistoryCreateOrConnectWithoutPlanningInput | OperationHistoryCreateOrConnectWithoutPlanningInput[]
    upsert?: OperationHistoryUpsertWithWhereUniqueWithoutPlanningInput | OperationHistoryUpsertWithWhereUniqueWithoutPlanningInput[]
    createMany?: OperationHistoryCreateManyPlanningInputEnvelope
    set?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
    disconnect?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
    delete?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
    connect?: OperationHistoryWhereUniqueInput | OperationHistoryWhereUniqueInput[]
    update?: OperationHistoryUpdateWithWhereUniqueWithoutPlanningInput | OperationHistoryUpdateWithWhereUniqueWithoutPlanningInput[]
    updateMany?: OperationHistoryUpdateManyWithWhereWithoutPlanningInput | OperationHistoryUpdateManyWithWhereWithoutPlanningInput[]
    deleteMany?: OperationHistoryScalarWhereInput | OperationHistoryScalarWhereInput[]
  }

  export type CommandProjectCreateNestedOneWithoutSprintInput = {
    create?: XOR<CommandProjectCreateWithoutSprintInput, CommandProjectUncheckedCreateWithoutSprintInput>
    connectOrCreate?: CommandProjectCreateOrConnectWithoutSprintInput
    connect?: CommandProjectWhereUniqueInput
  }

  export type CommandProjectUpdateOneRequiredWithoutSprintNestedInput = {
    create?: XOR<CommandProjectCreateWithoutSprintInput, CommandProjectUncheckedCreateWithoutSprintInput>
    connectOrCreate?: CommandProjectCreateOrConnectWithoutSprintInput
    upsert?: CommandProjectUpsertWithoutSprintInput
    connect?: CommandProjectWhereUniqueInput
    update?: XOR<XOR<CommandProjectUpdateToOneWithWhereWithoutSprintInput, CommandProjectUpdateWithoutSprintInput>, CommandProjectUncheckedUpdateWithoutSprintInput>
  }

  export type ExpertiseCreateNestedOneWithoutOperationsInput = {
    create?: XOR<ExpertiseCreateWithoutOperationsInput, ExpertiseUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: ExpertiseCreateOrConnectWithoutOperationsInput
    connect?: ExpertiseWhereUniqueInput
  }

  export type PlanningCreateNestedManyWithoutOperationInput = {
    create?: XOR<PlanningCreateWithoutOperationInput, PlanningUncheckedCreateWithoutOperationInput> | PlanningCreateWithoutOperationInput[] | PlanningUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutOperationInput | PlanningCreateOrConnectWithoutOperationInput[]
    createMany?: PlanningCreateManyOperationInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutOperationInput = {
    create?: XOR<PostCreateWithoutOperationInput, PostUncheckedCreateWithoutOperationInput> | PostCreateWithoutOperationInput[] | PostUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: PostCreateOrConnectWithoutOperationInput | PostCreateOrConnectWithoutOperationInput[]
    createMany?: PostCreateManyOperationInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type WorkFlowNodeCreateNestedManyWithoutOperationInput = {
    create?: XOR<WorkFlowNodeCreateWithoutOperationInput, WorkFlowNodeUncheckedCreateWithoutOperationInput> | WorkFlowNodeCreateWithoutOperationInput[] | WorkFlowNodeUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutOperationInput | WorkFlowNodeCreateOrConnectWithoutOperationInput[]
    createMany?: WorkFlowNodeCreateManyOperationInputEnvelope
    connect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
  }

  export type PlanningUncheckedCreateNestedManyWithoutOperationInput = {
    create?: XOR<PlanningCreateWithoutOperationInput, PlanningUncheckedCreateWithoutOperationInput> | PlanningCreateWithoutOperationInput[] | PlanningUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutOperationInput | PlanningCreateOrConnectWithoutOperationInput[]
    createMany?: PlanningCreateManyOperationInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutOperationInput = {
    create?: XOR<PostCreateWithoutOperationInput, PostUncheckedCreateWithoutOperationInput> | PostCreateWithoutOperationInput[] | PostUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: PostCreateOrConnectWithoutOperationInput | PostCreateOrConnectWithoutOperationInput[]
    createMany?: PostCreateManyOperationInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type WorkFlowNodeUncheckedCreateNestedManyWithoutOperationInput = {
    create?: XOR<WorkFlowNodeCreateWithoutOperationInput, WorkFlowNodeUncheckedCreateWithoutOperationInput> | WorkFlowNodeCreateWithoutOperationInput[] | WorkFlowNodeUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutOperationInput | WorkFlowNodeCreateOrConnectWithoutOperationInput[]
    createMany?: WorkFlowNodeCreateManyOperationInputEnvelope
    connect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
  }

  export type ExpertiseUpdateOneWithoutOperationsNestedInput = {
    create?: XOR<ExpertiseCreateWithoutOperationsInput, ExpertiseUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: ExpertiseCreateOrConnectWithoutOperationsInput
    upsert?: ExpertiseUpsertWithoutOperationsInput
    disconnect?: ExpertiseWhereInput | boolean
    delete?: ExpertiseWhereInput | boolean
    connect?: ExpertiseWhereUniqueInput
    update?: XOR<XOR<ExpertiseUpdateToOneWithWhereWithoutOperationsInput, ExpertiseUpdateWithoutOperationsInput>, ExpertiseUncheckedUpdateWithoutOperationsInput>
  }

  export type PlanningUpdateManyWithoutOperationNestedInput = {
    create?: XOR<PlanningCreateWithoutOperationInput, PlanningUncheckedCreateWithoutOperationInput> | PlanningCreateWithoutOperationInput[] | PlanningUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutOperationInput | PlanningCreateOrConnectWithoutOperationInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutOperationInput | PlanningUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: PlanningCreateManyOperationInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutOperationInput | PlanningUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutOperationInput | PlanningUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type PostUpdateManyWithoutOperationNestedInput = {
    create?: XOR<PostCreateWithoutOperationInput, PostUncheckedCreateWithoutOperationInput> | PostCreateWithoutOperationInput[] | PostUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: PostCreateOrConnectWithoutOperationInput | PostCreateOrConnectWithoutOperationInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutOperationInput | PostUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: PostCreateManyOperationInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutOperationInput | PostUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: PostUpdateManyWithWhereWithoutOperationInput | PostUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type WorkFlowNodeUpdateManyWithoutOperationNestedInput = {
    create?: XOR<WorkFlowNodeCreateWithoutOperationInput, WorkFlowNodeUncheckedCreateWithoutOperationInput> | WorkFlowNodeCreateWithoutOperationInput[] | WorkFlowNodeUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutOperationInput | WorkFlowNodeCreateOrConnectWithoutOperationInput[]
    upsert?: WorkFlowNodeUpsertWithWhereUniqueWithoutOperationInput | WorkFlowNodeUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: WorkFlowNodeCreateManyOperationInputEnvelope
    set?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    disconnect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    delete?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    connect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    update?: WorkFlowNodeUpdateWithWhereUniqueWithoutOperationInput | WorkFlowNodeUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: WorkFlowNodeUpdateManyWithWhereWithoutOperationInput | WorkFlowNodeUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: WorkFlowNodeScalarWhereInput | WorkFlowNodeScalarWhereInput[]
  }

  export type PlanningUncheckedUpdateManyWithoutOperationNestedInput = {
    create?: XOR<PlanningCreateWithoutOperationInput, PlanningUncheckedCreateWithoutOperationInput> | PlanningCreateWithoutOperationInput[] | PlanningUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutOperationInput | PlanningCreateOrConnectWithoutOperationInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutOperationInput | PlanningUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: PlanningCreateManyOperationInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutOperationInput | PlanningUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutOperationInput | PlanningUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutOperationNestedInput = {
    create?: XOR<PostCreateWithoutOperationInput, PostUncheckedCreateWithoutOperationInput> | PostCreateWithoutOperationInput[] | PostUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: PostCreateOrConnectWithoutOperationInput | PostCreateOrConnectWithoutOperationInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutOperationInput | PostUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: PostCreateManyOperationInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutOperationInput | PostUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: PostUpdateManyWithWhereWithoutOperationInput | PostUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type WorkFlowNodeUncheckedUpdateManyWithoutOperationNestedInput = {
    create?: XOR<WorkFlowNodeCreateWithoutOperationInput, WorkFlowNodeUncheckedCreateWithoutOperationInput> | WorkFlowNodeCreateWithoutOperationInput[] | WorkFlowNodeUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutOperationInput | WorkFlowNodeCreateOrConnectWithoutOperationInput[]
    upsert?: WorkFlowNodeUpsertWithWhereUniqueWithoutOperationInput | WorkFlowNodeUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: WorkFlowNodeCreateManyOperationInputEnvelope
    set?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    disconnect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    delete?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    connect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    update?: WorkFlowNodeUpdateWithWhereUniqueWithoutOperationInput | WorkFlowNodeUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: WorkFlowNodeUpdateManyWithWhereWithoutOperationInput | WorkFlowNodeUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: WorkFlowNodeScalarWhereInput | WorkFlowNodeScalarWhereInput[]
  }

  export type WorkFlowEdgeCreateNestedManyWithoutSourceInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutSourceInput, WorkFlowEdgeUncheckedCreateWithoutSourceInput> | WorkFlowEdgeCreateWithoutSourceInput[] | WorkFlowEdgeUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutSourceInput | WorkFlowEdgeCreateOrConnectWithoutSourceInput[]
    createMany?: WorkFlowEdgeCreateManySourceInputEnvelope
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
  }

  export type WorkFlowEdgeCreateNestedManyWithoutTargetInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutTargetInput, WorkFlowEdgeUncheckedCreateWithoutTargetInput> | WorkFlowEdgeCreateWithoutTargetInput[] | WorkFlowEdgeUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutTargetInput | WorkFlowEdgeCreateOrConnectWithoutTargetInput[]
    createMany?: WorkFlowEdgeCreateManyTargetInputEnvelope
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
  }

  export type OperationCreateNestedOneWithoutWorkflowNodeInput = {
    create?: XOR<OperationCreateWithoutWorkflowNodeInput, OperationUncheckedCreateWithoutWorkflowNodeInput>
    connectOrCreate?: OperationCreateOrConnectWithoutWorkflowNodeInput
    connect?: OperationWhereUniqueInput
  }

  export type WorkFlowCreateNestedOneWithoutWorkflowNodeInput = {
    create?: XOR<WorkFlowCreateWithoutWorkflowNodeInput, WorkFlowUncheckedCreateWithoutWorkflowNodeInput>
    connectOrCreate?: WorkFlowCreateOrConnectWithoutWorkflowNodeInput
    connect?: WorkFlowWhereUniqueInput
  }

  export type WorkFlowEdgeUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutSourceInput, WorkFlowEdgeUncheckedCreateWithoutSourceInput> | WorkFlowEdgeCreateWithoutSourceInput[] | WorkFlowEdgeUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutSourceInput | WorkFlowEdgeCreateOrConnectWithoutSourceInput[]
    createMany?: WorkFlowEdgeCreateManySourceInputEnvelope
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
  }

  export type WorkFlowEdgeUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutTargetInput, WorkFlowEdgeUncheckedCreateWithoutTargetInput> | WorkFlowEdgeCreateWithoutTargetInput[] | WorkFlowEdgeUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutTargetInput | WorkFlowEdgeCreateOrConnectWithoutTargetInput[]
    createMany?: WorkFlowEdgeCreateManyTargetInputEnvelope
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
  }

  export type WorkFlowEdgeUpdateManyWithoutSourceNestedInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutSourceInput, WorkFlowEdgeUncheckedCreateWithoutSourceInput> | WorkFlowEdgeCreateWithoutSourceInput[] | WorkFlowEdgeUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutSourceInput | WorkFlowEdgeCreateOrConnectWithoutSourceInput[]
    upsert?: WorkFlowEdgeUpsertWithWhereUniqueWithoutSourceInput | WorkFlowEdgeUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: WorkFlowEdgeCreateManySourceInputEnvelope
    set?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    disconnect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    delete?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    update?: WorkFlowEdgeUpdateWithWhereUniqueWithoutSourceInput | WorkFlowEdgeUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: WorkFlowEdgeUpdateManyWithWhereWithoutSourceInput | WorkFlowEdgeUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: WorkFlowEdgeScalarWhereInput | WorkFlowEdgeScalarWhereInput[]
  }

  export type WorkFlowEdgeUpdateManyWithoutTargetNestedInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutTargetInput, WorkFlowEdgeUncheckedCreateWithoutTargetInput> | WorkFlowEdgeCreateWithoutTargetInput[] | WorkFlowEdgeUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutTargetInput | WorkFlowEdgeCreateOrConnectWithoutTargetInput[]
    upsert?: WorkFlowEdgeUpsertWithWhereUniqueWithoutTargetInput | WorkFlowEdgeUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: WorkFlowEdgeCreateManyTargetInputEnvelope
    set?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    disconnect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    delete?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    update?: WorkFlowEdgeUpdateWithWhereUniqueWithoutTargetInput | WorkFlowEdgeUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: WorkFlowEdgeUpdateManyWithWhereWithoutTargetInput | WorkFlowEdgeUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: WorkFlowEdgeScalarWhereInput | WorkFlowEdgeScalarWhereInput[]
  }

  export type OperationUpdateOneRequiredWithoutWorkflowNodeNestedInput = {
    create?: XOR<OperationCreateWithoutWorkflowNodeInput, OperationUncheckedCreateWithoutWorkflowNodeInput>
    connectOrCreate?: OperationCreateOrConnectWithoutWorkflowNodeInput
    upsert?: OperationUpsertWithoutWorkflowNodeInput
    connect?: OperationWhereUniqueInput
    update?: XOR<XOR<OperationUpdateToOneWithWhereWithoutWorkflowNodeInput, OperationUpdateWithoutWorkflowNodeInput>, OperationUncheckedUpdateWithoutWorkflowNodeInput>
  }

  export type WorkFlowUpdateOneRequiredWithoutWorkflowNodeNestedInput = {
    create?: XOR<WorkFlowCreateWithoutWorkflowNodeInput, WorkFlowUncheckedCreateWithoutWorkflowNodeInput>
    connectOrCreate?: WorkFlowCreateOrConnectWithoutWorkflowNodeInput
    upsert?: WorkFlowUpsertWithoutWorkflowNodeInput
    connect?: WorkFlowWhereUniqueInput
    update?: XOR<XOR<WorkFlowUpdateToOneWithWhereWithoutWorkflowNodeInput, WorkFlowUpdateWithoutWorkflowNodeInput>, WorkFlowUncheckedUpdateWithoutWorkflowNodeInput>
  }

  export type WorkFlowEdgeUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutSourceInput, WorkFlowEdgeUncheckedCreateWithoutSourceInput> | WorkFlowEdgeCreateWithoutSourceInput[] | WorkFlowEdgeUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutSourceInput | WorkFlowEdgeCreateOrConnectWithoutSourceInput[]
    upsert?: WorkFlowEdgeUpsertWithWhereUniqueWithoutSourceInput | WorkFlowEdgeUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: WorkFlowEdgeCreateManySourceInputEnvelope
    set?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    disconnect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    delete?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    update?: WorkFlowEdgeUpdateWithWhereUniqueWithoutSourceInput | WorkFlowEdgeUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: WorkFlowEdgeUpdateManyWithWhereWithoutSourceInput | WorkFlowEdgeUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: WorkFlowEdgeScalarWhereInput | WorkFlowEdgeScalarWhereInput[]
  }

  export type WorkFlowEdgeUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutTargetInput, WorkFlowEdgeUncheckedCreateWithoutTargetInput> | WorkFlowEdgeCreateWithoutTargetInput[] | WorkFlowEdgeUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutTargetInput | WorkFlowEdgeCreateOrConnectWithoutTargetInput[]
    upsert?: WorkFlowEdgeUpsertWithWhereUniqueWithoutTargetInput | WorkFlowEdgeUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: WorkFlowEdgeCreateManyTargetInputEnvelope
    set?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    disconnect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    delete?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    update?: WorkFlowEdgeUpdateWithWhereUniqueWithoutTargetInput | WorkFlowEdgeUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: WorkFlowEdgeUpdateManyWithWhereWithoutTargetInput | WorkFlowEdgeUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: WorkFlowEdgeScalarWhereInput | WorkFlowEdgeScalarWhereInput[]
  }

  export type WorkFlowNodeCreateNestedOneWithoutTargetEdgesInput = {
    create?: XOR<WorkFlowNodeCreateWithoutTargetEdgesInput, WorkFlowNodeUncheckedCreateWithoutTargetEdgesInput>
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutTargetEdgesInput
    connect?: WorkFlowNodeWhereUniqueInput
  }

  export type WorkFlowNodeCreateNestedOneWithoutSourceEdgesInput = {
    create?: XOR<WorkFlowNodeCreateWithoutSourceEdgesInput, WorkFlowNodeUncheckedCreateWithoutSourceEdgesInput>
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutSourceEdgesInput
    connect?: WorkFlowNodeWhereUniqueInput
  }

  export type WorkFlowCreateNestedOneWithoutWorkFlowEdgeInput = {
    create?: XOR<WorkFlowCreateWithoutWorkFlowEdgeInput, WorkFlowUncheckedCreateWithoutWorkFlowEdgeInput>
    connectOrCreate?: WorkFlowCreateOrConnectWithoutWorkFlowEdgeInput
    connect?: WorkFlowWhereUniqueInput
  }

  export type WorkFlowNodeUpdateOneRequiredWithoutTargetEdgesNestedInput = {
    create?: XOR<WorkFlowNodeCreateWithoutTargetEdgesInput, WorkFlowNodeUncheckedCreateWithoutTargetEdgesInput>
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutTargetEdgesInput
    upsert?: WorkFlowNodeUpsertWithoutTargetEdgesInput
    connect?: WorkFlowNodeWhereUniqueInput
    update?: XOR<XOR<WorkFlowNodeUpdateToOneWithWhereWithoutTargetEdgesInput, WorkFlowNodeUpdateWithoutTargetEdgesInput>, WorkFlowNodeUncheckedUpdateWithoutTargetEdgesInput>
  }

  export type WorkFlowNodeUpdateOneRequiredWithoutSourceEdgesNestedInput = {
    create?: XOR<WorkFlowNodeCreateWithoutSourceEdgesInput, WorkFlowNodeUncheckedCreateWithoutSourceEdgesInput>
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutSourceEdgesInput
    upsert?: WorkFlowNodeUpsertWithoutSourceEdgesInput
    connect?: WorkFlowNodeWhereUniqueInput
    update?: XOR<XOR<WorkFlowNodeUpdateToOneWithWhereWithoutSourceEdgesInput, WorkFlowNodeUpdateWithoutSourceEdgesInput>, WorkFlowNodeUncheckedUpdateWithoutSourceEdgesInput>
  }

  export type WorkFlowUpdateOneRequiredWithoutWorkFlowEdgeNestedInput = {
    create?: XOR<WorkFlowCreateWithoutWorkFlowEdgeInput, WorkFlowUncheckedCreateWithoutWorkFlowEdgeInput>
    connectOrCreate?: WorkFlowCreateOrConnectWithoutWorkFlowEdgeInput
    upsert?: WorkFlowUpsertWithoutWorkFlowEdgeInput
    connect?: WorkFlowWhereUniqueInput
    update?: XOR<XOR<WorkFlowUpdateToOneWithWhereWithoutWorkFlowEdgeInput, WorkFlowUpdateWithoutWorkFlowEdgeInput>, WorkFlowUncheckedUpdateWithoutWorkFlowEdgeInput>
  }

  export type ProjectCreateNestedOneWithoutWorkFlowInput = {
    create?: XOR<ProjectCreateWithoutWorkFlowInput, ProjectUncheckedCreateWithoutWorkFlowInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkFlowInput
    connect?: ProjectWhereUniqueInput
  }

  export type WorkFlowEdgeCreateNestedManyWithoutWorkFlowInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutWorkFlowInput, WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput> | WorkFlowEdgeCreateWithoutWorkFlowInput[] | WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput | WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput[]
    createMany?: WorkFlowEdgeCreateManyWorkFlowInputEnvelope
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
  }

  export type WorkFlowNodeCreateNestedManyWithoutWorkFlowInput = {
    create?: XOR<WorkFlowNodeCreateWithoutWorkFlowInput, WorkFlowNodeUncheckedCreateWithoutWorkFlowInput> | WorkFlowNodeCreateWithoutWorkFlowInput[] | WorkFlowNodeUncheckedCreateWithoutWorkFlowInput[]
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutWorkFlowInput | WorkFlowNodeCreateOrConnectWithoutWorkFlowInput[]
    createMany?: WorkFlowNodeCreateManyWorkFlowInputEnvelope
    connect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedOneWithoutWorkFlowInput = {
    create?: XOR<ProjectCreateWithoutWorkFlowInput, ProjectUncheckedCreateWithoutWorkFlowInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkFlowInput
    connect?: ProjectWhereUniqueInput
  }

  export type WorkFlowEdgeUncheckedCreateNestedManyWithoutWorkFlowInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutWorkFlowInput, WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput> | WorkFlowEdgeCreateWithoutWorkFlowInput[] | WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput | WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput[]
    createMany?: WorkFlowEdgeCreateManyWorkFlowInputEnvelope
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
  }

  export type WorkFlowNodeUncheckedCreateNestedManyWithoutWorkFlowInput = {
    create?: XOR<WorkFlowNodeCreateWithoutWorkFlowInput, WorkFlowNodeUncheckedCreateWithoutWorkFlowInput> | WorkFlowNodeCreateWithoutWorkFlowInput[] | WorkFlowNodeUncheckedCreateWithoutWorkFlowInput[]
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutWorkFlowInput | WorkFlowNodeCreateOrConnectWithoutWorkFlowInput[]
    createMany?: WorkFlowNodeCreateManyWorkFlowInputEnvelope
    connect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
  }

  export type ProjectUpdateOneWithoutWorkFlowNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkFlowInput, ProjectUncheckedCreateWithoutWorkFlowInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkFlowInput
    upsert?: ProjectUpsertWithoutWorkFlowInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWorkFlowInput, ProjectUpdateWithoutWorkFlowInput>, ProjectUncheckedUpdateWithoutWorkFlowInput>
  }

  export type WorkFlowEdgeUpdateManyWithoutWorkFlowNestedInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutWorkFlowInput, WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput> | WorkFlowEdgeCreateWithoutWorkFlowInput[] | WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput | WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput[]
    upsert?: WorkFlowEdgeUpsertWithWhereUniqueWithoutWorkFlowInput | WorkFlowEdgeUpsertWithWhereUniqueWithoutWorkFlowInput[]
    createMany?: WorkFlowEdgeCreateManyWorkFlowInputEnvelope
    set?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    disconnect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    delete?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    update?: WorkFlowEdgeUpdateWithWhereUniqueWithoutWorkFlowInput | WorkFlowEdgeUpdateWithWhereUniqueWithoutWorkFlowInput[]
    updateMany?: WorkFlowEdgeUpdateManyWithWhereWithoutWorkFlowInput | WorkFlowEdgeUpdateManyWithWhereWithoutWorkFlowInput[]
    deleteMany?: WorkFlowEdgeScalarWhereInput | WorkFlowEdgeScalarWhereInput[]
  }

  export type WorkFlowNodeUpdateManyWithoutWorkFlowNestedInput = {
    create?: XOR<WorkFlowNodeCreateWithoutWorkFlowInput, WorkFlowNodeUncheckedCreateWithoutWorkFlowInput> | WorkFlowNodeCreateWithoutWorkFlowInput[] | WorkFlowNodeUncheckedCreateWithoutWorkFlowInput[]
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutWorkFlowInput | WorkFlowNodeCreateOrConnectWithoutWorkFlowInput[]
    upsert?: WorkFlowNodeUpsertWithWhereUniqueWithoutWorkFlowInput | WorkFlowNodeUpsertWithWhereUniqueWithoutWorkFlowInput[]
    createMany?: WorkFlowNodeCreateManyWorkFlowInputEnvelope
    set?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    disconnect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    delete?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    connect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    update?: WorkFlowNodeUpdateWithWhereUniqueWithoutWorkFlowInput | WorkFlowNodeUpdateWithWhereUniqueWithoutWorkFlowInput[]
    updateMany?: WorkFlowNodeUpdateManyWithWhereWithoutWorkFlowInput | WorkFlowNodeUpdateManyWithWhereWithoutWorkFlowInput[]
    deleteMany?: WorkFlowNodeScalarWhereInput | WorkFlowNodeScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateOneWithoutWorkFlowNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkFlowInput, ProjectUncheckedCreateWithoutWorkFlowInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkFlowInput
    upsert?: ProjectUpsertWithoutWorkFlowInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWorkFlowInput, ProjectUpdateWithoutWorkFlowInput>, ProjectUncheckedUpdateWithoutWorkFlowInput>
  }

  export type WorkFlowEdgeUncheckedUpdateManyWithoutWorkFlowNestedInput = {
    create?: XOR<WorkFlowEdgeCreateWithoutWorkFlowInput, WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput> | WorkFlowEdgeCreateWithoutWorkFlowInput[] | WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput[]
    connectOrCreate?: WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput | WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput[]
    upsert?: WorkFlowEdgeUpsertWithWhereUniqueWithoutWorkFlowInput | WorkFlowEdgeUpsertWithWhereUniqueWithoutWorkFlowInput[]
    createMany?: WorkFlowEdgeCreateManyWorkFlowInputEnvelope
    set?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    disconnect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    delete?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    connect?: WorkFlowEdgeWhereUniqueInput | WorkFlowEdgeWhereUniqueInput[]
    update?: WorkFlowEdgeUpdateWithWhereUniqueWithoutWorkFlowInput | WorkFlowEdgeUpdateWithWhereUniqueWithoutWorkFlowInput[]
    updateMany?: WorkFlowEdgeUpdateManyWithWhereWithoutWorkFlowInput | WorkFlowEdgeUpdateManyWithWhereWithoutWorkFlowInput[]
    deleteMany?: WorkFlowEdgeScalarWhereInput | WorkFlowEdgeScalarWhereInput[]
  }

  export type WorkFlowNodeUncheckedUpdateManyWithoutWorkFlowNestedInput = {
    create?: XOR<WorkFlowNodeCreateWithoutWorkFlowInput, WorkFlowNodeUncheckedCreateWithoutWorkFlowInput> | WorkFlowNodeCreateWithoutWorkFlowInput[] | WorkFlowNodeUncheckedCreateWithoutWorkFlowInput[]
    connectOrCreate?: WorkFlowNodeCreateOrConnectWithoutWorkFlowInput | WorkFlowNodeCreateOrConnectWithoutWorkFlowInput[]
    upsert?: WorkFlowNodeUpsertWithWhereUniqueWithoutWorkFlowInput | WorkFlowNodeUpsertWithWhereUniqueWithoutWorkFlowInput[]
    createMany?: WorkFlowNodeCreateManyWorkFlowInputEnvelope
    set?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    disconnect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    delete?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    connect?: WorkFlowNodeWhereUniqueInput | WorkFlowNodeWhereUniqueInput[]
    update?: WorkFlowNodeUpdateWithWhereUniqueWithoutWorkFlowInput | WorkFlowNodeUpdateWithWhereUniqueWithoutWorkFlowInput[]
    updateMany?: WorkFlowNodeUpdateManyWithWhereWithoutWorkFlowInput | WorkFlowNodeUpdateManyWithWhereWithoutWorkFlowInput[]
    deleteMany?: WorkFlowNodeScalarWhereInput | WorkFlowNodeScalarWhereInput[]
  }

  export type PlanningCreateNestedOneWithoutOperationHistoryInput = {
    create?: XOR<PlanningCreateWithoutOperationHistoryInput, PlanningUncheckedCreateWithoutOperationHistoryInput>
    connectOrCreate?: PlanningCreateOrConnectWithoutOperationHistoryInput
    connect?: PlanningWhereUniqueInput
  }

  export type PlanningUpdateOneRequiredWithoutOperationHistoryNestedInput = {
    create?: XOR<PlanningCreateWithoutOperationHistoryInput, PlanningUncheckedCreateWithoutOperationHistoryInput>
    connectOrCreate?: PlanningCreateOrConnectWithoutOperationHistoryInput
    upsert?: PlanningUpsertWithoutOperationHistoryInput
    connect?: PlanningWhereUniqueInput
    update?: XOR<XOR<PlanningUpdateToOneWithWhereWithoutOperationHistoryInput, PlanningUpdateWithoutOperationHistoryInput>, PlanningUncheckedUpdateWithoutOperationHistoryInput>
  }

  export type UserCreateNestedOneWithoutExpertisesInput = {
    create?: XOR<UserCreateWithoutExpertisesInput, UserUncheckedCreateWithoutExpertisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpertisesInput
    connect?: UserWhereUniqueInput
  }

  export type OperationCreateNestedManyWithoutExpertiseInput = {
    create?: XOR<OperationCreateWithoutExpertiseInput, OperationUncheckedCreateWithoutExpertiseInput> | OperationCreateWithoutExpertiseInput[] | OperationUncheckedCreateWithoutExpertiseInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutExpertiseInput | OperationCreateOrConnectWithoutExpertiseInput[]
    createMany?: OperationCreateManyExpertiseInputEnvelope
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutExpertisesInput = {
    create?: XOR<PostCreateWithoutExpertisesInput, PostUncheckedCreateWithoutExpertisesInput> | PostCreateWithoutExpertisesInput[] | PostUncheckedCreateWithoutExpertisesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutExpertisesInput | PostCreateOrConnectWithoutExpertisesInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type OperationUncheckedCreateNestedManyWithoutExpertiseInput = {
    create?: XOR<OperationCreateWithoutExpertiseInput, OperationUncheckedCreateWithoutExpertiseInput> | OperationCreateWithoutExpertiseInput[] | OperationUncheckedCreateWithoutExpertiseInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutExpertiseInput | OperationCreateOrConnectWithoutExpertiseInput[]
    createMany?: OperationCreateManyExpertiseInputEnvelope
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutExpertisesInput = {
    create?: XOR<PostCreateWithoutExpertisesInput, PostUncheckedCreateWithoutExpertisesInput> | PostCreateWithoutExpertisesInput[] | PostUncheckedCreateWithoutExpertisesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutExpertisesInput | PostCreateOrConnectWithoutExpertisesInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutExpertisesNestedInput = {
    create?: XOR<UserCreateWithoutExpertisesInput, UserUncheckedCreateWithoutExpertisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpertisesInput
    upsert?: UserUpsertWithoutExpertisesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpertisesInput, UserUpdateWithoutExpertisesInput>, UserUncheckedUpdateWithoutExpertisesInput>
  }

  export type OperationUpdateManyWithoutExpertiseNestedInput = {
    create?: XOR<OperationCreateWithoutExpertiseInput, OperationUncheckedCreateWithoutExpertiseInput> | OperationCreateWithoutExpertiseInput[] | OperationUncheckedCreateWithoutExpertiseInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutExpertiseInput | OperationCreateOrConnectWithoutExpertiseInput[]
    upsert?: OperationUpsertWithWhereUniqueWithoutExpertiseInput | OperationUpsertWithWhereUniqueWithoutExpertiseInput[]
    createMany?: OperationCreateManyExpertiseInputEnvelope
    set?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    disconnect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    delete?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    update?: OperationUpdateWithWhereUniqueWithoutExpertiseInput | OperationUpdateWithWhereUniqueWithoutExpertiseInput[]
    updateMany?: OperationUpdateManyWithWhereWithoutExpertiseInput | OperationUpdateManyWithWhereWithoutExpertiseInput[]
    deleteMany?: OperationScalarWhereInput | OperationScalarWhereInput[]
  }

  export type PostUpdateManyWithoutExpertisesNestedInput = {
    create?: XOR<PostCreateWithoutExpertisesInput, PostUncheckedCreateWithoutExpertisesInput> | PostCreateWithoutExpertisesInput[] | PostUncheckedCreateWithoutExpertisesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutExpertisesInput | PostCreateOrConnectWithoutExpertisesInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutExpertisesInput | PostUpsertWithWhereUniqueWithoutExpertisesInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutExpertisesInput | PostUpdateWithWhereUniqueWithoutExpertisesInput[]
    updateMany?: PostUpdateManyWithWhereWithoutExpertisesInput | PostUpdateManyWithWhereWithoutExpertisesInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type OperationUncheckedUpdateManyWithoutExpertiseNestedInput = {
    create?: XOR<OperationCreateWithoutExpertiseInput, OperationUncheckedCreateWithoutExpertiseInput> | OperationCreateWithoutExpertiseInput[] | OperationUncheckedCreateWithoutExpertiseInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutExpertiseInput | OperationCreateOrConnectWithoutExpertiseInput[]
    upsert?: OperationUpsertWithWhereUniqueWithoutExpertiseInput | OperationUpsertWithWhereUniqueWithoutExpertiseInput[]
    createMany?: OperationCreateManyExpertiseInputEnvelope
    set?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    disconnect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    delete?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    update?: OperationUpdateWithWhereUniqueWithoutExpertiseInput | OperationUpdateWithWhereUniqueWithoutExpertiseInput[]
    updateMany?: OperationUpdateManyWithWhereWithoutExpertiseInput | OperationUpdateManyWithWhereWithoutExpertiseInput[]
    deleteMany?: OperationScalarWhereInput | OperationScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutExpertisesNestedInput = {
    create?: XOR<PostCreateWithoutExpertisesInput, PostUncheckedCreateWithoutExpertisesInput> | PostCreateWithoutExpertisesInput[] | PostUncheckedCreateWithoutExpertisesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutExpertisesInput | PostCreateOrConnectWithoutExpertisesInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutExpertisesInput | PostUpsertWithWhereUniqueWithoutExpertisesInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutExpertisesInput | PostUpdateWithWhereUniqueWithoutExpertisesInput[]
    updateMany?: PostUpdateManyWithWhereWithoutExpertisesInput | PostUpdateManyWithWhereWithoutExpertisesInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<UserCreateWithoutHistoriesInput, UserUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type NullableEnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType | null
  }

  export type UserUpdateOneRequiredWithoutHistoriesNestedInput = {
    create?: XOR<UserCreateWithoutHistoriesInput, UserUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoriesInput
    upsert?: UserUpsertWithoutHistoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHistoriesInput, UserUpdateWithoutHistoriesInput>, UserUncheckedUpdateWithoutHistoriesInput>
  }

  export type PlanningCreateNestedOneWithoutDeviceInput = {
    create?: XOR<PlanningCreateWithoutDeviceInput, PlanningUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: PlanningCreateOrConnectWithoutDeviceInput
    connect?: PlanningWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutDeviceInput = {
    create?: XOR<PostCreateWithoutDeviceInput, PostUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: PostCreateOrConnectWithoutDeviceInput
    connect?: PostWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlanningUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<PlanningCreateWithoutDeviceInput, PlanningUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: PlanningCreateOrConnectWithoutDeviceInput
    upsert?: PlanningUpsertWithoutDeviceInput
    disconnect?: PlanningWhereInput | boolean
    delete?: PlanningWhereInput | boolean
    connect?: PlanningWhereUniqueInput
    update?: XOR<XOR<PlanningUpdateToOneWithWhereWithoutDeviceInput, PlanningUpdateWithoutDeviceInput>, PlanningUncheckedUpdateWithoutDeviceInput>
  }

  export type PostUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<PostCreateWithoutDeviceInput, PostUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: PostCreateOrConnectWithoutDeviceInput
    upsert?: PostUpsertWithoutDeviceInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutDeviceInput, PostUpdateWithoutDeviceInput>, PostUncheckedUpdateWithoutDeviceInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CommandCreateWithoutClientInput = {
    id?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProjects?: CommandProjectCreateNestedManyWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutClientInput = {
    id?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProjects?: CommandProjectUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutClientInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutClientInput, CommandUncheckedCreateWithoutClientInput>
  }

  export type CommandCreateManyClientInputEnvelope = {
    data: CommandCreateManyClientInput | CommandCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ExpertiseCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operations?: OperationCreateNestedManyWithoutExpertiseInput
    posts?: PostCreateNestedManyWithoutExpertisesInput
  }

  export type ExpertiseUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operations?: OperationUncheckedCreateNestedManyWithoutExpertiseInput
    posts?: PostUncheckedCreateNestedManyWithoutExpertisesInput
  }

  export type ExpertiseCreateOrConnectWithoutUsersInput = {
    where: ExpertiseWhereUniqueInput
    create: XOR<ExpertiseCreateWithoutUsersInput, ExpertiseUncheckedCreateWithoutUsersInput>
  }

  export type ExpertiseCreateManyUsersInputEnvelope = {
    data: ExpertiseCreateManyUsersInput | ExpertiseCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type HistoryCreateWithoutUserInput = {
    id?: string
    action: $Enums.ActionType
    entity?: $Enums.EntityType | null
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type HistoryUncheckedCreateWithoutUserInput = {
    id?: string
    action: $Enums.ActionType
    entity?: $Enums.EntityType | null
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type HistoryCreateOrConnectWithoutUserInput = {
    where: HistoryWhereUniqueInput
    create: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput>
  }

  export type HistoryCreateManyUserInputEnvelope = {
    data: HistoryCreateManyUserInput | HistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlanningCreateWithoutOperatorInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryCreateNestedManyWithoutPlanningInput
    commandProject: CommandProjectCreateNestedOneWithoutPlaningsInput
    operation: OperationCreateNestedOneWithoutPlanningsInput
    post: PostCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateWithoutOperatorInput = {
    id?: string
    postId: string
    operationId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceUncheckedCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutOperatorInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutOperatorInput, PlanningUncheckedCreateWithoutOperatorInput>
  }

  export type PlanningCreateManyOperatorInputEnvelope = {
    data: PlanningCreateManyOperatorInput | PlanningCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type CommandUpsertWithWhereUniqueWithoutClientInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutClientInput, CommandUncheckedUpdateWithoutClientInput>
    create: XOR<CommandCreateWithoutClientInput, CommandUncheckedCreateWithoutClientInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutClientInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutClientInput, CommandUncheckedUpdateWithoutClientInput>
  }

  export type CommandUpdateManyWithWhereWithoutClientInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutClientInput>
  }

  export type CommandScalarWhereInput = {
    AND?: CommandScalarWhereInput | CommandScalarWhereInput[]
    OR?: CommandScalarWhereInput[]
    NOT?: CommandScalarWhereInput | CommandScalarWhereInput[]
    id?: StringFilter<"Command"> | string
    reference?: StringFilter<"Command"> | string
    clientId?: StringNullableFilter<"Command"> | string | null
    createdAt?: DateTimeFilter<"Command"> | Date | string
    updatedAt?: DateTimeFilter<"Command"> | Date | string
  }

  export type ExpertiseUpsertWithWhereUniqueWithoutUsersInput = {
    where: ExpertiseWhereUniqueInput
    update: XOR<ExpertiseUpdateWithoutUsersInput, ExpertiseUncheckedUpdateWithoutUsersInput>
    create: XOR<ExpertiseCreateWithoutUsersInput, ExpertiseUncheckedCreateWithoutUsersInput>
  }

  export type ExpertiseUpdateWithWhereUniqueWithoutUsersInput = {
    where: ExpertiseWhereUniqueInput
    data: XOR<ExpertiseUpdateWithoutUsersInput, ExpertiseUncheckedUpdateWithoutUsersInput>
  }

  export type ExpertiseUpdateManyWithWhereWithoutUsersInput = {
    where: ExpertiseScalarWhereInput
    data: XOR<ExpertiseUpdateManyMutationInput, ExpertiseUncheckedUpdateManyWithoutUsersInput>
  }

  export type ExpertiseScalarWhereInput = {
    AND?: ExpertiseScalarWhereInput | ExpertiseScalarWhereInput[]
    OR?: ExpertiseScalarWhereInput[]
    NOT?: ExpertiseScalarWhereInput | ExpertiseScalarWhereInput[]
    id?: StringFilter<"Expertise"> | string
    userId?: StringFilter<"Expertise"> | string
    name?: StringFilter<"Expertise"> | string
    description?: StringNullableFilter<"Expertise"> | string | null
    code?: StringFilter<"Expertise"> | string
    createdAt?: DateTimeFilter<"Expertise"> | Date | string
    updatedAt?: DateTimeFilter<"Expertise"> | Date | string
  }

  export type HistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: HistoryWhereUniqueInput
    update: XOR<HistoryUpdateWithoutUserInput, HistoryUncheckedUpdateWithoutUserInput>
    create: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput>
  }

  export type HistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: HistoryWhereUniqueInput
    data: XOR<HistoryUpdateWithoutUserInput, HistoryUncheckedUpdateWithoutUserInput>
  }

  export type HistoryUpdateManyWithWhereWithoutUserInput = {
    where: HistoryScalarWhereInput
    data: XOR<HistoryUpdateManyMutationInput, HistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type HistoryScalarWhereInput = {
    AND?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
    OR?: HistoryScalarWhereInput[]
    NOT?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
    id?: StringFilter<"History"> | string
    userId?: StringFilter<"History"> | string
    action?: EnumActionTypeFilter<"History"> | $Enums.ActionType
    entity?: EnumEntityTypeNullableFilter<"History"> | $Enums.EntityType | null
    entityId?: StringFilter<"History"> | string
    details?: StringFilter<"History"> | string
    createdAt?: DateTimeFilter<"History"> | Date | string
  }

  export type PlanningUpsertWithWhereUniqueWithoutOperatorInput = {
    where: PlanningWhereUniqueInput
    update: XOR<PlanningUpdateWithoutOperatorInput, PlanningUncheckedUpdateWithoutOperatorInput>
    create: XOR<PlanningCreateWithoutOperatorInput, PlanningUncheckedCreateWithoutOperatorInput>
  }

  export type PlanningUpdateWithWhereUniqueWithoutOperatorInput = {
    where: PlanningWhereUniqueInput
    data: XOR<PlanningUpdateWithoutOperatorInput, PlanningUncheckedUpdateWithoutOperatorInput>
  }

  export type PlanningUpdateManyWithWhereWithoutOperatorInput = {
    where: PlanningScalarWhereInput
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyWithoutOperatorInput>
  }

  export type PlanningScalarWhereInput = {
    AND?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
    OR?: PlanningScalarWhereInput[]
    NOT?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
    id?: StringFilter<"Planning"> | string
    operatorId?: StringFilter<"Planning"> | string
    postId?: StringFilter<"Planning"> | string
    operationId?: StringFilter<"Planning"> | string
    commandProjectId?: StringFilter<"Planning"> | string
    startDate?: DateTimeFilter<"Planning"> | Date | string
    endDate?: DateTimeFilter<"Planning"> | Date | string
    createdAt?: DateTimeFilter<"Planning"> | Date | string
    updatedAt?: DateTimeFilter<"Planning"> | Date | string
  }

  export type CommandProjectCreateWithoutProjectInput = {
    id?: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    command: CommandCreateNestedOneWithoutCommandProjectsInput
    planings?: PlanningCreateNestedManyWithoutCommandProjectInput
    sprint?: SprintCreateNestedOneWithoutCommandProjectInput
  }

  export type CommandProjectUncheckedCreateWithoutProjectInput = {
    id?: string
    commandId: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    planings?: PlanningUncheckedCreateNestedManyWithoutCommandProjectInput
    sprint?: SprintUncheckedCreateNestedOneWithoutCommandProjectInput
  }

  export type CommandProjectCreateOrConnectWithoutProjectInput = {
    where: CommandProjectWhereUniqueInput
    create: XOR<CommandProjectCreateWithoutProjectInput, CommandProjectUncheckedCreateWithoutProjectInput>
  }

  export type CommandProjectCreateManyProjectInputEnvelope = {
    data: CommandProjectCreateManyProjectInput | CommandProjectCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WorkFlowCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    WorkFlowEdge?: WorkFlowEdgeCreateNestedManyWithoutWorkFlowInput
    WorkflowNode?: WorkFlowNodeCreateNestedManyWithoutWorkFlowInput
  }

  export type WorkFlowUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    WorkFlowEdge?: WorkFlowEdgeUncheckedCreateNestedManyWithoutWorkFlowInput
    WorkflowNode?: WorkFlowNodeUncheckedCreateNestedManyWithoutWorkFlowInput
  }

  export type WorkFlowCreateOrConnectWithoutProjectInput = {
    where: WorkFlowWhereUniqueInput
    create: XOR<WorkFlowCreateWithoutProjectInput, WorkFlowUncheckedCreateWithoutProjectInput>
  }

  export type CommandProjectUpsertWithWhereUniqueWithoutProjectInput = {
    where: CommandProjectWhereUniqueInput
    update: XOR<CommandProjectUpdateWithoutProjectInput, CommandProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<CommandProjectCreateWithoutProjectInput, CommandProjectUncheckedCreateWithoutProjectInput>
  }

  export type CommandProjectUpdateWithWhereUniqueWithoutProjectInput = {
    where: CommandProjectWhereUniqueInput
    data: XOR<CommandProjectUpdateWithoutProjectInput, CommandProjectUncheckedUpdateWithoutProjectInput>
  }

  export type CommandProjectUpdateManyWithWhereWithoutProjectInput = {
    where: CommandProjectScalarWhereInput
    data: XOR<CommandProjectUpdateManyMutationInput, CommandProjectUncheckedUpdateManyWithoutProjectInput>
  }

  export type CommandProjectScalarWhereInput = {
    AND?: CommandProjectScalarWhereInput | CommandProjectScalarWhereInput[]
    OR?: CommandProjectScalarWhereInput[]
    NOT?: CommandProjectScalarWhereInput | CommandProjectScalarWhereInput[]
    id?: StringFilter<"CommandProject"> | string
    commandId?: StringFilter<"CommandProject"> | string
    projectId?: StringFilter<"CommandProject"> | string
    target?: IntFilter<"CommandProject"> | number
    done?: IntFilter<"CommandProject"> | number
    startDate?: DateTimeNullableFilter<"CommandProject"> | Date | string | null
    endDate?: DateTimeFilter<"CommandProject"> | Date | string
    status?: EnumStatusFilter<"CommandProject"> | $Enums.Status
    createdAt?: DateTimeFilter<"CommandProject"> | Date | string
    updatedAt?: DateTimeFilter<"CommandProject"> | Date | string
  }

  export type WorkFlowUpsertWithoutProjectInput = {
    update: XOR<WorkFlowUpdateWithoutProjectInput, WorkFlowUncheckedUpdateWithoutProjectInput>
    create: XOR<WorkFlowCreateWithoutProjectInput, WorkFlowUncheckedCreateWithoutProjectInput>
    where?: WorkFlowWhereInput
  }

  export type WorkFlowUpdateToOneWithWhereWithoutProjectInput = {
    where?: WorkFlowWhereInput
    data: XOR<WorkFlowUpdateWithoutProjectInput, WorkFlowUncheckedUpdateWithoutProjectInput>
  }

  export type WorkFlowUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WorkFlowEdge?: WorkFlowEdgeUpdateManyWithoutWorkFlowNestedInput
    WorkflowNode?: WorkFlowNodeUpdateManyWithoutWorkFlowNestedInput
  }

  export type WorkFlowUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WorkFlowEdge?: WorkFlowEdgeUncheckedUpdateManyWithoutWorkFlowNestedInput
    WorkflowNode?: WorkFlowNodeUncheckedUpdateManyWithoutWorkFlowNestedInput
  }

  export type CommandProjectCreateWithoutCommandInput = {
    id?: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutCommandProjectsInput
    planings?: PlanningCreateNestedManyWithoutCommandProjectInput
    sprint?: SprintCreateNestedOneWithoutCommandProjectInput
  }

  export type CommandProjectUncheckedCreateWithoutCommandInput = {
    id?: string
    projectId: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    planings?: PlanningUncheckedCreateNestedManyWithoutCommandProjectInput
    sprint?: SprintUncheckedCreateNestedOneWithoutCommandProjectInput
  }

  export type CommandProjectCreateOrConnectWithoutCommandInput = {
    where: CommandProjectWhereUniqueInput
    create: XOR<CommandProjectCreateWithoutCommandInput, CommandProjectUncheckedCreateWithoutCommandInput>
  }

  export type CommandProjectCreateManyCommandInputEnvelope = {
    data: CommandProjectCreateManyCommandInput | CommandProjectCreateManyCommandInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCommandsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expertises?: ExpertiseCreateNestedManyWithoutUsersInput
    histories?: HistoryCreateNestedManyWithoutUserInput
    plannings?: PlanningCreateNestedManyWithoutOperatorInput
  }

  export type UserUncheckedCreateWithoutCommandsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expertises?: ExpertiseUncheckedCreateNestedManyWithoutUsersInput
    histories?: HistoryUncheckedCreateNestedManyWithoutUserInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type UserCreateOrConnectWithoutCommandsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
  }

  export type CommandProjectUpsertWithWhereUniqueWithoutCommandInput = {
    where: CommandProjectWhereUniqueInput
    update: XOR<CommandProjectUpdateWithoutCommandInput, CommandProjectUncheckedUpdateWithoutCommandInput>
    create: XOR<CommandProjectCreateWithoutCommandInput, CommandProjectUncheckedCreateWithoutCommandInput>
  }

  export type CommandProjectUpdateWithWhereUniqueWithoutCommandInput = {
    where: CommandProjectWhereUniqueInput
    data: XOR<CommandProjectUpdateWithoutCommandInput, CommandProjectUncheckedUpdateWithoutCommandInput>
  }

  export type CommandProjectUpdateManyWithWhereWithoutCommandInput = {
    where: CommandProjectScalarWhereInput
    data: XOR<CommandProjectUpdateManyMutationInput, CommandProjectUncheckedUpdateManyWithoutCommandInput>
  }

  export type UserUpsertWithoutCommandsInput = {
    update: XOR<UserUpdateWithoutCommandsInput, UserUncheckedUpdateWithoutCommandsInput>
    create: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommandsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommandsInput, UserUncheckedUpdateWithoutCommandsInput>
  }

  export type UserUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertises?: ExpertiseUpdateManyWithoutUsersNestedInput
    histories?: HistoryUpdateManyWithoutUserNestedInput
    plannings?: PlanningUpdateManyWithoutOperatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertises?: ExpertiseUncheckedUpdateManyWithoutUsersNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutUserNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type CommandCreateWithoutCommandProjectsInput = {
    id?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: UserCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateWithoutCommandProjectsInput = {
    id?: string
    reference: string
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandCreateOrConnectWithoutCommandProjectsInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutCommandProjectsInput, CommandUncheckedCreateWithoutCommandProjectsInput>
  }

  export type ProjectCreateWithoutCommandProjectsInput = {
    id?: string
    name: string
    description?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlow?: WorkFlowCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCommandProjectsInput = {
    id?: string
    name: string
    description?: string | null
    status?: boolean
    workFlowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutCommandProjectsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCommandProjectsInput, ProjectUncheckedCreateWithoutCommandProjectsInput>
  }

  export type PlanningCreateWithoutCommandProjectInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryCreateNestedManyWithoutPlanningInput
    operation: OperationCreateNestedOneWithoutPlanningsInput
    post: PostCreateNestedOneWithoutPlanningsInput
    operator: UserCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateWithoutCommandProjectInput = {
    id?: string
    operatorId: string
    postId: string
    operationId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceUncheckedCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutCommandProjectInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutCommandProjectInput, PlanningUncheckedCreateWithoutCommandProjectInput>
  }

  export type PlanningCreateManyCommandProjectInputEnvelope = {
    data: PlanningCreateManyCommandProjectInput | PlanningCreateManyCommandProjectInput[]
    skipDuplicates?: boolean
  }

  export type SprintCreateWithoutCommandProjectInput = {
    id?: string
    target: number
    days: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintUncheckedCreateWithoutCommandProjectInput = {
    id?: string
    target: number
    days: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintCreateOrConnectWithoutCommandProjectInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutCommandProjectInput, SprintUncheckedCreateWithoutCommandProjectInput>
  }

  export type CommandUpsertWithoutCommandProjectsInput = {
    update: XOR<CommandUpdateWithoutCommandProjectsInput, CommandUncheckedUpdateWithoutCommandProjectsInput>
    create: XOR<CommandCreateWithoutCommandProjectsInput, CommandUncheckedCreateWithoutCommandProjectsInput>
    where?: CommandWhereInput
  }

  export type CommandUpdateToOneWithWhereWithoutCommandProjectsInput = {
    where?: CommandWhereInput
    data: XOR<CommandUpdateWithoutCommandProjectsInput, CommandUncheckedUpdateWithoutCommandProjectsInput>
  }

  export type CommandUpdateWithoutCommandProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateWithoutCommandProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpsertWithoutCommandProjectsInput = {
    update: XOR<ProjectUpdateWithoutCommandProjectsInput, ProjectUncheckedUpdateWithoutCommandProjectsInput>
    create: XOR<ProjectCreateWithoutCommandProjectsInput, ProjectUncheckedCreateWithoutCommandProjectsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCommandProjectsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCommandProjectsInput, ProjectUncheckedUpdateWithoutCommandProjectsInput>
  }

  export type ProjectUpdateWithoutCommandProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlow?: WorkFlowUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCommandProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    workFlowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUpsertWithWhereUniqueWithoutCommandProjectInput = {
    where: PlanningWhereUniqueInput
    update: XOR<PlanningUpdateWithoutCommandProjectInput, PlanningUncheckedUpdateWithoutCommandProjectInput>
    create: XOR<PlanningCreateWithoutCommandProjectInput, PlanningUncheckedCreateWithoutCommandProjectInput>
  }

  export type PlanningUpdateWithWhereUniqueWithoutCommandProjectInput = {
    where: PlanningWhereUniqueInput
    data: XOR<PlanningUpdateWithoutCommandProjectInput, PlanningUncheckedUpdateWithoutCommandProjectInput>
  }

  export type PlanningUpdateManyWithWhereWithoutCommandProjectInput = {
    where: PlanningScalarWhereInput
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyWithoutCommandProjectInput>
  }

  export type SprintUpsertWithoutCommandProjectInput = {
    update: XOR<SprintUpdateWithoutCommandProjectInput, SprintUncheckedUpdateWithoutCommandProjectInput>
    create: XOR<SprintCreateWithoutCommandProjectInput, SprintUncheckedCreateWithoutCommandProjectInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutCommandProjectInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutCommandProjectInput, SprintUncheckedUpdateWithoutCommandProjectInput>
  }

  export type SprintUpdateWithoutCommandProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintUncheckedUpdateWithoutCommandProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateWithoutPostInput = {
    id?: string
    deviceId: string
    count?: number | null
    createdAt?: Date | string
    planning?: PlanningCreateNestedOneWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutPostInput = {
    id?: string
    deviceId: string
    planningId?: string | null
    count?: number | null
    createdAt?: Date | string
  }

  export type DeviceCreateOrConnectWithoutPostInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutPostInput, DeviceUncheckedCreateWithoutPostInput>
  }

  export type PlanningCreateWithoutPostInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryCreateNestedManyWithoutPlanningInput
    commandProject: CommandProjectCreateNestedOneWithoutPlaningsInput
    operation: OperationCreateNestedOneWithoutPlanningsInput
    operator: UserCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateWithoutPostInput = {
    id?: string
    operatorId: string
    operationId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceUncheckedCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutPostInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutPostInput, PlanningUncheckedCreateWithoutPostInput>
  }

  export type PlanningCreateManyPostInputEnvelope = {
    data: PlanningCreateManyPostInput | PlanningCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type OperationCreateWithoutPostsInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Expertise?: ExpertiseCreateNestedOneWithoutOperationsInput
    plannings?: PlanningCreateNestedManyWithoutOperationInput
    WorkflowNode?: WorkFlowNodeCreateNestedManyWithoutOperationInput
  }

  export type OperationUncheckedCreateWithoutPostsInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expertiseId?: string | null
    plannings?: PlanningUncheckedCreateNestedManyWithoutOperationInput
    WorkflowNode?: WorkFlowNodeUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutPostsInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutPostsInput, OperationUncheckedCreateWithoutPostsInput>
  }

  export type ExpertiseCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UserCreateNestedOneWithoutExpertisesInput
    operations?: OperationCreateNestedManyWithoutExpertiseInput
  }

  export type ExpertiseUncheckedCreateWithoutPostsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operations?: OperationUncheckedCreateNestedManyWithoutExpertiseInput
  }

  export type ExpertiseCreateOrConnectWithoutPostsInput = {
    where: ExpertiseWhereUniqueInput
    create: XOR<ExpertiseCreateWithoutPostsInput, ExpertiseUncheckedCreateWithoutPostsInput>
  }

  export type DeviceUpsertWithoutPostInput = {
    update: XOR<DeviceUpdateWithoutPostInput, DeviceUncheckedUpdateWithoutPostInput>
    create: XOR<DeviceCreateWithoutPostInput, DeviceUncheckedCreateWithoutPostInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutPostInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutPostInput, DeviceUncheckedUpdateWithoutPostInput>
  }

  export type DeviceUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planning?: PlanningUpdateOneWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUpsertWithWhereUniqueWithoutPostInput = {
    where: PlanningWhereUniqueInput
    update: XOR<PlanningUpdateWithoutPostInput, PlanningUncheckedUpdateWithoutPostInput>
    create: XOR<PlanningCreateWithoutPostInput, PlanningUncheckedCreateWithoutPostInput>
  }

  export type PlanningUpdateWithWhereUniqueWithoutPostInput = {
    where: PlanningWhereUniqueInput
    data: XOR<PlanningUpdateWithoutPostInput, PlanningUncheckedUpdateWithoutPostInput>
  }

  export type PlanningUpdateManyWithWhereWithoutPostInput = {
    where: PlanningScalarWhereInput
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyWithoutPostInput>
  }

  export type OperationUpsertWithoutPostsInput = {
    update: XOR<OperationUpdateWithoutPostsInput, OperationUncheckedUpdateWithoutPostsInput>
    create: XOR<OperationCreateWithoutPostsInput, OperationUncheckedCreateWithoutPostsInput>
    where?: OperationWhereInput
  }

  export type OperationUpdateToOneWithWhereWithoutPostsInput = {
    where?: OperationWhereInput
    data: XOR<OperationUpdateWithoutPostsInput, OperationUncheckedUpdateWithoutPostsInput>
  }

  export type OperationUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Expertise?: ExpertiseUpdateOneWithoutOperationsNestedInput
    plannings?: PlanningUpdateManyWithoutOperationNestedInput
    WorkflowNode?: WorkFlowNodeUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertiseId?: NullableStringFieldUpdateOperationsInput | string | null
    plannings?: PlanningUncheckedUpdateManyWithoutOperationNestedInput
    WorkflowNode?: WorkFlowNodeUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type ExpertiseUpsertWithWhereUniqueWithoutPostsInput = {
    where: ExpertiseWhereUniqueInput
    update: XOR<ExpertiseUpdateWithoutPostsInput, ExpertiseUncheckedUpdateWithoutPostsInput>
    create: XOR<ExpertiseCreateWithoutPostsInput, ExpertiseUncheckedCreateWithoutPostsInput>
  }

  export type ExpertiseUpdateWithWhereUniqueWithoutPostsInput = {
    where: ExpertiseWhereUniqueInput
    data: XOR<ExpertiseUpdateWithoutPostsInput, ExpertiseUncheckedUpdateWithoutPostsInput>
  }

  export type ExpertiseUpdateManyWithWhereWithoutPostsInput = {
    where: ExpertiseScalarWhereInput
    data: XOR<ExpertiseUpdateManyMutationInput, ExpertiseUncheckedUpdateManyWithoutPostsInput>
  }

  export type DeviceCreateWithoutPlanningInput = {
    id?: string
    deviceId: string
    count?: number | null
    createdAt?: Date | string
    post?: PostCreateNestedOneWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutPlanningInput = {
    id?: string
    deviceId: string
    postId?: string | null
    count?: number | null
    createdAt?: Date | string
  }

  export type DeviceCreateOrConnectWithoutPlanningInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutPlanningInput, DeviceUncheckedCreateWithoutPlanningInput>
  }

  export type OperationHistoryCreateWithoutPlanningInput = {
    id?: string
    count: number
    createdAt?: Date | string
  }

  export type OperationHistoryUncheckedCreateWithoutPlanningInput = {
    id?: string
    count: number
    createdAt?: Date | string
  }

  export type OperationHistoryCreateOrConnectWithoutPlanningInput = {
    where: OperationHistoryWhereUniqueInput
    create: XOR<OperationHistoryCreateWithoutPlanningInput, OperationHistoryUncheckedCreateWithoutPlanningInput>
  }

  export type OperationHistoryCreateManyPlanningInputEnvelope = {
    data: OperationHistoryCreateManyPlanningInput | OperationHistoryCreateManyPlanningInput[]
    skipDuplicates?: boolean
  }

  export type CommandProjectCreateWithoutPlaningsInput = {
    id?: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    command: CommandCreateNestedOneWithoutCommandProjectsInput
    project: ProjectCreateNestedOneWithoutCommandProjectsInput
    sprint?: SprintCreateNestedOneWithoutCommandProjectInput
  }

  export type CommandProjectUncheckedCreateWithoutPlaningsInput = {
    id?: string
    commandId: string
    projectId: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sprint?: SprintUncheckedCreateNestedOneWithoutCommandProjectInput
  }

  export type CommandProjectCreateOrConnectWithoutPlaningsInput = {
    where: CommandProjectWhereUniqueInput
    create: XOR<CommandProjectCreateWithoutPlaningsInput, CommandProjectUncheckedCreateWithoutPlaningsInput>
  }

  export type OperationCreateWithoutPlanningsInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Expertise?: ExpertiseCreateNestedOneWithoutOperationsInput
    posts?: PostCreateNestedManyWithoutOperationInput
    WorkflowNode?: WorkFlowNodeCreateNestedManyWithoutOperationInput
  }

  export type OperationUncheckedCreateWithoutPlanningsInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expertiseId?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutOperationInput
    WorkflowNode?: WorkFlowNodeUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutPlanningsInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutPlanningsInput, OperationUncheckedCreateWithoutPlanningsInput>
  }

  export type PostCreateWithoutPlanningsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPostInput
    Operation?: OperationCreateNestedOneWithoutPostsInput
    expertises?: ExpertiseCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutPlanningsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationId?: string | null
    device?: DeviceUncheckedCreateNestedOneWithoutPostInput
    expertises?: ExpertiseUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutPlanningsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPlanningsInput, PostUncheckedCreateWithoutPlanningsInput>
  }

  export type UserCreateWithoutPlanningsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutClientInput
    expertises?: ExpertiseCreateNestedManyWithoutUsersInput
    histories?: HistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlanningsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandUncheckedCreateNestedManyWithoutClientInput
    expertises?: ExpertiseUncheckedCreateNestedManyWithoutUsersInput
    histories?: HistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlanningsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlanningsInput, UserUncheckedCreateWithoutPlanningsInput>
  }

  export type DeviceUpsertWithoutPlanningInput = {
    update: XOR<DeviceUpdateWithoutPlanningInput, DeviceUncheckedUpdateWithoutPlanningInput>
    create: XOR<DeviceCreateWithoutPlanningInput, DeviceUncheckedCreateWithoutPlanningInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutPlanningInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutPlanningInput, DeviceUncheckedUpdateWithoutPlanningInput>
  }

  export type DeviceUpdateWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationHistoryUpsertWithWhereUniqueWithoutPlanningInput = {
    where: OperationHistoryWhereUniqueInput
    update: XOR<OperationHistoryUpdateWithoutPlanningInput, OperationHistoryUncheckedUpdateWithoutPlanningInput>
    create: XOR<OperationHistoryCreateWithoutPlanningInput, OperationHistoryUncheckedCreateWithoutPlanningInput>
  }

  export type OperationHistoryUpdateWithWhereUniqueWithoutPlanningInput = {
    where: OperationHistoryWhereUniqueInput
    data: XOR<OperationHistoryUpdateWithoutPlanningInput, OperationHistoryUncheckedUpdateWithoutPlanningInput>
  }

  export type OperationHistoryUpdateManyWithWhereWithoutPlanningInput = {
    where: OperationHistoryScalarWhereInput
    data: XOR<OperationHistoryUpdateManyMutationInput, OperationHistoryUncheckedUpdateManyWithoutPlanningInput>
  }

  export type OperationHistoryScalarWhereInput = {
    AND?: OperationHistoryScalarWhereInput | OperationHistoryScalarWhereInput[]
    OR?: OperationHistoryScalarWhereInput[]
    NOT?: OperationHistoryScalarWhereInput | OperationHistoryScalarWhereInput[]
    id?: StringFilter<"OperationHistory"> | string
    planningId?: StringFilter<"OperationHistory"> | string
    count?: IntFilter<"OperationHistory"> | number
    createdAt?: DateTimeFilter<"OperationHistory"> | Date | string
  }

  export type CommandProjectUpsertWithoutPlaningsInput = {
    update: XOR<CommandProjectUpdateWithoutPlaningsInput, CommandProjectUncheckedUpdateWithoutPlaningsInput>
    create: XOR<CommandProjectCreateWithoutPlaningsInput, CommandProjectUncheckedCreateWithoutPlaningsInput>
    where?: CommandProjectWhereInput
  }

  export type CommandProjectUpdateToOneWithWhereWithoutPlaningsInput = {
    where?: CommandProjectWhereInput
    data: XOR<CommandProjectUpdateWithoutPlaningsInput, CommandProjectUncheckedUpdateWithoutPlaningsInput>
  }

  export type CommandProjectUpdateWithoutPlaningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    command?: CommandUpdateOneRequiredWithoutCommandProjectsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCommandProjectsNestedInput
    sprint?: SprintUpdateOneWithoutCommandProjectNestedInput
  }

  export type CommandProjectUncheckedUpdateWithoutPlaningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprint?: SprintUncheckedUpdateOneWithoutCommandProjectNestedInput
  }

  export type OperationUpsertWithoutPlanningsInput = {
    update: XOR<OperationUpdateWithoutPlanningsInput, OperationUncheckedUpdateWithoutPlanningsInput>
    create: XOR<OperationCreateWithoutPlanningsInput, OperationUncheckedCreateWithoutPlanningsInput>
    where?: OperationWhereInput
  }

  export type OperationUpdateToOneWithWhereWithoutPlanningsInput = {
    where?: OperationWhereInput
    data: XOR<OperationUpdateWithoutPlanningsInput, OperationUncheckedUpdateWithoutPlanningsInput>
  }

  export type OperationUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Expertise?: ExpertiseUpdateOneWithoutOperationsNestedInput
    posts?: PostUpdateManyWithoutOperationNestedInput
    WorkflowNode?: WorkFlowNodeUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertiseId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutOperationNestedInput
    WorkflowNode?: WorkFlowNodeUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type PostUpsertWithoutPlanningsInput = {
    update: XOR<PostUpdateWithoutPlanningsInput, PostUncheckedUpdateWithoutPlanningsInput>
    create: XOR<PostCreateWithoutPlanningsInput, PostUncheckedCreateWithoutPlanningsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutPlanningsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutPlanningsInput, PostUncheckedUpdateWithoutPlanningsInput>
  }

  export type PostUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPostNestedInput
    Operation?: OperationUpdateOneWithoutPostsNestedInput
    expertises?: ExpertiseUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUncheckedUpdateOneWithoutPostNestedInput
    expertises?: ExpertiseUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserUpsertWithoutPlanningsInput = {
    update: XOR<UserUpdateWithoutPlanningsInput, UserUncheckedUpdateWithoutPlanningsInput>
    create: XOR<UserCreateWithoutPlanningsInput, UserUncheckedCreateWithoutPlanningsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlanningsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlanningsInput, UserUncheckedUpdateWithoutPlanningsInput>
  }

  export type UserUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutClientNestedInput
    expertises?: ExpertiseUpdateManyWithoutUsersNestedInput
    histories?: HistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUncheckedUpdateManyWithoutClientNestedInput
    expertises?: ExpertiseUncheckedUpdateManyWithoutUsersNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommandProjectCreateWithoutSprintInput = {
    id?: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    command: CommandCreateNestedOneWithoutCommandProjectsInput
    project: ProjectCreateNestedOneWithoutCommandProjectsInput
    planings?: PlanningCreateNestedManyWithoutCommandProjectInput
  }

  export type CommandProjectUncheckedCreateWithoutSprintInput = {
    id?: string
    commandId: string
    projectId: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    planings?: PlanningUncheckedCreateNestedManyWithoutCommandProjectInput
  }

  export type CommandProjectCreateOrConnectWithoutSprintInput = {
    where: CommandProjectWhereUniqueInput
    create: XOR<CommandProjectCreateWithoutSprintInput, CommandProjectUncheckedCreateWithoutSprintInput>
  }

  export type CommandProjectUpsertWithoutSprintInput = {
    update: XOR<CommandProjectUpdateWithoutSprintInput, CommandProjectUncheckedUpdateWithoutSprintInput>
    create: XOR<CommandProjectCreateWithoutSprintInput, CommandProjectUncheckedCreateWithoutSprintInput>
    where?: CommandProjectWhereInput
  }

  export type CommandProjectUpdateToOneWithWhereWithoutSprintInput = {
    where?: CommandProjectWhereInput
    data: XOR<CommandProjectUpdateWithoutSprintInput, CommandProjectUncheckedUpdateWithoutSprintInput>
  }

  export type CommandProjectUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    command?: CommandUpdateOneRequiredWithoutCommandProjectsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCommandProjectsNestedInput
    planings?: PlanningUpdateManyWithoutCommandProjectNestedInput
  }

  export type CommandProjectUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planings?: PlanningUncheckedUpdateManyWithoutCommandProjectNestedInput
  }

  export type ExpertiseCreateWithoutOperationsInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UserCreateNestedOneWithoutExpertisesInput
    posts?: PostCreateNestedManyWithoutExpertisesInput
  }

  export type ExpertiseUncheckedCreateWithoutOperationsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutExpertisesInput
  }

  export type ExpertiseCreateOrConnectWithoutOperationsInput = {
    where: ExpertiseWhereUniqueInput
    create: XOR<ExpertiseCreateWithoutOperationsInput, ExpertiseUncheckedCreateWithoutOperationsInput>
  }

  export type PlanningCreateWithoutOperationInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryCreateNestedManyWithoutPlanningInput
    commandProject: CommandProjectCreateNestedOneWithoutPlaningsInput
    post: PostCreateNestedOneWithoutPlanningsInput
    operator: UserCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateWithoutOperationInput = {
    id?: string
    operatorId: string
    postId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceUncheckedCreateNestedOneWithoutPlanningInput
    operationHistory?: OperationHistoryUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutOperationInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutOperationInput, PlanningUncheckedCreateWithoutOperationInput>
  }

  export type PlanningCreateManyOperationInputEnvelope = {
    data: PlanningCreateManyOperationInput | PlanningCreateManyOperationInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutOperationInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPostInput
    plannings?: PlanningCreateNestedManyWithoutPostInput
    expertises?: ExpertiseCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutOperationInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceUncheckedCreateNestedOneWithoutPostInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutPostInput
    expertises?: ExpertiseUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutOperationInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutOperationInput, PostUncheckedCreateWithoutOperationInput>
  }

  export type PostCreateManyOperationInputEnvelope = {
    data: PostCreateManyOperationInput | PostCreateManyOperationInput[]
    skipDuplicates?: boolean
  }

  export type WorkFlowNodeCreateWithoutOperationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeCreateNestedManyWithoutSourceInput
    sourceEdges?: WorkFlowEdgeCreateNestedManyWithoutTargetInput
    WorkFlow: WorkFlowCreateNestedOneWithoutWorkflowNodeInput
  }

  export type WorkFlowNodeUncheckedCreateWithoutOperationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    data: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUncheckedCreateNestedManyWithoutSourceInput
    sourceEdges?: WorkFlowEdgeUncheckedCreateNestedManyWithoutTargetInput
  }

  export type WorkFlowNodeCreateOrConnectWithoutOperationInput = {
    where: WorkFlowNodeWhereUniqueInput
    create: XOR<WorkFlowNodeCreateWithoutOperationInput, WorkFlowNodeUncheckedCreateWithoutOperationInput>
  }

  export type WorkFlowNodeCreateManyOperationInputEnvelope = {
    data: WorkFlowNodeCreateManyOperationInput | WorkFlowNodeCreateManyOperationInput[]
    skipDuplicates?: boolean
  }

  export type ExpertiseUpsertWithoutOperationsInput = {
    update: XOR<ExpertiseUpdateWithoutOperationsInput, ExpertiseUncheckedUpdateWithoutOperationsInput>
    create: XOR<ExpertiseCreateWithoutOperationsInput, ExpertiseUncheckedCreateWithoutOperationsInput>
    where?: ExpertiseWhereInput
  }

  export type ExpertiseUpdateToOneWithWhereWithoutOperationsInput = {
    where?: ExpertiseWhereInput
    data: XOR<ExpertiseUpdateWithoutOperationsInput, ExpertiseUncheckedUpdateWithoutOperationsInput>
  }

  export type ExpertiseUpdateWithoutOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutExpertisesNestedInput
    posts?: PostUpdateManyWithoutExpertisesNestedInput
  }

  export type ExpertiseUncheckedUpdateWithoutOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutExpertisesNestedInput
  }

  export type PlanningUpsertWithWhereUniqueWithoutOperationInput = {
    where: PlanningWhereUniqueInput
    update: XOR<PlanningUpdateWithoutOperationInput, PlanningUncheckedUpdateWithoutOperationInput>
    create: XOR<PlanningCreateWithoutOperationInput, PlanningUncheckedCreateWithoutOperationInput>
  }

  export type PlanningUpdateWithWhereUniqueWithoutOperationInput = {
    where: PlanningWhereUniqueInput
    data: XOR<PlanningUpdateWithoutOperationInput, PlanningUncheckedUpdateWithoutOperationInput>
  }

  export type PlanningUpdateManyWithWhereWithoutOperationInput = {
    where: PlanningScalarWhereInput
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyWithoutOperationInput>
  }

  export type PostUpsertWithWhereUniqueWithoutOperationInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutOperationInput, PostUncheckedUpdateWithoutOperationInput>
    create: XOR<PostCreateWithoutOperationInput, PostUncheckedCreateWithoutOperationInput>
  }

  export type PostUpdateWithWhereUniqueWithoutOperationInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutOperationInput, PostUncheckedUpdateWithoutOperationInput>
  }

  export type PostUpdateManyWithWhereWithoutOperationInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutOperationInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    operationId?: StringNullableFilter<"Post"> | string | null
  }

  export type WorkFlowNodeUpsertWithWhereUniqueWithoutOperationInput = {
    where: WorkFlowNodeWhereUniqueInput
    update: XOR<WorkFlowNodeUpdateWithoutOperationInput, WorkFlowNodeUncheckedUpdateWithoutOperationInput>
    create: XOR<WorkFlowNodeCreateWithoutOperationInput, WorkFlowNodeUncheckedCreateWithoutOperationInput>
  }

  export type WorkFlowNodeUpdateWithWhereUniqueWithoutOperationInput = {
    where: WorkFlowNodeWhereUniqueInput
    data: XOR<WorkFlowNodeUpdateWithoutOperationInput, WorkFlowNodeUncheckedUpdateWithoutOperationInput>
  }

  export type WorkFlowNodeUpdateManyWithWhereWithoutOperationInput = {
    where: WorkFlowNodeScalarWhereInput
    data: XOR<WorkFlowNodeUpdateManyMutationInput, WorkFlowNodeUncheckedUpdateManyWithoutOperationInput>
  }

  export type WorkFlowNodeScalarWhereInput = {
    AND?: WorkFlowNodeScalarWhereInput | WorkFlowNodeScalarWhereInput[]
    OR?: WorkFlowNodeScalarWhereInput[]
    NOT?: WorkFlowNodeScalarWhereInput | WorkFlowNodeScalarWhereInput[]
    id?: StringFilter<"WorkFlowNode"> | string
    createdAt?: DateTimeFilter<"WorkFlowNode"> | Date | string
    updatedAt?: DateTimeFilter<"WorkFlowNode"> | Date | string
    workFlowId?: StringFilter<"WorkFlowNode"> | string
    operationId?: StringFilter<"WorkFlowNode"> | string
    data?: JsonFilter<"WorkFlowNode">
  }

  export type WorkFlowEdgeCreateWithoutSourceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    count?: number
    target: WorkFlowNodeCreateNestedOneWithoutSourceEdgesInput
    WorkFlow: WorkFlowCreateNestedOneWithoutWorkFlowEdgeInput
  }

  export type WorkFlowEdgeUncheckedCreateWithoutSourceInput = {
    id?: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    data: JsonNullValueInput | InputJsonValue
    count?: number
  }

  export type WorkFlowEdgeCreateOrConnectWithoutSourceInput = {
    where: WorkFlowEdgeWhereUniqueInput
    create: XOR<WorkFlowEdgeCreateWithoutSourceInput, WorkFlowEdgeUncheckedCreateWithoutSourceInput>
  }

  export type WorkFlowEdgeCreateManySourceInputEnvelope = {
    data: WorkFlowEdgeCreateManySourceInput | WorkFlowEdgeCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type WorkFlowEdgeCreateWithoutTargetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    count?: number
    source: WorkFlowNodeCreateNestedOneWithoutTargetEdgesInput
    WorkFlow: WorkFlowCreateNestedOneWithoutWorkFlowEdgeInput
  }

  export type WorkFlowEdgeUncheckedCreateWithoutTargetInput = {
    id?: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    data: JsonNullValueInput | InputJsonValue
    count?: number
  }

  export type WorkFlowEdgeCreateOrConnectWithoutTargetInput = {
    where: WorkFlowEdgeWhereUniqueInput
    create: XOR<WorkFlowEdgeCreateWithoutTargetInput, WorkFlowEdgeUncheckedCreateWithoutTargetInput>
  }

  export type WorkFlowEdgeCreateManyTargetInputEnvelope = {
    data: WorkFlowEdgeCreateManyTargetInput | WorkFlowEdgeCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type OperationCreateWithoutWorkflowNodeInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Expertise?: ExpertiseCreateNestedOneWithoutOperationsInput
    plannings?: PlanningCreateNestedManyWithoutOperationInput
    posts?: PostCreateNestedManyWithoutOperationInput
  }

  export type OperationUncheckedCreateWithoutWorkflowNodeInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expertiseId?: string | null
    plannings?: PlanningUncheckedCreateNestedManyWithoutOperationInput
    posts?: PostUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutWorkflowNodeInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutWorkflowNodeInput, OperationUncheckedCreateWithoutWorkflowNodeInput>
  }

  export type WorkFlowCreateWithoutWorkflowNodeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutWorkFlowInput
    WorkFlowEdge?: WorkFlowEdgeCreateNestedManyWithoutWorkFlowInput
  }

  export type WorkFlowUncheckedCreateWithoutWorkflowNodeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectUncheckedCreateNestedOneWithoutWorkFlowInput
    WorkFlowEdge?: WorkFlowEdgeUncheckedCreateNestedManyWithoutWorkFlowInput
  }

  export type WorkFlowCreateOrConnectWithoutWorkflowNodeInput = {
    where: WorkFlowWhereUniqueInput
    create: XOR<WorkFlowCreateWithoutWorkflowNodeInput, WorkFlowUncheckedCreateWithoutWorkflowNodeInput>
  }

  export type WorkFlowEdgeUpsertWithWhereUniqueWithoutSourceInput = {
    where: WorkFlowEdgeWhereUniqueInput
    update: XOR<WorkFlowEdgeUpdateWithoutSourceInput, WorkFlowEdgeUncheckedUpdateWithoutSourceInput>
    create: XOR<WorkFlowEdgeCreateWithoutSourceInput, WorkFlowEdgeUncheckedCreateWithoutSourceInput>
  }

  export type WorkFlowEdgeUpdateWithWhereUniqueWithoutSourceInput = {
    where: WorkFlowEdgeWhereUniqueInput
    data: XOR<WorkFlowEdgeUpdateWithoutSourceInput, WorkFlowEdgeUncheckedUpdateWithoutSourceInput>
  }

  export type WorkFlowEdgeUpdateManyWithWhereWithoutSourceInput = {
    where: WorkFlowEdgeScalarWhereInput
    data: XOR<WorkFlowEdgeUpdateManyMutationInput, WorkFlowEdgeUncheckedUpdateManyWithoutSourceInput>
  }

  export type WorkFlowEdgeScalarWhereInput = {
    AND?: WorkFlowEdgeScalarWhereInput | WorkFlowEdgeScalarWhereInput[]
    OR?: WorkFlowEdgeScalarWhereInput[]
    NOT?: WorkFlowEdgeScalarWhereInput | WorkFlowEdgeScalarWhereInput[]
    id?: StringFilter<"WorkFlowEdge"> | string
    sourceId?: StringFilter<"WorkFlowEdge"> | string
    targetId?: StringFilter<"WorkFlowEdge"> | string
    createdAt?: DateTimeFilter<"WorkFlowEdge"> | Date | string
    updatedAt?: DateTimeFilter<"WorkFlowEdge"> | Date | string
    workFlowId?: StringFilter<"WorkFlowEdge"> | string
    data?: JsonFilter<"WorkFlowEdge">
    count?: IntFilter<"WorkFlowEdge"> | number
  }

  export type WorkFlowEdgeUpsertWithWhereUniqueWithoutTargetInput = {
    where: WorkFlowEdgeWhereUniqueInput
    update: XOR<WorkFlowEdgeUpdateWithoutTargetInput, WorkFlowEdgeUncheckedUpdateWithoutTargetInput>
    create: XOR<WorkFlowEdgeCreateWithoutTargetInput, WorkFlowEdgeUncheckedCreateWithoutTargetInput>
  }

  export type WorkFlowEdgeUpdateWithWhereUniqueWithoutTargetInput = {
    where: WorkFlowEdgeWhereUniqueInput
    data: XOR<WorkFlowEdgeUpdateWithoutTargetInput, WorkFlowEdgeUncheckedUpdateWithoutTargetInput>
  }

  export type WorkFlowEdgeUpdateManyWithWhereWithoutTargetInput = {
    where: WorkFlowEdgeScalarWhereInput
    data: XOR<WorkFlowEdgeUpdateManyMutationInput, WorkFlowEdgeUncheckedUpdateManyWithoutTargetInput>
  }

  export type OperationUpsertWithoutWorkflowNodeInput = {
    update: XOR<OperationUpdateWithoutWorkflowNodeInput, OperationUncheckedUpdateWithoutWorkflowNodeInput>
    create: XOR<OperationCreateWithoutWorkflowNodeInput, OperationUncheckedCreateWithoutWorkflowNodeInput>
    where?: OperationWhereInput
  }

  export type OperationUpdateToOneWithWhereWithoutWorkflowNodeInput = {
    where?: OperationWhereInput
    data: XOR<OperationUpdateWithoutWorkflowNodeInput, OperationUncheckedUpdateWithoutWorkflowNodeInput>
  }

  export type OperationUpdateWithoutWorkflowNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Expertise?: ExpertiseUpdateOneWithoutOperationsNestedInput
    plannings?: PlanningUpdateManyWithoutOperationNestedInput
    posts?: PostUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateWithoutWorkflowNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertiseId?: NullableStringFieldUpdateOperationsInput | string | null
    plannings?: PlanningUncheckedUpdateManyWithoutOperationNestedInput
    posts?: PostUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type WorkFlowUpsertWithoutWorkflowNodeInput = {
    update: XOR<WorkFlowUpdateWithoutWorkflowNodeInput, WorkFlowUncheckedUpdateWithoutWorkflowNodeInput>
    create: XOR<WorkFlowCreateWithoutWorkflowNodeInput, WorkFlowUncheckedCreateWithoutWorkflowNodeInput>
    where?: WorkFlowWhereInput
  }

  export type WorkFlowUpdateToOneWithWhereWithoutWorkflowNodeInput = {
    where?: WorkFlowWhereInput
    data: XOR<WorkFlowUpdateWithoutWorkflowNodeInput, WorkFlowUncheckedUpdateWithoutWorkflowNodeInput>
  }

  export type WorkFlowUpdateWithoutWorkflowNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutWorkFlowNestedInput
    WorkFlowEdge?: WorkFlowEdgeUpdateManyWithoutWorkFlowNestedInput
  }

  export type WorkFlowUncheckedUpdateWithoutWorkflowNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUncheckedUpdateOneWithoutWorkFlowNestedInput
    WorkFlowEdge?: WorkFlowEdgeUncheckedUpdateManyWithoutWorkFlowNestedInput
  }

  export type WorkFlowNodeCreateWithoutTargetEdgesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    sourceEdges?: WorkFlowEdgeCreateNestedManyWithoutTargetInput
    operation: OperationCreateNestedOneWithoutWorkflowNodeInput
    WorkFlow: WorkFlowCreateNestedOneWithoutWorkflowNodeInput
  }

  export type WorkFlowNodeUncheckedCreateWithoutTargetEdgesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    operationId: string
    data: JsonNullValueInput | InputJsonValue
    sourceEdges?: WorkFlowEdgeUncheckedCreateNestedManyWithoutTargetInput
  }

  export type WorkFlowNodeCreateOrConnectWithoutTargetEdgesInput = {
    where: WorkFlowNodeWhereUniqueInput
    create: XOR<WorkFlowNodeCreateWithoutTargetEdgesInput, WorkFlowNodeUncheckedCreateWithoutTargetEdgesInput>
  }

  export type WorkFlowNodeCreateWithoutSourceEdgesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeCreateNestedManyWithoutSourceInput
    operation: OperationCreateNestedOneWithoutWorkflowNodeInput
    WorkFlow: WorkFlowCreateNestedOneWithoutWorkflowNodeInput
  }

  export type WorkFlowNodeUncheckedCreateWithoutSourceEdgesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    operationId: string
    data: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUncheckedCreateNestedManyWithoutSourceInput
  }

  export type WorkFlowNodeCreateOrConnectWithoutSourceEdgesInput = {
    where: WorkFlowNodeWhereUniqueInput
    create: XOR<WorkFlowNodeCreateWithoutSourceEdgesInput, WorkFlowNodeUncheckedCreateWithoutSourceEdgesInput>
  }

  export type WorkFlowCreateWithoutWorkFlowEdgeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutWorkFlowInput
    WorkflowNode?: WorkFlowNodeCreateNestedManyWithoutWorkFlowInput
  }

  export type WorkFlowUncheckedCreateWithoutWorkFlowEdgeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectUncheckedCreateNestedOneWithoutWorkFlowInput
    WorkflowNode?: WorkFlowNodeUncheckedCreateNestedManyWithoutWorkFlowInput
  }

  export type WorkFlowCreateOrConnectWithoutWorkFlowEdgeInput = {
    where: WorkFlowWhereUniqueInput
    create: XOR<WorkFlowCreateWithoutWorkFlowEdgeInput, WorkFlowUncheckedCreateWithoutWorkFlowEdgeInput>
  }

  export type WorkFlowNodeUpsertWithoutTargetEdgesInput = {
    update: XOR<WorkFlowNodeUpdateWithoutTargetEdgesInput, WorkFlowNodeUncheckedUpdateWithoutTargetEdgesInput>
    create: XOR<WorkFlowNodeCreateWithoutTargetEdgesInput, WorkFlowNodeUncheckedCreateWithoutTargetEdgesInput>
    where?: WorkFlowNodeWhereInput
  }

  export type WorkFlowNodeUpdateToOneWithWhereWithoutTargetEdgesInput = {
    where?: WorkFlowNodeWhereInput
    data: XOR<WorkFlowNodeUpdateWithoutTargetEdgesInput, WorkFlowNodeUncheckedUpdateWithoutTargetEdgesInput>
  }

  export type WorkFlowNodeUpdateWithoutTargetEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    sourceEdges?: WorkFlowEdgeUpdateManyWithoutTargetNestedInput
    operation?: OperationUpdateOneRequiredWithoutWorkflowNodeNestedInput
    WorkFlow?: WorkFlowUpdateOneRequiredWithoutWorkflowNodeNestedInput
  }

  export type WorkFlowNodeUncheckedUpdateWithoutTargetEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    sourceEdges?: WorkFlowEdgeUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type WorkFlowNodeUpsertWithoutSourceEdgesInput = {
    update: XOR<WorkFlowNodeUpdateWithoutSourceEdgesInput, WorkFlowNodeUncheckedUpdateWithoutSourceEdgesInput>
    create: XOR<WorkFlowNodeCreateWithoutSourceEdgesInput, WorkFlowNodeUncheckedCreateWithoutSourceEdgesInput>
    where?: WorkFlowNodeWhereInput
  }

  export type WorkFlowNodeUpdateToOneWithWhereWithoutSourceEdgesInput = {
    where?: WorkFlowNodeWhereInput
    data: XOR<WorkFlowNodeUpdateWithoutSourceEdgesInput, WorkFlowNodeUncheckedUpdateWithoutSourceEdgesInput>
  }

  export type WorkFlowNodeUpdateWithoutSourceEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUpdateManyWithoutSourceNestedInput
    operation?: OperationUpdateOneRequiredWithoutWorkflowNodeNestedInput
    WorkFlow?: WorkFlowUpdateOneRequiredWithoutWorkflowNodeNestedInput
  }

  export type WorkFlowNodeUncheckedUpdateWithoutSourceEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type WorkFlowUpsertWithoutWorkFlowEdgeInput = {
    update: XOR<WorkFlowUpdateWithoutWorkFlowEdgeInput, WorkFlowUncheckedUpdateWithoutWorkFlowEdgeInput>
    create: XOR<WorkFlowCreateWithoutWorkFlowEdgeInput, WorkFlowUncheckedCreateWithoutWorkFlowEdgeInput>
    where?: WorkFlowWhereInput
  }

  export type WorkFlowUpdateToOneWithWhereWithoutWorkFlowEdgeInput = {
    where?: WorkFlowWhereInput
    data: XOR<WorkFlowUpdateWithoutWorkFlowEdgeInput, WorkFlowUncheckedUpdateWithoutWorkFlowEdgeInput>
  }

  export type WorkFlowUpdateWithoutWorkFlowEdgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutWorkFlowNestedInput
    WorkflowNode?: WorkFlowNodeUpdateManyWithoutWorkFlowNestedInput
  }

  export type WorkFlowUncheckedUpdateWithoutWorkFlowEdgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUncheckedUpdateOneWithoutWorkFlowNestedInput
    WorkflowNode?: WorkFlowNodeUncheckedUpdateManyWithoutWorkFlowNestedInput
  }

  export type ProjectCreateWithoutWorkFlowInput = {
    id?: string
    name: string
    description?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProjects?: CommandProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWorkFlowInput = {
    id?: string
    name: string
    description?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandProjects?: CommandProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWorkFlowInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWorkFlowInput, ProjectUncheckedCreateWithoutWorkFlowInput>
  }

  export type WorkFlowEdgeCreateWithoutWorkFlowInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    count?: number
    source: WorkFlowNodeCreateNestedOneWithoutTargetEdgesInput
    target: WorkFlowNodeCreateNestedOneWithoutSourceEdgesInput
  }

  export type WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput = {
    id?: string
    sourceId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    count?: number
  }

  export type WorkFlowEdgeCreateOrConnectWithoutWorkFlowInput = {
    where: WorkFlowEdgeWhereUniqueInput
    create: XOR<WorkFlowEdgeCreateWithoutWorkFlowInput, WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput>
  }

  export type WorkFlowEdgeCreateManyWorkFlowInputEnvelope = {
    data: WorkFlowEdgeCreateManyWorkFlowInput | WorkFlowEdgeCreateManyWorkFlowInput[]
    skipDuplicates?: boolean
  }

  export type WorkFlowNodeCreateWithoutWorkFlowInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeCreateNestedManyWithoutSourceInput
    sourceEdges?: WorkFlowEdgeCreateNestedManyWithoutTargetInput
    operation: OperationCreateNestedOneWithoutWorkflowNodeInput
  }

  export type WorkFlowNodeUncheckedCreateWithoutWorkFlowInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationId: string
    data: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUncheckedCreateNestedManyWithoutSourceInput
    sourceEdges?: WorkFlowEdgeUncheckedCreateNestedManyWithoutTargetInput
  }

  export type WorkFlowNodeCreateOrConnectWithoutWorkFlowInput = {
    where: WorkFlowNodeWhereUniqueInput
    create: XOR<WorkFlowNodeCreateWithoutWorkFlowInput, WorkFlowNodeUncheckedCreateWithoutWorkFlowInput>
  }

  export type WorkFlowNodeCreateManyWorkFlowInputEnvelope = {
    data: WorkFlowNodeCreateManyWorkFlowInput | WorkFlowNodeCreateManyWorkFlowInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutWorkFlowInput = {
    update: XOR<ProjectUpdateWithoutWorkFlowInput, ProjectUncheckedUpdateWithoutWorkFlowInput>
    create: XOR<ProjectCreateWithoutWorkFlowInput, ProjectUncheckedCreateWithoutWorkFlowInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWorkFlowInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWorkFlowInput, ProjectUncheckedUpdateWithoutWorkFlowInput>
  }

  export type ProjectUpdateWithoutWorkFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProjects?: CommandProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWorkFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProjects?: CommandProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type WorkFlowEdgeUpsertWithWhereUniqueWithoutWorkFlowInput = {
    where: WorkFlowEdgeWhereUniqueInput
    update: XOR<WorkFlowEdgeUpdateWithoutWorkFlowInput, WorkFlowEdgeUncheckedUpdateWithoutWorkFlowInput>
    create: XOR<WorkFlowEdgeCreateWithoutWorkFlowInput, WorkFlowEdgeUncheckedCreateWithoutWorkFlowInput>
  }

  export type WorkFlowEdgeUpdateWithWhereUniqueWithoutWorkFlowInput = {
    where: WorkFlowEdgeWhereUniqueInput
    data: XOR<WorkFlowEdgeUpdateWithoutWorkFlowInput, WorkFlowEdgeUncheckedUpdateWithoutWorkFlowInput>
  }

  export type WorkFlowEdgeUpdateManyWithWhereWithoutWorkFlowInput = {
    where: WorkFlowEdgeScalarWhereInput
    data: XOR<WorkFlowEdgeUpdateManyMutationInput, WorkFlowEdgeUncheckedUpdateManyWithoutWorkFlowInput>
  }

  export type WorkFlowNodeUpsertWithWhereUniqueWithoutWorkFlowInput = {
    where: WorkFlowNodeWhereUniqueInput
    update: XOR<WorkFlowNodeUpdateWithoutWorkFlowInput, WorkFlowNodeUncheckedUpdateWithoutWorkFlowInput>
    create: XOR<WorkFlowNodeCreateWithoutWorkFlowInput, WorkFlowNodeUncheckedCreateWithoutWorkFlowInput>
  }

  export type WorkFlowNodeUpdateWithWhereUniqueWithoutWorkFlowInput = {
    where: WorkFlowNodeWhereUniqueInput
    data: XOR<WorkFlowNodeUpdateWithoutWorkFlowInput, WorkFlowNodeUncheckedUpdateWithoutWorkFlowInput>
  }

  export type WorkFlowNodeUpdateManyWithWhereWithoutWorkFlowInput = {
    where: WorkFlowNodeScalarWhereInput
    data: XOR<WorkFlowNodeUpdateManyMutationInput, WorkFlowNodeUncheckedUpdateManyWithoutWorkFlowInput>
  }

  export type PlanningCreateWithoutOperationHistoryInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPlanningInput
    commandProject: CommandProjectCreateNestedOneWithoutPlaningsInput
    operation: OperationCreateNestedOneWithoutPlanningsInput
    post: PostCreateNestedOneWithoutPlanningsInput
    operator: UserCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateWithoutOperationHistoryInput = {
    id?: string
    operatorId: string
    postId: string
    operationId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceUncheckedCreateNestedOneWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutOperationHistoryInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutOperationHistoryInput, PlanningUncheckedCreateWithoutOperationHistoryInput>
  }

  export type PlanningUpsertWithoutOperationHistoryInput = {
    update: XOR<PlanningUpdateWithoutOperationHistoryInput, PlanningUncheckedUpdateWithoutOperationHistoryInput>
    create: XOR<PlanningCreateWithoutOperationHistoryInput, PlanningUncheckedCreateWithoutOperationHistoryInput>
    where?: PlanningWhereInput
  }

  export type PlanningUpdateToOneWithWhereWithoutOperationHistoryInput = {
    where?: PlanningWhereInput
    data: XOR<PlanningUpdateWithoutOperationHistoryInput, PlanningUncheckedUpdateWithoutOperationHistoryInput>
  }

  export type PlanningUpdateWithoutOperationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPlanningNestedInput
    commandProject?: CommandProjectUpdateOneRequiredWithoutPlaningsNestedInput
    operation?: OperationUpdateOneRequiredWithoutPlanningsNestedInput
    post?: PostUpdateOneRequiredWithoutPlanningsNestedInput
    operator?: UserUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateWithoutOperationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUncheckedUpdateOneWithoutPlanningNestedInput
  }

  export type UserCreateWithoutExpertisesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutClientInput
    histories?: HistoryCreateNestedManyWithoutUserInput
    plannings?: PlanningCreateNestedManyWithoutOperatorInput
  }

  export type UserUncheckedCreateWithoutExpertisesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandUncheckedCreateNestedManyWithoutClientInput
    histories?: HistoryUncheckedCreateNestedManyWithoutUserInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type UserCreateOrConnectWithoutExpertisesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpertisesInput, UserUncheckedCreateWithoutExpertisesInput>
  }

  export type OperationCreateWithoutExpertiseInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plannings?: PlanningCreateNestedManyWithoutOperationInput
    posts?: PostCreateNestedManyWithoutOperationInput
    WorkflowNode?: WorkFlowNodeCreateNestedManyWithoutOperationInput
  }

  export type OperationUncheckedCreateWithoutExpertiseInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plannings?: PlanningUncheckedCreateNestedManyWithoutOperationInput
    posts?: PostUncheckedCreateNestedManyWithoutOperationInput
    WorkflowNode?: WorkFlowNodeUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutExpertiseInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutExpertiseInput, OperationUncheckedCreateWithoutExpertiseInput>
  }

  export type OperationCreateManyExpertiseInputEnvelope = {
    data: OperationCreateManyExpertiseInput | OperationCreateManyExpertiseInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutExpertisesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutPostInput
    plannings?: PlanningCreateNestedManyWithoutPostInput
    Operation?: OperationCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutExpertisesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationId?: string | null
    device?: DeviceUncheckedCreateNestedOneWithoutPostInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutExpertisesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutExpertisesInput, PostUncheckedCreateWithoutExpertisesInput>
  }

  export type UserUpsertWithoutExpertisesInput = {
    update: XOR<UserUpdateWithoutExpertisesInput, UserUncheckedUpdateWithoutExpertisesInput>
    create: XOR<UserCreateWithoutExpertisesInput, UserUncheckedCreateWithoutExpertisesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpertisesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpertisesInput, UserUncheckedUpdateWithoutExpertisesInput>
  }

  export type UserUpdateWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutClientNestedInput
    histories?: HistoryUpdateManyWithoutUserNestedInput
    plannings?: PlanningUpdateManyWithoutOperatorNestedInput
  }

  export type UserUncheckedUpdateWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUncheckedUpdateManyWithoutClientNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutUserNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type OperationUpsertWithWhereUniqueWithoutExpertiseInput = {
    where: OperationWhereUniqueInput
    update: XOR<OperationUpdateWithoutExpertiseInput, OperationUncheckedUpdateWithoutExpertiseInput>
    create: XOR<OperationCreateWithoutExpertiseInput, OperationUncheckedCreateWithoutExpertiseInput>
  }

  export type OperationUpdateWithWhereUniqueWithoutExpertiseInput = {
    where: OperationWhereUniqueInput
    data: XOR<OperationUpdateWithoutExpertiseInput, OperationUncheckedUpdateWithoutExpertiseInput>
  }

  export type OperationUpdateManyWithWhereWithoutExpertiseInput = {
    where: OperationScalarWhereInput
    data: XOR<OperationUpdateManyMutationInput, OperationUncheckedUpdateManyWithoutExpertiseInput>
  }

  export type OperationScalarWhereInput = {
    AND?: OperationScalarWhereInput | OperationScalarWhereInput[]
    OR?: OperationScalarWhereInput[]
    NOT?: OperationScalarWhereInput | OperationScalarWhereInput[]
    id?: StringFilter<"Operation"> | string
    name?: StringFilter<"Operation"> | string
    code?: StringFilter<"Operation"> | string
    icon?: StringFilter<"Operation"> | string
    description?: StringNullableFilter<"Operation"> | string | null
    isFinal?: BoolFilter<"Operation"> | boolean
    estimatedTime?: IntFilter<"Operation"> | number
    createdAt?: DateTimeFilter<"Operation"> | Date | string
    updatedAt?: DateTimeFilter<"Operation"> | Date | string
    expertiseId?: StringNullableFilter<"Operation"> | string | null
  }

  export type PostUpsertWithWhereUniqueWithoutExpertisesInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutExpertisesInput, PostUncheckedUpdateWithoutExpertisesInput>
    create: XOR<PostCreateWithoutExpertisesInput, PostUncheckedCreateWithoutExpertisesInput>
  }

  export type PostUpdateWithWhereUniqueWithoutExpertisesInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutExpertisesInput, PostUncheckedUpdateWithoutExpertisesInput>
  }

  export type PostUpdateManyWithWhereWithoutExpertisesInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutExpertisesInput>
  }

  export type UserCreateWithoutHistoriesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutClientInput
    expertises?: ExpertiseCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutOperatorInput
  }

  export type UserUncheckedCreateWithoutHistoriesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    password: string
    image?: string | null
    phone?: string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandUncheckedCreateNestedManyWithoutClientInput
    expertises?: ExpertiseUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type UserCreateOrConnectWithoutHistoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHistoriesInput, UserUncheckedCreateWithoutHistoriesInput>
  }

  export type UserUpsertWithoutHistoriesInput = {
    update: XOR<UserUpdateWithoutHistoriesInput, UserUncheckedUpdateWithoutHistoriesInput>
    create: XOR<UserCreateWithoutHistoriesInput, UserUncheckedCreateWithoutHistoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHistoriesInput, UserUncheckedUpdateWithoutHistoriesInput>
  }

  export type UserUpdateWithoutHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutClientNestedInput
    expertises?: ExpertiseUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutOperatorNestedInput
  }

  export type UserUncheckedUpdateWithoutHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUncheckedUpdateManyWithoutClientNestedInput
    expertises?: ExpertiseUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type PlanningCreateWithoutDeviceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationHistory?: OperationHistoryCreateNestedManyWithoutPlanningInput
    commandProject: CommandProjectCreateNestedOneWithoutPlaningsInput
    operation: OperationCreateNestedOneWithoutPlanningsInput
    post: PostCreateNestedOneWithoutPlanningsInput
    operator: UserCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateWithoutDeviceInput = {
    id?: string
    operatorId: string
    postId: string
    operationId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationHistory?: OperationHistoryUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutDeviceInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutDeviceInput, PlanningUncheckedCreateWithoutDeviceInput>
  }

  export type PostCreateWithoutDeviceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plannings?: PlanningCreateNestedManyWithoutPostInput
    Operation?: OperationCreateNestedOneWithoutPostsInput
    expertises?: ExpertiseCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutDeviceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationId?: string | null
    plannings?: PlanningUncheckedCreateNestedManyWithoutPostInput
    expertises?: ExpertiseUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutDeviceInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutDeviceInput, PostUncheckedCreateWithoutDeviceInput>
  }

  export type PlanningUpsertWithoutDeviceInput = {
    update: XOR<PlanningUpdateWithoutDeviceInput, PlanningUncheckedUpdateWithoutDeviceInput>
    create: XOR<PlanningCreateWithoutDeviceInput, PlanningUncheckedCreateWithoutDeviceInput>
    where?: PlanningWhereInput
  }

  export type PlanningUpdateToOneWithWhereWithoutDeviceInput = {
    where?: PlanningWhereInput
    data: XOR<PlanningUpdateWithoutDeviceInput, PlanningUncheckedUpdateWithoutDeviceInput>
  }

  export type PlanningUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationHistory?: OperationHistoryUpdateManyWithoutPlanningNestedInput
    commandProject?: CommandProjectUpdateOneRequiredWithoutPlaningsNestedInput
    operation?: OperationUpdateOneRequiredWithoutPlanningsNestedInput
    post?: PostUpdateOneRequiredWithoutPlanningsNestedInput
    operator?: UserUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationHistory?: OperationHistoryUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type PostUpsertWithoutDeviceInput = {
    update: XOR<PostUpdateWithoutDeviceInput, PostUncheckedUpdateWithoutDeviceInput>
    create: XOR<PostCreateWithoutDeviceInput, PostUncheckedCreateWithoutDeviceInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutDeviceInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutDeviceInput, PostUncheckedUpdateWithoutDeviceInput>
  }

  export type PostUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannings?: PlanningUpdateManyWithoutPostNestedInput
    Operation?: OperationUpdateOneWithoutPostsNestedInput
    expertises?: ExpertiseUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationId?: NullableStringFieldUpdateOperationsInput | string | null
    plannings?: PlanningUncheckedUpdateManyWithoutPostNestedInput
    expertises?: ExpertiseUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type CommandCreateManyClientInput = {
    id?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpertiseCreateManyUsersInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HistoryCreateManyUserInput = {
    id?: string
    action: $Enums.ActionType
    entity?: $Enums.EntityType | null
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type PlanningCreateManyOperatorInput = {
    id?: string
    postId: string
    operationId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProjects?: CommandProjectUpdateManyWithoutCommandNestedInput
  }

  export type CommandUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandProjects?: CommandProjectUncheckedUpdateManyWithoutCommandNestedInput
  }

  export type CommandUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertiseUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operations?: OperationUpdateManyWithoutExpertiseNestedInput
    posts?: PostUpdateManyWithoutExpertisesNestedInput
  }

  export type ExpertiseUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operations?: OperationUncheckedUpdateManyWithoutExpertiseNestedInput
    posts?: PostUncheckedUpdateManyWithoutExpertisesNestedInput
  }

  export type ExpertiseUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entity?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entity?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entity?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUpdateManyWithoutPlanningNestedInput
    commandProject?: CommandProjectUpdateOneRequiredWithoutPlaningsNestedInput
    operation?: OperationUpdateOneRequiredWithoutPlanningsNestedInput
    post?: PostUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUncheckedUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type PlanningUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandProjectCreateManyProjectInput = {
    id?: string
    commandId: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandProjectUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    command?: CommandUpdateOneRequiredWithoutCommandProjectsNestedInput
    planings?: PlanningUpdateManyWithoutCommandProjectNestedInput
    sprint?: SprintUpdateOneWithoutCommandProjectNestedInput
  }

  export type CommandProjectUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandId?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planings?: PlanningUncheckedUpdateManyWithoutCommandProjectNestedInput
    sprint?: SprintUncheckedUpdateOneWithoutCommandProjectNestedInput
  }

  export type CommandProjectUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandId?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandProjectCreateManyCommandInput = {
    id?: string
    projectId: string
    target: number
    done?: number
    startDate?: Date | string | null
    endDate: Date | string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandProjectUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCommandProjectsNestedInput
    planings?: PlanningUpdateManyWithoutCommandProjectNestedInput
    sprint?: SprintUpdateOneWithoutCommandProjectNestedInput
  }

  export type CommandProjectUncheckedUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planings?: PlanningUncheckedUpdateManyWithoutCommandProjectNestedInput
    sprint?: SprintUncheckedUpdateOneWithoutCommandProjectNestedInput
  }

  export type CommandProjectUncheckedUpdateManyWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    target?: IntFieldUpdateOperationsInput | number
    done?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningCreateManyCommandProjectInput = {
    id?: string
    operatorId: string
    postId: string
    operationId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanningUpdateWithoutCommandProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUpdateManyWithoutPlanningNestedInput
    operation?: OperationUpdateOneRequiredWithoutPlanningsNestedInput
    post?: PostUpdateOneRequiredWithoutPlanningsNestedInput
    operator?: UserUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateWithoutCommandProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUncheckedUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type PlanningUncheckedUpdateManyWithoutCommandProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningCreateManyPostInput = {
    id?: string
    operatorId: string
    operationId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanningUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUpdateManyWithoutPlanningNestedInput
    commandProject?: CommandProjectUpdateOneRequiredWithoutPlaningsNestedInput
    operation?: OperationUpdateOneRequiredWithoutPlanningsNestedInput
    operator?: UserUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUncheckedUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type PlanningUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    operationId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertiseUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutExpertisesNestedInput
    operations?: OperationUpdateManyWithoutExpertiseNestedInput
  }

  export type ExpertiseUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operations?: OperationUncheckedUpdateManyWithoutExpertiseNestedInput
  }

  export type ExpertiseUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationHistoryCreateManyPlanningInput = {
    id?: string
    count: number
    createdAt?: Date | string
  }

  export type OperationHistoryUpdateWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationHistoryUncheckedUpdateWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationHistoryUncheckedUpdateManyWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningCreateManyOperationInput = {
    id?: string
    operatorId: string
    postId: string
    commandProjectId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyOperationInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkFlowNodeCreateManyOperationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type PlanningUpdateWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUpdateManyWithoutPlanningNestedInput
    commandProject?: CommandProjectUpdateOneRequiredWithoutPlaningsNestedInput
    post?: PostUpdateOneRequiredWithoutPlanningsNestedInput
    operator?: UserUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUncheckedUpdateOneWithoutPlanningNestedInput
    operationHistory?: OperationHistoryUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type PlanningUncheckedUpdateManyWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    commandProjectId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPostNestedInput
    plannings?: PlanningUpdateManyWithoutPostNestedInput
    expertises?: ExpertiseUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUncheckedUpdateOneWithoutPostNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutPostNestedInput
    expertises?: ExpertiseUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateManyWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkFlowNodeUpdateWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUpdateManyWithoutSourceNestedInput
    sourceEdges?: WorkFlowEdgeUpdateManyWithoutTargetNestedInput
    WorkFlow?: WorkFlowUpdateOneRequiredWithoutWorkflowNodeNestedInput
  }

  export type WorkFlowNodeUncheckedUpdateWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUncheckedUpdateManyWithoutSourceNestedInput
    sourceEdges?: WorkFlowEdgeUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type WorkFlowNodeUncheckedUpdateManyWithoutOperationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type WorkFlowEdgeCreateManySourceInput = {
    id?: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    data: JsonNullValueInput | InputJsonValue
    count?: number
  }

  export type WorkFlowEdgeCreateManyTargetInput = {
    id?: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workFlowId: string
    data: JsonNullValueInput | InputJsonValue
    count?: number
  }

  export type WorkFlowEdgeUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    target?: WorkFlowNodeUpdateOneRequiredWithoutSourceEdgesNestedInput
    WorkFlow?: WorkFlowUpdateOneRequiredWithoutWorkFlowEdgeNestedInput
  }

  export type WorkFlowEdgeUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowEdgeUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowEdgeUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    source?: WorkFlowNodeUpdateOneRequiredWithoutTargetEdgesNestedInput
    WorkFlow?: WorkFlowUpdateOneRequiredWithoutWorkFlowEdgeNestedInput
  }

  export type WorkFlowEdgeUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowEdgeUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workFlowId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowEdgeCreateManyWorkFlowInput = {
    id?: string
    sourceId: string
    targetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    count?: number
  }

  export type WorkFlowNodeCreateManyWorkFlowInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationId: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type WorkFlowEdgeUpdateWithoutWorkFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    source?: WorkFlowNodeUpdateOneRequiredWithoutTargetEdgesNestedInput
    target?: WorkFlowNodeUpdateOneRequiredWithoutSourceEdgesNestedInput
  }

  export type WorkFlowEdgeUncheckedUpdateWithoutWorkFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowEdgeUncheckedUpdateManyWithoutWorkFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkFlowNodeUpdateWithoutWorkFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUpdateManyWithoutSourceNestedInput
    sourceEdges?: WorkFlowEdgeUpdateManyWithoutTargetNestedInput
    operation?: OperationUpdateOneRequiredWithoutWorkflowNodeNestedInput
  }

  export type WorkFlowNodeUncheckedUpdateWithoutWorkFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    targetEdges?: WorkFlowEdgeUncheckedUpdateManyWithoutSourceNestedInput
    sourceEdges?: WorkFlowEdgeUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type WorkFlowNodeUncheckedUpdateManyWithoutWorkFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type OperationCreateManyExpertiseInput = {
    id: string
    name: string
    code: string
    icon: string
    description?: string | null
    isFinal?: boolean
    estimatedTime: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationUpdateWithoutExpertiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannings?: PlanningUpdateManyWithoutOperationNestedInput
    posts?: PostUpdateManyWithoutOperationNestedInput
    WorkflowNode?: WorkFlowNodeUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateWithoutExpertiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannings?: PlanningUncheckedUpdateManyWithoutOperationNestedInput
    posts?: PostUncheckedUpdateManyWithoutOperationNestedInput
    WorkflowNode?: WorkFlowNodeUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateManyWithoutExpertiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutPostNestedInput
    plannings?: PlanningUpdateManyWithoutPostNestedInput
    Operation?: OperationUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUncheckedUpdateOneWithoutPostNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommandCountOutputTypeDefaultArgs instead
     */
    export type CommandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommandProjectCountOutputTypeDefaultArgs instead
     */
    export type CommandProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommandProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanningCountOutputTypeDefaultArgs instead
     */
    export type PlanningCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanningCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationCountOutputTypeDefaultArgs instead
     */
    export type OperationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkFlowNodeCountOutputTypeDefaultArgs instead
     */
    export type WorkFlowNodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkFlowNodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkFlowCountOutputTypeDefaultArgs instead
     */
    export type WorkFlowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkFlowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpertiseCountOutputTypeDefaultArgs instead
     */
    export type ExpertiseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpertiseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommandDefaultArgs instead
     */
    export type CommandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommandProjectDefaultArgs instead
     */
    export type CommandProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommandProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanningDefaultArgs instead
     */
    export type PlanningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanningDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SprintDefaultArgs instead
     */
    export type SprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SprintDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationDefaultArgs instead
     */
    export type OperationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkFlowNodeDefaultArgs instead
     */
    export type WorkFlowNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkFlowNodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkFlowEdgeDefaultArgs instead
     */
    export type WorkFlowEdgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkFlowEdgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkFlowDefaultArgs instead
     */
    export type WorkFlowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkFlowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationHistoryDefaultArgs instead
     */
    export type OperationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpertiseDefaultArgs instead
     */
    export type ExpertiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpertiseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistoryDefaultArgs instead
     */
    export type HistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceDefaultArgs instead
     */
    export type DeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationRecordDefaultArgs instead
     */
    export type OperationRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationRecordDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}